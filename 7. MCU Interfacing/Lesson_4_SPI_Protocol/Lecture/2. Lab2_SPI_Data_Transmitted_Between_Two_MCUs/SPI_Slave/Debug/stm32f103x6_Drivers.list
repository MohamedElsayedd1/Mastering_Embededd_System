
stm32f103x6_Drivers.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000130  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00001048  08000130  08000130  00010130  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000060  08001178  08001178  00011178  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  080011d8  080011d8  00020034  2**0
                  CONTENTS
  4 .ARM          00000000  080011d8  080011d8  00020034  2**0
                  CONTENTS
  5 .preinit_array 00000000  080011d8  080011d8  00020034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  080011d8  080011d8  000111d8  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000004  080011dc  080011dc  000111dc  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         00000034  20000000  080011e0  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          00000070  20000034  08001214  00020034  2**2
                  ALLOC
 10 ._user_heap_stack 00000604  200000a4  08001214  000200a4  2**0
                  ALLOC
 11 .ARM.attributes 00000029  00000000  00000000  00020034  2**0
                  CONTENTS, READONLY
 12 .debug_info   000027e6  00000000  00000000  0002005d  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_abbrev 000007fe  00000000  00000000  00022843  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_loc    00000ef4  00000000  00000000  00023041  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_aranges 00000250  00000000  00000000  00023f38  2**3
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_ranges 000001e8  00000000  00000000  00024188  2**3
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_macro  00000296  00000000  00000000  00024370  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_line   000010c1  00000000  00000000  00024606  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_str    00004eab  00000000  00000000  000256c7  2**0
                  CONTENTS, READONLY, DEBUGGING
 20 .comment      0000007b  00000000  00000000  0002a572  2**0
                  CONTENTS, READONLY
 21 .debug_frame  0000079c  00000000  00000000  0002a5f0  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

08000130 <__do_global_dtors_aux>:
 8000130:	b510      	push	{r4, lr}
 8000132:	4c05      	ldr	r4, [pc, #20]	; (8000148 <__do_global_dtors_aux+0x18>)
 8000134:	7823      	ldrb	r3, [r4, #0]
 8000136:	b933      	cbnz	r3, 8000146 <__do_global_dtors_aux+0x16>
 8000138:	4b04      	ldr	r3, [pc, #16]	; (800014c <__do_global_dtors_aux+0x1c>)
 800013a:	b113      	cbz	r3, 8000142 <__do_global_dtors_aux+0x12>
 800013c:	4804      	ldr	r0, [pc, #16]	; (8000150 <__do_global_dtors_aux+0x20>)
 800013e:	f3af 8000 	nop.w
 8000142:	2301      	movs	r3, #1
 8000144:	7023      	strb	r3, [r4, #0]
 8000146:	bd10      	pop	{r4, pc}
 8000148:	20000034 	.word	0x20000034
 800014c:	00000000 	.word	0x00000000
 8000150:	08001160 	.word	0x08001160

08000154 <frame_dummy>:
 8000154:	b508      	push	{r3, lr}
 8000156:	4b03      	ldr	r3, [pc, #12]	; (8000164 <frame_dummy+0x10>)
 8000158:	b11b      	cbz	r3, 8000162 <frame_dummy+0xe>
 800015a:	4903      	ldr	r1, [pc, #12]	; (8000168 <frame_dummy+0x14>)
 800015c:	4803      	ldr	r0, [pc, #12]	; (800016c <frame_dummy+0x18>)
 800015e:	f3af 8000 	nop.w
 8000162:	bd08      	pop	{r3, pc}
 8000164:	00000000 	.word	0x00000000
 8000168:	20000038 	.word	0x20000038
 800016c:	08001160 	.word	0x08001160

08000170 <EXTI0_IRQHandler>:

/* ================================================================ */
/* ========================= ISR Functions ======================== */
/* ================================================================ */

void EXTI0_IRQHandler(void){
 8000170:	b580      	push	{r7, lr}
 8000172:	af00      	add	r7, sp, #0
	// This bit is cleared by writing a ‘1’ into the bit
	SET_BIT(EXTI->PR, 0);
 8000174:	4b07      	ldr	r3, [pc, #28]	; (8000194 <EXTI0_IRQHandler+0x24>)
 8000176:	695b      	ldr	r3, [r3, #20]
 8000178:	4a06      	ldr	r2, [pc, #24]	; (8000194 <EXTI0_IRQHandler+0x24>)
 800017a:	f043 0301 	orr.w	r3, r3, #1
 800017e:	6153      	str	r3, [r2, #20]
	// Call IRQ Call Back Function
	if (EXTI_CallBacks[0] != NULL) {
 8000180:	4b05      	ldr	r3, [pc, #20]	; (8000198 <EXTI0_IRQHandler+0x28>)
 8000182:	681b      	ldr	r3, [r3, #0]
 8000184:	2b00      	cmp	r3, #0
 8000186:	d002      	beq.n	800018e <EXTI0_IRQHandler+0x1e>
		EXTI_CallBacks[0]();
 8000188:	4b03      	ldr	r3, [pc, #12]	; (8000198 <EXTI0_IRQHandler+0x28>)
 800018a:	681b      	ldr	r3, [r3, #0]
 800018c:	4798      	blx	r3
	}
}
 800018e:	bf00      	nop
 8000190:	bd80      	pop	{r7, pc}
 8000192:	bf00      	nop
 8000194:	40010400 	.word	0x40010400
 8000198:	20000050 	.word	0x20000050

0800019c <EXTI1_IRQHandler>:

void EXTI1_IRQHandler(void){
 800019c:	b580      	push	{r7, lr}
 800019e:	af00      	add	r7, sp, #0
	// This bit is cleared by writing a ‘1’ into the bit
	SET_BIT(EXTI->PR, 1);
 80001a0:	4b07      	ldr	r3, [pc, #28]	; (80001c0 <EXTI1_IRQHandler+0x24>)
 80001a2:	695b      	ldr	r3, [r3, #20]
 80001a4:	4a06      	ldr	r2, [pc, #24]	; (80001c0 <EXTI1_IRQHandler+0x24>)
 80001a6:	f043 0302 	orr.w	r3, r3, #2
 80001aa:	6153      	str	r3, [r2, #20]
	// Call IRQ Call Back Function
	if (EXTI_CallBacks[1] != NULL) {
 80001ac:	4b05      	ldr	r3, [pc, #20]	; (80001c4 <EXTI1_IRQHandler+0x28>)
 80001ae:	685b      	ldr	r3, [r3, #4]
 80001b0:	2b00      	cmp	r3, #0
 80001b2:	d002      	beq.n	80001ba <EXTI1_IRQHandler+0x1e>
		EXTI_CallBacks[1]();
 80001b4:	4b03      	ldr	r3, [pc, #12]	; (80001c4 <EXTI1_IRQHandler+0x28>)
 80001b6:	685b      	ldr	r3, [r3, #4]
 80001b8:	4798      	blx	r3
	}
}
 80001ba:	bf00      	nop
 80001bc:	bd80      	pop	{r7, pc}
 80001be:	bf00      	nop
 80001c0:	40010400 	.word	0x40010400
 80001c4:	20000050 	.word	0x20000050

080001c8 <EXTI2_IRQHandler>:

void EXTI2_IRQHandler(void){
 80001c8:	b580      	push	{r7, lr}
 80001ca:	af00      	add	r7, sp, #0
	// This bit is cleared by writing a ‘1’ into the bit
	SET_BIT(EXTI->PR, 2);
 80001cc:	4b07      	ldr	r3, [pc, #28]	; (80001ec <EXTI2_IRQHandler+0x24>)
 80001ce:	695b      	ldr	r3, [r3, #20]
 80001d0:	4a06      	ldr	r2, [pc, #24]	; (80001ec <EXTI2_IRQHandler+0x24>)
 80001d2:	f043 0304 	orr.w	r3, r3, #4
 80001d6:	6153      	str	r3, [r2, #20]
	// Call IRQ Call Back Function
	if (EXTI_CallBacks[2] != NULL) {
 80001d8:	4b05      	ldr	r3, [pc, #20]	; (80001f0 <EXTI2_IRQHandler+0x28>)
 80001da:	689b      	ldr	r3, [r3, #8]
 80001dc:	2b00      	cmp	r3, #0
 80001de:	d002      	beq.n	80001e6 <EXTI2_IRQHandler+0x1e>
		EXTI_CallBacks[2]();
 80001e0:	4b03      	ldr	r3, [pc, #12]	; (80001f0 <EXTI2_IRQHandler+0x28>)
 80001e2:	689b      	ldr	r3, [r3, #8]
 80001e4:	4798      	blx	r3
	}
}
 80001e6:	bf00      	nop
 80001e8:	bd80      	pop	{r7, pc}
 80001ea:	bf00      	nop
 80001ec:	40010400 	.word	0x40010400
 80001f0:	20000050 	.word	0x20000050

080001f4 <EXTI3_IRQHandler>:

void EXTI3_IRQHandler(void){
 80001f4:	b580      	push	{r7, lr}
 80001f6:	af00      	add	r7, sp, #0
	// This bit is cleared by writing a ‘1’ into the bit
	SET_BIT(EXTI->PR, 3);
 80001f8:	4b07      	ldr	r3, [pc, #28]	; (8000218 <EXTI3_IRQHandler+0x24>)
 80001fa:	695b      	ldr	r3, [r3, #20]
 80001fc:	4a06      	ldr	r2, [pc, #24]	; (8000218 <EXTI3_IRQHandler+0x24>)
 80001fe:	f043 0308 	orr.w	r3, r3, #8
 8000202:	6153      	str	r3, [r2, #20]
	// Call IRQ Call Back Function
	if (EXTI_CallBacks[3] != NULL) {
 8000204:	4b05      	ldr	r3, [pc, #20]	; (800021c <EXTI3_IRQHandler+0x28>)
 8000206:	68db      	ldr	r3, [r3, #12]
 8000208:	2b00      	cmp	r3, #0
 800020a:	d002      	beq.n	8000212 <EXTI3_IRQHandler+0x1e>
		EXTI_CallBacks[3]();
 800020c:	4b03      	ldr	r3, [pc, #12]	; (800021c <EXTI3_IRQHandler+0x28>)
 800020e:	68db      	ldr	r3, [r3, #12]
 8000210:	4798      	blx	r3
	}
}
 8000212:	bf00      	nop
 8000214:	bd80      	pop	{r7, pc}
 8000216:	bf00      	nop
 8000218:	40010400 	.word	0x40010400
 800021c:	20000050 	.word	0x20000050

08000220 <EXTI4_IRQHandler>:

void EXTI4_IRQHandler(void){
 8000220:	b580      	push	{r7, lr}
 8000222:	af00      	add	r7, sp, #0
	// This bit is cleared by writing a ‘1’ into the bit
	SET_BIT(EXTI->PR, 4);
 8000224:	4b07      	ldr	r3, [pc, #28]	; (8000244 <EXTI4_IRQHandler+0x24>)
 8000226:	695b      	ldr	r3, [r3, #20]
 8000228:	4a06      	ldr	r2, [pc, #24]	; (8000244 <EXTI4_IRQHandler+0x24>)
 800022a:	f043 0310 	orr.w	r3, r3, #16
 800022e:	6153      	str	r3, [r2, #20]
	// Call IRQ Call Back Function
	if (EXTI_CallBacks[4] != NULL) {
 8000230:	4b05      	ldr	r3, [pc, #20]	; (8000248 <EXTI4_IRQHandler+0x28>)
 8000232:	691b      	ldr	r3, [r3, #16]
 8000234:	2b00      	cmp	r3, #0
 8000236:	d002      	beq.n	800023e <EXTI4_IRQHandler+0x1e>
		EXTI_CallBacks[4]();
 8000238:	4b03      	ldr	r3, [pc, #12]	; (8000248 <EXTI4_IRQHandler+0x28>)
 800023a:	691b      	ldr	r3, [r3, #16]
 800023c:	4798      	blx	r3
	}
}
 800023e:	bf00      	nop
 8000240:	bd80      	pop	{r7, pc}
 8000242:	bf00      	nop
 8000244:	40010400 	.word	0x40010400
 8000248:	20000050 	.word	0x20000050

0800024c <EXTI9_5_IRQHandler>:

void EXTI9_5_IRQHandler(void){
 800024c:	b580      	push	{r7, lr}
 800024e:	af00      	add	r7, sp, #0
	if(EXTI_INTERRUPET_TRIGGERED == READ_BIT(EXTI->PR, 5)){
 8000250:	4b34      	ldr	r3, [pc, #208]	; (8000324 <EXTI9_5_IRQHandler+0xd8>)
 8000252:	695b      	ldr	r3, [r3, #20]
 8000254:	095b      	lsrs	r3, r3, #5
 8000256:	f003 0301 	and.w	r3, r3, #1
 800025a:	2b01      	cmp	r3, #1
 800025c:	d10d      	bne.n	800027a <EXTI9_5_IRQHandler+0x2e>
		// This bit is cleared by writing a ‘1’ into the bit
		SET_BIT(EXTI->PR, 5);
 800025e:	4b31      	ldr	r3, [pc, #196]	; (8000324 <EXTI9_5_IRQHandler+0xd8>)
 8000260:	695b      	ldr	r3, [r3, #20]
 8000262:	4a30      	ldr	r2, [pc, #192]	; (8000324 <EXTI9_5_IRQHandler+0xd8>)
 8000264:	f043 0320 	orr.w	r3, r3, #32
 8000268:	6153      	str	r3, [r2, #20]
		// Call IRQ Call Back Function
		if (EXTI_CallBacks[5] != NULL) {
 800026a:	4b2f      	ldr	r3, [pc, #188]	; (8000328 <EXTI9_5_IRQHandler+0xdc>)
 800026c:	695b      	ldr	r3, [r3, #20]
 800026e:	2b00      	cmp	r3, #0
 8000270:	d056      	beq.n	8000320 <EXTI9_5_IRQHandler+0xd4>
			EXTI_CallBacks[5]();
 8000272:	4b2d      	ldr	r3, [pc, #180]	; (8000328 <EXTI9_5_IRQHandler+0xdc>)
 8000274:	695b      	ldr	r3, [r3, #20]
 8000276:	4798      	blx	r3
		// Call IRQ Call Back Function
		if (EXTI_CallBacks[9] != NULL) {
			EXTI_CallBacks[9]();
		}
	}
}
 8000278:	e052      	b.n	8000320 <EXTI9_5_IRQHandler+0xd4>
	else if(EXTI_INTERRUPET_TRIGGERED == READ_BIT(EXTI->PR, 6)){
 800027a:	4b2a      	ldr	r3, [pc, #168]	; (8000324 <EXTI9_5_IRQHandler+0xd8>)
 800027c:	695b      	ldr	r3, [r3, #20]
 800027e:	099b      	lsrs	r3, r3, #6
 8000280:	f003 0301 	and.w	r3, r3, #1
 8000284:	2b01      	cmp	r3, #1
 8000286:	d10d      	bne.n	80002a4 <EXTI9_5_IRQHandler+0x58>
		SET_BIT(EXTI->PR, 6);
 8000288:	4b26      	ldr	r3, [pc, #152]	; (8000324 <EXTI9_5_IRQHandler+0xd8>)
 800028a:	695b      	ldr	r3, [r3, #20]
 800028c:	4a25      	ldr	r2, [pc, #148]	; (8000324 <EXTI9_5_IRQHandler+0xd8>)
 800028e:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8000292:	6153      	str	r3, [r2, #20]
		if (EXTI_CallBacks[6] != NULL) {
 8000294:	4b24      	ldr	r3, [pc, #144]	; (8000328 <EXTI9_5_IRQHandler+0xdc>)
 8000296:	699b      	ldr	r3, [r3, #24]
 8000298:	2b00      	cmp	r3, #0
 800029a:	d041      	beq.n	8000320 <EXTI9_5_IRQHandler+0xd4>
			EXTI_CallBacks[6]();
 800029c:	4b22      	ldr	r3, [pc, #136]	; (8000328 <EXTI9_5_IRQHandler+0xdc>)
 800029e:	699b      	ldr	r3, [r3, #24]
 80002a0:	4798      	blx	r3
}
 80002a2:	e03d      	b.n	8000320 <EXTI9_5_IRQHandler+0xd4>
	else if(EXTI_INTERRUPET_TRIGGERED == READ_BIT(EXTI->PR, 7)){
 80002a4:	4b1f      	ldr	r3, [pc, #124]	; (8000324 <EXTI9_5_IRQHandler+0xd8>)
 80002a6:	695b      	ldr	r3, [r3, #20]
 80002a8:	09db      	lsrs	r3, r3, #7
 80002aa:	f003 0301 	and.w	r3, r3, #1
 80002ae:	2b01      	cmp	r3, #1
 80002b0:	d10d      	bne.n	80002ce <EXTI9_5_IRQHandler+0x82>
		SET_BIT(EXTI->PR, 7);
 80002b2:	4b1c      	ldr	r3, [pc, #112]	; (8000324 <EXTI9_5_IRQHandler+0xd8>)
 80002b4:	695b      	ldr	r3, [r3, #20]
 80002b6:	4a1b      	ldr	r2, [pc, #108]	; (8000324 <EXTI9_5_IRQHandler+0xd8>)
 80002b8:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80002bc:	6153      	str	r3, [r2, #20]
		if (EXTI_CallBacks[7] != NULL) {
 80002be:	4b1a      	ldr	r3, [pc, #104]	; (8000328 <EXTI9_5_IRQHandler+0xdc>)
 80002c0:	69db      	ldr	r3, [r3, #28]
 80002c2:	2b00      	cmp	r3, #0
 80002c4:	d02c      	beq.n	8000320 <EXTI9_5_IRQHandler+0xd4>
			EXTI_CallBacks[7]();
 80002c6:	4b18      	ldr	r3, [pc, #96]	; (8000328 <EXTI9_5_IRQHandler+0xdc>)
 80002c8:	69db      	ldr	r3, [r3, #28]
 80002ca:	4798      	blx	r3
}
 80002cc:	e028      	b.n	8000320 <EXTI9_5_IRQHandler+0xd4>
	else if(EXTI_INTERRUPET_TRIGGERED == READ_BIT(EXTI->PR, 8)){
 80002ce:	4b15      	ldr	r3, [pc, #84]	; (8000324 <EXTI9_5_IRQHandler+0xd8>)
 80002d0:	695b      	ldr	r3, [r3, #20]
 80002d2:	0a1b      	lsrs	r3, r3, #8
 80002d4:	f003 0301 	and.w	r3, r3, #1
 80002d8:	2b01      	cmp	r3, #1
 80002da:	d10d      	bne.n	80002f8 <EXTI9_5_IRQHandler+0xac>
		SET_BIT(EXTI->PR, 8);
 80002dc:	4b11      	ldr	r3, [pc, #68]	; (8000324 <EXTI9_5_IRQHandler+0xd8>)
 80002de:	695b      	ldr	r3, [r3, #20]
 80002e0:	4a10      	ldr	r2, [pc, #64]	; (8000324 <EXTI9_5_IRQHandler+0xd8>)
 80002e2:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80002e6:	6153      	str	r3, [r2, #20]
		if (EXTI_CallBacks[8] != NULL) {
 80002e8:	4b0f      	ldr	r3, [pc, #60]	; (8000328 <EXTI9_5_IRQHandler+0xdc>)
 80002ea:	6a1b      	ldr	r3, [r3, #32]
 80002ec:	2b00      	cmp	r3, #0
 80002ee:	d017      	beq.n	8000320 <EXTI9_5_IRQHandler+0xd4>
			EXTI_CallBacks[8]();
 80002f0:	4b0d      	ldr	r3, [pc, #52]	; (8000328 <EXTI9_5_IRQHandler+0xdc>)
 80002f2:	6a1b      	ldr	r3, [r3, #32]
 80002f4:	4798      	blx	r3
}
 80002f6:	e013      	b.n	8000320 <EXTI9_5_IRQHandler+0xd4>
	else if(EXTI_INTERRUPET_TRIGGERED == READ_BIT(EXTI->PR, 9)){
 80002f8:	4b0a      	ldr	r3, [pc, #40]	; (8000324 <EXTI9_5_IRQHandler+0xd8>)
 80002fa:	695b      	ldr	r3, [r3, #20]
 80002fc:	0a5b      	lsrs	r3, r3, #9
 80002fe:	f003 0301 	and.w	r3, r3, #1
 8000302:	2b01      	cmp	r3, #1
 8000304:	d10c      	bne.n	8000320 <EXTI9_5_IRQHandler+0xd4>
		SET_BIT(EXTI->PR, 9);
 8000306:	4b07      	ldr	r3, [pc, #28]	; (8000324 <EXTI9_5_IRQHandler+0xd8>)
 8000308:	695b      	ldr	r3, [r3, #20]
 800030a:	4a06      	ldr	r2, [pc, #24]	; (8000324 <EXTI9_5_IRQHandler+0xd8>)
 800030c:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8000310:	6153      	str	r3, [r2, #20]
		if (EXTI_CallBacks[9] != NULL) {
 8000312:	4b05      	ldr	r3, [pc, #20]	; (8000328 <EXTI9_5_IRQHandler+0xdc>)
 8000314:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8000316:	2b00      	cmp	r3, #0
 8000318:	d002      	beq.n	8000320 <EXTI9_5_IRQHandler+0xd4>
			EXTI_CallBacks[9]();
 800031a:	4b03      	ldr	r3, [pc, #12]	; (8000328 <EXTI9_5_IRQHandler+0xdc>)
 800031c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800031e:	4798      	blx	r3
}
 8000320:	bf00      	nop
 8000322:	bd80      	pop	{r7, pc}
 8000324:	40010400 	.word	0x40010400
 8000328:	20000050 	.word	0x20000050

0800032c <EXTI15_10_IRQHandler>:

void EXTI15_10_IRQHandler(void){
 800032c:	b580      	push	{r7, lr}
 800032e:	af00      	add	r7, sp, #0
	if(EXTI_INTERRUPET_TRIGGERED == READ_BIT(EXTI->PR, 10)){
 8000330:	4b3f      	ldr	r3, [pc, #252]	; (8000430 <EXTI15_10_IRQHandler+0x104>)
 8000332:	695b      	ldr	r3, [r3, #20]
 8000334:	0a9b      	lsrs	r3, r3, #10
 8000336:	f003 0301 	and.w	r3, r3, #1
 800033a:	2b01      	cmp	r3, #1
 800033c:	d10d      	bne.n	800035a <EXTI15_10_IRQHandler+0x2e>
		// This bit is cleared by writing a ‘1’ into the bit
		SET_BIT(EXTI->PR, 10);
 800033e:	4b3c      	ldr	r3, [pc, #240]	; (8000430 <EXTI15_10_IRQHandler+0x104>)
 8000340:	695b      	ldr	r3, [r3, #20]
 8000342:	4a3b      	ldr	r2, [pc, #236]	; (8000430 <EXTI15_10_IRQHandler+0x104>)
 8000344:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8000348:	6153      	str	r3, [r2, #20]
		// Call IRQ Call Back Function
		if (EXTI_CallBacks[10] != NULL) {
 800034a:	4b3a      	ldr	r3, [pc, #232]	; (8000434 <EXTI15_10_IRQHandler+0x108>)
 800034c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800034e:	2b00      	cmp	r3, #0
 8000350:	d06b      	beq.n	800042a <EXTI15_10_IRQHandler+0xfe>
			EXTI_CallBacks[10]();
 8000352:	4b38      	ldr	r3, [pc, #224]	; (8000434 <EXTI15_10_IRQHandler+0x108>)
 8000354:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8000356:	4798      	blx	r3
		// Call IRQ Call Back Function
		if (EXTI_CallBacks[15] != NULL) {
			EXTI_CallBacks[15]();
		}
	}
}
 8000358:	e067      	b.n	800042a <EXTI15_10_IRQHandler+0xfe>
	else if(EXTI_INTERRUPET_TRIGGERED == READ_BIT(EXTI->PR, 11)){
 800035a:	4b35      	ldr	r3, [pc, #212]	; (8000430 <EXTI15_10_IRQHandler+0x104>)
 800035c:	695b      	ldr	r3, [r3, #20]
 800035e:	0adb      	lsrs	r3, r3, #11
 8000360:	f003 0301 	and.w	r3, r3, #1
 8000364:	2b01      	cmp	r3, #1
 8000366:	d10d      	bne.n	8000384 <EXTI15_10_IRQHandler+0x58>
		SET_BIT(EXTI->PR, 11);
 8000368:	4b31      	ldr	r3, [pc, #196]	; (8000430 <EXTI15_10_IRQHandler+0x104>)
 800036a:	695b      	ldr	r3, [r3, #20]
 800036c:	4a30      	ldr	r2, [pc, #192]	; (8000430 <EXTI15_10_IRQHandler+0x104>)
 800036e:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8000372:	6153      	str	r3, [r2, #20]
		if (EXTI_CallBacks[11] != NULL) {
 8000374:	4b2f      	ldr	r3, [pc, #188]	; (8000434 <EXTI15_10_IRQHandler+0x108>)
 8000376:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8000378:	2b00      	cmp	r3, #0
 800037a:	d056      	beq.n	800042a <EXTI15_10_IRQHandler+0xfe>
			EXTI_CallBacks[11]();
 800037c:	4b2d      	ldr	r3, [pc, #180]	; (8000434 <EXTI15_10_IRQHandler+0x108>)
 800037e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8000380:	4798      	blx	r3
}
 8000382:	e052      	b.n	800042a <EXTI15_10_IRQHandler+0xfe>
	else if(EXTI_INTERRUPET_TRIGGERED == READ_BIT(EXTI->PR, 12)){
 8000384:	4b2a      	ldr	r3, [pc, #168]	; (8000430 <EXTI15_10_IRQHandler+0x104>)
 8000386:	695b      	ldr	r3, [r3, #20]
 8000388:	0b1b      	lsrs	r3, r3, #12
 800038a:	f003 0301 	and.w	r3, r3, #1
 800038e:	2b01      	cmp	r3, #1
 8000390:	d10d      	bne.n	80003ae <EXTI15_10_IRQHandler+0x82>
		SET_BIT(EXTI->PR, 12);
 8000392:	4b27      	ldr	r3, [pc, #156]	; (8000430 <EXTI15_10_IRQHandler+0x104>)
 8000394:	695b      	ldr	r3, [r3, #20]
 8000396:	4a26      	ldr	r2, [pc, #152]	; (8000430 <EXTI15_10_IRQHandler+0x104>)
 8000398:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 800039c:	6153      	str	r3, [r2, #20]
		if (EXTI_CallBacks[12] != NULL) {
 800039e:	4b25      	ldr	r3, [pc, #148]	; (8000434 <EXTI15_10_IRQHandler+0x108>)
 80003a0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80003a2:	2b00      	cmp	r3, #0
 80003a4:	d041      	beq.n	800042a <EXTI15_10_IRQHandler+0xfe>
			EXTI_CallBacks[12]();
 80003a6:	4b23      	ldr	r3, [pc, #140]	; (8000434 <EXTI15_10_IRQHandler+0x108>)
 80003a8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80003aa:	4798      	blx	r3
}
 80003ac:	e03d      	b.n	800042a <EXTI15_10_IRQHandler+0xfe>
	else if(EXTI_INTERRUPET_TRIGGERED == READ_BIT(EXTI->PR, 13)){
 80003ae:	4b20      	ldr	r3, [pc, #128]	; (8000430 <EXTI15_10_IRQHandler+0x104>)
 80003b0:	695b      	ldr	r3, [r3, #20]
 80003b2:	0b5b      	lsrs	r3, r3, #13
 80003b4:	f003 0301 	and.w	r3, r3, #1
 80003b8:	2b01      	cmp	r3, #1
 80003ba:	d10d      	bne.n	80003d8 <EXTI15_10_IRQHandler+0xac>
		SET_BIT(EXTI->PR, 13);
 80003bc:	4b1c      	ldr	r3, [pc, #112]	; (8000430 <EXTI15_10_IRQHandler+0x104>)
 80003be:	695b      	ldr	r3, [r3, #20]
 80003c0:	4a1b      	ldr	r2, [pc, #108]	; (8000430 <EXTI15_10_IRQHandler+0x104>)
 80003c2:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 80003c6:	6153      	str	r3, [r2, #20]
		if (EXTI_CallBacks[13] != NULL) {
 80003c8:	4b1a      	ldr	r3, [pc, #104]	; (8000434 <EXTI15_10_IRQHandler+0x108>)
 80003ca:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80003cc:	2b00      	cmp	r3, #0
 80003ce:	d02c      	beq.n	800042a <EXTI15_10_IRQHandler+0xfe>
			EXTI_CallBacks[13]();
 80003d0:	4b18      	ldr	r3, [pc, #96]	; (8000434 <EXTI15_10_IRQHandler+0x108>)
 80003d2:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80003d4:	4798      	blx	r3
}
 80003d6:	e028      	b.n	800042a <EXTI15_10_IRQHandler+0xfe>
	else if(EXTI_INTERRUPET_TRIGGERED == READ_BIT(EXTI->PR, 14)){
 80003d8:	4b15      	ldr	r3, [pc, #84]	; (8000430 <EXTI15_10_IRQHandler+0x104>)
 80003da:	695b      	ldr	r3, [r3, #20]
 80003dc:	0b9b      	lsrs	r3, r3, #14
 80003de:	f003 0301 	and.w	r3, r3, #1
 80003e2:	2b01      	cmp	r3, #1
 80003e4:	d10d      	bne.n	8000402 <EXTI15_10_IRQHandler+0xd6>
		SET_BIT(EXTI->PR, 14);
 80003e6:	4b12      	ldr	r3, [pc, #72]	; (8000430 <EXTI15_10_IRQHandler+0x104>)
 80003e8:	695b      	ldr	r3, [r3, #20]
 80003ea:	4a11      	ldr	r2, [pc, #68]	; (8000430 <EXTI15_10_IRQHandler+0x104>)
 80003ec:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 80003f0:	6153      	str	r3, [r2, #20]
		if (EXTI_CallBacks[14] != NULL) {
 80003f2:	4b10      	ldr	r3, [pc, #64]	; (8000434 <EXTI15_10_IRQHandler+0x108>)
 80003f4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80003f6:	2b00      	cmp	r3, #0
 80003f8:	d017      	beq.n	800042a <EXTI15_10_IRQHandler+0xfe>
			EXTI_CallBacks[14]();
 80003fa:	4b0e      	ldr	r3, [pc, #56]	; (8000434 <EXTI15_10_IRQHandler+0x108>)
 80003fc:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80003fe:	4798      	blx	r3
}
 8000400:	e013      	b.n	800042a <EXTI15_10_IRQHandler+0xfe>
	else if(EXTI_INTERRUPET_TRIGGERED == READ_BIT(EXTI->PR, 15)){
 8000402:	4b0b      	ldr	r3, [pc, #44]	; (8000430 <EXTI15_10_IRQHandler+0x104>)
 8000404:	695b      	ldr	r3, [r3, #20]
 8000406:	0bdb      	lsrs	r3, r3, #15
 8000408:	f003 0301 	and.w	r3, r3, #1
 800040c:	2b01      	cmp	r3, #1
 800040e:	d10c      	bne.n	800042a <EXTI15_10_IRQHandler+0xfe>
		SET_BIT(EXTI->PR, 15);
 8000410:	4b07      	ldr	r3, [pc, #28]	; (8000430 <EXTI15_10_IRQHandler+0x104>)
 8000412:	695b      	ldr	r3, [r3, #20]
 8000414:	4a06      	ldr	r2, [pc, #24]	; (8000430 <EXTI15_10_IRQHandler+0x104>)
 8000416:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800041a:	6153      	str	r3, [r2, #20]
		if (EXTI_CallBacks[15] != NULL) {
 800041c:	4b05      	ldr	r3, [pc, #20]	; (8000434 <EXTI15_10_IRQHandler+0x108>)
 800041e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8000420:	2b00      	cmp	r3, #0
 8000422:	d002      	beq.n	800042a <EXTI15_10_IRQHandler+0xfe>
			EXTI_CallBacks[15]();
 8000424:	4b03      	ldr	r3, [pc, #12]	; (8000434 <EXTI15_10_IRQHandler+0x108>)
 8000426:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8000428:	4798      	blx	r3
}
 800042a:	bf00      	nop
 800042c:	bd80      	pop	{r7, pc}
 800042e:	bf00      	nop
 8000430:	40010400 	.word	0x40010400
 8000434:	20000050 	.word	0x20000050

08000438 <MCAL_GPIO_Init>:
 *
 * @Retval    None
 *
 * @Note      This function must be called before performing any operation on the pin.
 */
void MCAL_GPIO_Init(GPIO_t *GPIOx, GPIO_PinConfig_t *PinConfig){
 8000438:	b480      	push	{r7}
 800043a:	b085      	sub	sp, #20
 800043c:	af00      	add	r7, sp, #0
 800043e:	6078      	str	r0, [r7, #4]
 8000440:	6039      	str	r1, [r7, #0]
	volatile uint32 *configRegister = NULL;
 8000442:	2300      	movs	r3, #0
 8000444:	60fb      	str	r3, [r7, #12]
	uint8 shift = 0;
 8000446:	2300      	movs	r3, #0
 8000448:	72fb      	strb	r3, [r7, #11]
	uint8 pin = PinConfig->PinNum ;
 800044a:	683b      	ldr	r3, [r7, #0]
 800044c:	781b      	ldrb	r3, [r3, #0]
 800044e:	72bb      	strb	r3, [r7, #10]

	if(pin >= 0 && pin <= 7){
 8000450:	7abb      	ldrb	r3, [r7, #10]
 8000452:	2b07      	cmp	r3, #7
 8000454:	d805      	bhi.n	8000462 <MCAL_GPIO_Init+0x2a>
		// Port configuration register low (GPIOx_CRL) 0>>7
		configRegister = &(GPIOx->CRL);
 8000456:	687b      	ldr	r3, [r7, #4]
 8000458:	60fb      	str	r3, [r7, #12]
		shift = (pin * 4);
 800045a:	7abb      	ldrb	r3, [r7, #10]
 800045c:	009b      	lsls	r3, r3, #2
 800045e:	72fb      	strb	r3, [r7, #11]
 8000460:	e00d      	b.n	800047e <MCAL_GPIO_Init+0x46>
	}
	else if(pin >= 8 && pin <= 15){
 8000462:	7abb      	ldrb	r3, [r7, #10]
 8000464:	2b07      	cmp	r3, #7
 8000466:	d94c      	bls.n	8000502 <MCAL_GPIO_Init+0xca>
 8000468:	7abb      	ldrb	r3, [r7, #10]
 800046a:	2b0f      	cmp	r3, #15
 800046c:	d849      	bhi.n	8000502 <MCAL_GPIO_Init+0xca>
		// Port configuration register high (GPIOx_CRH) 8>>15
		configRegister = &(GPIOx->CRH);
 800046e:	687b      	ldr	r3, [r7, #4]
 8000470:	3304      	adds	r3, #4
 8000472:	60fb      	str	r3, [r7, #12]
		shift = ((pin - 8) * 4);
 8000474:	7abb      	ldrb	r3, [r7, #10]
 8000476:	3338      	adds	r3, #56	; 0x38
 8000478:	b2db      	uxtb	r3, r3
 800047a:	009b      	lsls	r3, r3, #2
 800047c:	72fb      	strb	r3, [r7, #11]
	else{
		return;
	}

	// Clear the current configuration for the pin
	*configRegister &= ~(0xF << shift);
 800047e:	68fb      	ldr	r3, [r7, #12]
 8000480:	681b      	ldr	r3, [r3, #0]
 8000482:	7afa      	ldrb	r2, [r7, #11]
 8000484:	210f      	movs	r1, #15
 8000486:	fa01 f202 	lsl.w	r2, r1, r2
 800048a:	43d2      	mvns	r2, r2
 800048c:	401a      	ands	r2, r3
 800048e:	68fb      	ldr	r3, [r7, #12]
 8000490:	601a      	str	r2, [r3, #0]

	if(PinConfig->PinCNF == GPIO_CNF_PULL_UP_DOWN_INPUT){
 8000492:	683b      	ldr	r3, [r7, #0]
 8000494:	78db      	ldrb	r3, [r3, #3]
 8000496:	2b02      	cmp	r3, #2
 8000498:	d119      	bne.n	80004ce <MCAL_GPIO_Init+0x96>
		// Configure Pin State : High OR Low
		if(PinConfig->PinState == GPIO_HIGH){
 800049a:	683b      	ldr	r3, [r7, #0]
 800049c:	789b      	ldrb	r3, [r3, #2]
 800049e:	2b01      	cmp	r3, #1
 80004a0:	d10a      	bne.n	80004b8 <MCAL_GPIO_Init+0x80>
			SET_BIT(GPIOx->ODR, PinConfig->PinNum);		 // Enable pull-up
 80004a2:	687b      	ldr	r3, [r7, #4]
 80004a4:	68db      	ldr	r3, [r3, #12]
 80004a6:	683a      	ldr	r2, [r7, #0]
 80004a8:	7812      	ldrb	r2, [r2, #0]
 80004aa:	4611      	mov	r1, r2
 80004ac:	2201      	movs	r2, #1
 80004ae:	408a      	lsls	r2, r1
 80004b0:	431a      	orrs	r2, r3
 80004b2:	687b      	ldr	r3, [r7, #4]
 80004b4:	60da      	str	r2, [r3, #12]
 80004b6:	e00a      	b.n	80004ce <MCAL_GPIO_Init+0x96>
		}
		else{
			CLEAR_BIT(GPIOx->ODR, PinConfig->PinNum);	// Enable pull-down
 80004b8:	687b      	ldr	r3, [r7, #4]
 80004ba:	68db      	ldr	r3, [r3, #12]
 80004bc:	683a      	ldr	r2, [r7, #0]
 80004be:	7812      	ldrb	r2, [r2, #0]
 80004c0:	4611      	mov	r1, r2
 80004c2:	2201      	movs	r2, #1
 80004c4:	408a      	lsls	r2, r1
 80004c6:	43d2      	mvns	r2, r2
 80004c8:	401a      	ands	r2, r3
 80004ca:	687b      	ldr	r3, [r7, #4]
 80004cc:	60da      	str	r2, [r3, #12]
		}
	}

	// Set the mode and configuration
	*configRegister |= ((PinConfig->PinMode & 0x03) << shift);		 // MODE[1:0]
 80004ce:	68fb      	ldr	r3, [r7, #12]
 80004d0:	681b      	ldr	r3, [r3, #0]
 80004d2:	683a      	ldr	r2, [r7, #0]
 80004d4:	7852      	ldrb	r2, [r2, #1]
 80004d6:	f002 0103 	and.w	r1, r2, #3
 80004da:	7afa      	ldrb	r2, [r7, #11]
 80004dc:	fa01 f202 	lsl.w	r2, r1, r2
 80004e0:	431a      	orrs	r2, r3
 80004e2:	68fb      	ldr	r3, [r7, #12]
 80004e4:	601a      	str	r2, [r3, #0]
	*configRegister |= ((PinConfig->PinCNF & 0x03) << (shift+2));	 // CNF[1:0]
 80004e6:	68fb      	ldr	r3, [r7, #12]
 80004e8:	681b      	ldr	r3, [r3, #0]
 80004ea:	683a      	ldr	r2, [r7, #0]
 80004ec:	78d2      	ldrb	r2, [r2, #3]
 80004ee:	f002 0103 	and.w	r1, r2, #3
 80004f2:	7afa      	ldrb	r2, [r7, #11]
 80004f4:	3202      	adds	r2, #2
 80004f6:	fa01 f202 	lsl.w	r2, r1, r2
 80004fa:	431a      	orrs	r2, r3
 80004fc:	68fb      	ldr	r3, [r7, #12]
 80004fe:	601a      	str	r2, [r3, #0]
 8000500:	e000      	b.n	8000504 <MCAL_GPIO_Init+0xcc>
		return;
 8000502:	bf00      	nop


}
 8000504:	3714      	adds	r7, #20
 8000506:	46bd      	mov	sp, r7
 8000508:	bc80      	pop	{r7}
 800050a:	4770      	bx	lr

0800050c <MCAL_RCC_GetSYSCLK_Freq>:
#include "stm32f103x6_RCC_driver.h"

static const uint32 AHP_Prescaler_Table[16] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 6, 7, 8, 9};
static const uint32 ABP_Prescaler_Table[8] = {0, 0, 0, 0, 1, 2, 3, 4};

uint32 MCAL_RCC_GetSYSCLK_Freq(){
 800050c:	b480      	push	{r7}
 800050e:	af00      	add	r7, sp, #0
	switch((RCC->CFGR >> 2) & 0x3){
 8000510:	4b09      	ldr	r3, [pc, #36]	; (8000538 <MCAL_RCC_GetSYSCLK_Freq+0x2c>)
 8000512:	685b      	ldr	r3, [r3, #4]
 8000514:	089b      	lsrs	r3, r3, #2
 8000516:	f003 0303 	and.w	r3, r3, #3
 800051a:	2b01      	cmp	r3, #1
 800051c:	d007      	beq.n	800052e <MCAL_RCC_GetSYSCLK_Freq+0x22>
 800051e:	2b01      	cmp	r3, #1
 8000520:	d303      	bcc.n	800052a <MCAL_RCC_GetSYSCLK_Freq+0x1e>
 8000522:	2b02      	cmp	r3, #2
		case RCC_HSE_CLOCK :
			return HSE_RC_FREQ;
			break;
		case RCC_PLL_CLOCK :
			// Select PLLSRC, Choose PLLMUL, Return PLLCLK
			break;
 8000524:	bf00      	nop
	}
	return RCC_HSI_CLOCK; // by default
 8000526:	2300      	movs	r3, #0
 8000528:	e002      	b.n	8000530 <MCAL_RCC_GetSYSCLK_Freq+0x24>
			return HSI_RC_FREQ;
 800052a:	4b04      	ldr	r3, [pc, #16]	; (800053c <MCAL_RCC_GetSYSCLK_Freq+0x30>)
 800052c:	e000      	b.n	8000530 <MCAL_RCC_GetSYSCLK_Freq+0x24>
			return HSE_RC_FREQ;
 800052e:	4b04      	ldr	r3, [pc, #16]	; (8000540 <MCAL_RCC_GetSYSCLK_Freq+0x34>)
}
 8000530:	4618      	mov	r0, r3
 8000532:	46bd      	mov	sp, r7
 8000534:	bc80      	pop	{r7}
 8000536:	4770      	bx	lr
 8000538:	40021000 	.word	0x40021000
 800053c:	007a1200 	.word	0x007a1200
 8000540:	00f42400 	.word	0x00f42400

08000544 <MCAL_RCC_GetHCLK_Freq>:

uint32 MCAL_RCC_GetHCLK_Freq(){
 8000544:	b580      	push	{r7, lr}
 8000546:	b084      	sub	sp, #16
 8000548:	af00      	add	r7, sp, #0
	uint32 SYSCLK = MCAL_RCC_GetSYSCLK_Freq();
 800054a:	f7ff ffdf 	bl	800050c <MCAL_RCC_GetSYSCLK_Freq>
 800054e:	60f8      	str	r0, [r7, #12]
			1100: SYSCLK divided by 64
			1101: SYSCLK divided by 128
			1110: SYSCLK divided by 256
			1111: SYSCLK divided by 512
	 */
	uint32 AHB_Prescale = ((RCC->CFGR >> 4) & 0xF);
 8000550:	4b09      	ldr	r3, [pc, #36]	; (8000578 <MCAL_RCC_GetHCLK_Freq+0x34>)
 8000552:	685b      	ldr	r3, [r3, #4]
 8000554:	091b      	lsrs	r3, r3, #4
 8000556:	f003 030f 	and.w	r3, r3, #15
 800055a:	60bb      	str	r3, [r7, #8]
	uint32 HCLK = ((uint32)SYSCLK >> AHP_Prescaler_Table[AHB_Prescale]);
 800055c:	4a07      	ldr	r2, [pc, #28]	; (800057c <MCAL_RCC_GetHCLK_Freq+0x38>)
 800055e:	68bb      	ldr	r3, [r7, #8]
 8000560:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8000564:	68fa      	ldr	r2, [r7, #12]
 8000566:	fa22 f303 	lsr.w	r3, r2, r3
 800056a:	607b      	str	r3, [r7, #4]
	return HCLK;
 800056c:	687b      	ldr	r3, [r7, #4]
}
 800056e:	4618      	mov	r0, r3
 8000570:	3710      	adds	r7, #16
 8000572:	46bd      	mov	sp, r7
 8000574:	bd80      	pop	{r7, pc}
 8000576:	bf00      	nop
 8000578:	40021000 	.word	0x40021000
 800057c:	08001178 	.word	0x08001178

08000580 <MCAL_RCC_GetPCLK1_Freq>:

uint32 MCAL_RCC_GetPCLK1_Freq(){
 8000580:	b580      	push	{r7, lr}
 8000582:	b084      	sub	sp, #16
 8000584:	af00      	add	r7, sp, #0
	uint32 HCLK = MCAL_RCC_GetHCLK_Freq();
 8000586:	f7ff ffdd 	bl	8000544 <MCAL_RCC_GetHCLK_Freq>
 800058a:	60f8      	str	r0, [r7, #12]
		100: HCLK divided by 2
		101: HCLK divided by 4
		110: HCLK divided by 8
		111: HCLK divided by 16
	*/
	uint32 ABP1_Prescale = ((RCC->CFGR >> 8) & 0x3);
 800058c:	4b09      	ldr	r3, [pc, #36]	; (80005b4 <MCAL_RCC_GetPCLK1_Freq+0x34>)
 800058e:	685b      	ldr	r3, [r3, #4]
 8000590:	0a1b      	lsrs	r3, r3, #8
 8000592:	f003 0303 	and.w	r3, r3, #3
 8000596:	60bb      	str	r3, [r7, #8]
	uint32 PCLK1 = ((uint32)HCLK >> ABP_Prescaler_Table[ABP1_Prescale]);
 8000598:	4a07      	ldr	r2, [pc, #28]	; (80005b8 <MCAL_RCC_GetPCLK1_Freq+0x38>)
 800059a:	68bb      	ldr	r3, [r7, #8]
 800059c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80005a0:	68fa      	ldr	r2, [r7, #12]
 80005a2:	fa22 f303 	lsr.w	r3, r2, r3
 80005a6:	607b      	str	r3, [r7, #4]
	return PCLK1;
 80005a8:	687b      	ldr	r3, [r7, #4]
}
 80005aa:	4618      	mov	r0, r3
 80005ac:	3710      	adds	r7, #16
 80005ae:	46bd      	mov	sp, r7
 80005b0:	bd80      	pop	{r7, pc}
 80005b2:	bf00      	nop
 80005b4:	40021000 	.word	0x40021000
 80005b8:	080011b8 	.word	0x080011b8

080005bc <MCAL_RCC_GetPCLK2_Freq>:

uint32 MCAL_RCC_GetPCLK2_Freq(){
 80005bc:	b580      	push	{r7, lr}
 80005be:	b084      	sub	sp, #16
 80005c0:	af00      	add	r7, sp, #0
	uint32 HCLK = MCAL_RCC_GetHCLK_Freq();
 80005c2:	f7ff ffbf 	bl	8000544 <MCAL_RCC_GetHCLK_Freq>
 80005c6:	60f8      	str	r0, [r7, #12]
		100: HCLK divided by 2
		101: HCLK divided by 4
		110: HCLK divided by 8
		111: HCLK divided by 16
	 */
	uint32 ABP2_Prescale = ((RCC->CFGR >> 11) & 0x3);
 80005c8:	4b09      	ldr	r3, [pc, #36]	; (80005f0 <MCAL_RCC_GetPCLK2_Freq+0x34>)
 80005ca:	685b      	ldr	r3, [r3, #4]
 80005cc:	0adb      	lsrs	r3, r3, #11
 80005ce:	f003 0303 	and.w	r3, r3, #3
 80005d2:	60bb      	str	r3, [r7, #8]
	uint32 PCLK2 = ((uint32)HCLK >> ABP_Prescaler_Table[ABP2_Prescale]);
 80005d4:	4a07      	ldr	r2, [pc, #28]	; (80005f4 <MCAL_RCC_GetPCLK2_Freq+0x38>)
 80005d6:	68bb      	ldr	r3, [r7, #8]
 80005d8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80005dc:	68fa      	ldr	r2, [r7, #12]
 80005de:	fa22 f303 	lsr.w	r3, r2, r3
 80005e2:	607b      	str	r3, [r7, #4]
	return PCLK2;
 80005e4:	687b      	ldr	r3, [r7, #4]
}
 80005e6:	4618      	mov	r0, r3
 80005e8:	3710      	adds	r7, #16
 80005ea:	46bd      	mov	sp, r7
 80005ec:	bd80      	pop	{r7, pc}
 80005ee:	bf00      	nop
 80005f0:	40021000 	.word	0x40021000
 80005f4:	080011b8 	.word	0x080011b8

080005f8 <MCAL_SPI_Set_GPIO_Pins>:

/* ================================================================ */
/* ======================== Static APIs =========================== */
/* ================================================================ */

static void MCAL_SPI_Set_GPIO_Pins(SPI_Config_t *SPI_config){
 80005f8:	b580      	push	{r7, lr}
 80005fa:	b084      	sub	sp, #16
 80005fc:	af00      	add	r7, sp, #0
 80005fe:	6078      	str	r0, [r7, #4]
	GPIO_PinConfig_t PinCfg;
	if(SPI_config->SPIx == SPI1){
 8000600:	687b      	ldr	r3, [r7, #4]
 8000602:	681b      	ldr	r3, [r3, #0]
 8000604:	4a8f      	ldr	r2, [pc, #572]	; (8000844 <MCAL_SPI_Set_GPIO_Pins+0x24c>)
 8000606:	4293      	cmp	r3, r2
 8000608:	f040 808b 	bne.w	8000722 <MCAL_SPI_Set_GPIO_Pins+0x12a>
		// SPI1_NSS : PA4
		// SPI1_SCK : PA5
		// SPI1_MISO : PA6
		// SPI1_MOSI : PA7
		if(SPI_config->mode == SPI_MODE_SLAVE){
 800060c:	687b      	ldr	r3, [r7, #4]
 800060e:	791b      	ldrb	r3, [r3, #4]
 8000610:	2b00      	cmp	r3, #0
 8000612:	d135      	bne.n	8000680 <MCAL_SPI_Set_GPIO_Pins+0x88>
			// Set MISO as Alternate function push-pull
			PinCfg.PinMode = GPIO_OUTPUT_10MHZ;
 8000614:	2301      	movs	r3, #1
 8000616:	737b      	strb	r3, [r7, #13]
			PinCfg.PinNum = GPIO_PIN6;
 8000618:	2306      	movs	r3, #6
 800061a:	733b      	strb	r3, [r7, #12]
			PinCfg.PinCNF = GPIO_CNF_AF_PUSH_PULL_OUTPUT;
 800061c:	2302      	movs	r3, #2
 800061e:	73fb      	strb	r3, [r7, #15]
			MCAL_GPIO_Init(GPIOA, &PinCfg);
 8000620:	f107 030c 	add.w	r3, r7, #12
 8000624:	4619      	mov	r1, r3
 8000626:	4888      	ldr	r0, [pc, #544]	; (8000848 <MCAL_SPI_Set_GPIO_Pins+0x250>)
 8000628:	f7ff ff06 	bl	8000438 <MCAL_GPIO_Init>
			// Set MOSI as input floating / Input pull-up
			PinCfg.PinMode = GPIO_INPUT;
 800062c:	2300      	movs	r3, #0
 800062e:	737b      	strb	r3, [r7, #13]
			PinCfg.PinNum = GPIO_PIN7;
 8000630:	2307      	movs	r3, #7
 8000632:	733b      	strb	r3, [r7, #12]
			PinCfg.PinCNF = GPIO_CNF_FLOATING_INPUT;
 8000634:	2301      	movs	r3, #1
 8000636:	73fb      	strb	r3, [r7, #15]
			MCAL_GPIO_Init(GPIOA, &PinCfg);
 8000638:	f107 030c 	add.w	r3, r7, #12
 800063c:	4619      	mov	r1, r3
 800063e:	4882      	ldr	r0, [pc, #520]	; (8000848 <MCAL_SPI_Set_GPIO_Pins+0x250>)
 8000640:	f7ff fefa 	bl	8000438 <MCAL_GPIO_Init>
			// Set SPI1_SCK as input floating
			PinCfg.PinMode = GPIO_INPUT;
 8000644:	2300      	movs	r3, #0
 8000646:	737b      	strb	r3, [r7, #13]
			PinCfg.PinNum = GPIO_PIN5;
 8000648:	2305      	movs	r3, #5
 800064a:	733b      	strb	r3, [r7, #12]
			PinCfg.PinCNF = GPIO_CNF_FLOATING_INPUT;
 800064c:	2301      	movs	r3, #1
 800064e:	73fb      	strb	r3, [r7, #15]
			MCAL_GPIO_Init(GPIOA, &PinCfg);
 8000650:	f107 030c 	add.w	r3, r7, #12
 8000654:	4619      	mov	r1, r3
 8000656:	487c      	ldr	r0, [pc, #496]	; (8000848 <MCAL_SPI_Set_GPIO_Pins+0x250>)
 8000658:	f7ff feee 	bl	8000438 <MCAL_GPIO_Init>
			if(SPI_config->ssm == SPI_SSM_DISABLED){  // Hardware NSS management
 800065c:	687b      	ldr	r3, [r7, #4]
 800065e:	7a9b      	ldrb	r3, [r3, #10]
 8000660:	2b00      	cmp	r3, #0
 8000662:	f040 80ea 	bne.w	800083a <MCAL_SPI_Set_GPIO_Pins+0x242>
				// Set SPIx_NSS as Input floating
				PinCfg.PinMode = GPIO_INPUT;
 8000666:	2300      	movs	r3, #0
 8000668:	737b      	strb	r3, [r7, #13]
				PinCfg.PinNum = GPIO_PIN4;
 800066a:	2304      	movs	r3, #4
 800066c:	733b      	strb	r3, [r7, #12]
				PinCfg.PinCNF = GPIO_CNF_FLOATING_INPUT;
 800066e:	2301      	movs	r3, #1
 8000670:	73fb      	strb	r3, [r7, #15]
				MCAL_GPIO_Init(GPIOA, &PinCfg);
 8000672:	f107 030c 	add.w	r3, r7, #12
 8000676:	4619      	mov	r1, r3
 8000678:	4873      	ldr	r0, [pc, #460]	; (8000848 <MCAL_SPI_Set_GPIO_Pins+0x250>)
 800067a:	f7ff fedd 	bl	8000438 <MCAL_GPIO_Init>
					MCAL_GPIO_Init(GPIOB, &PinCfg);
				}
			}
		}
	}
}
 800067e:	e0dc      	b.n	800083a <MCAL_SPI_Set_GPIO_Pins+0x242>
		else if(SPI_config->mode == SPI_MODE_MASTER){
 8000680:	687b      	ldr	r3, [r7, #4]
 8000682:	791b      	ldrb	r3, [r3, #4]
 8000684:	2b01      	cmp	r3, #1
 8000686:	f040 80d8 	bne.w	800083a <MCAL_SPI_Set_GPIO_Pins+0x242>
			PinCfg.PinMode = GPIO_INPUT;
 800068a:	2300      	movs	r3, #0
 800068c:	737b      	strb	r3, [r7, #13]
			PinCfg.PinNum = GPIO_PIN6;
 800068e:	2306      	movs	r3, #6
 8000690:	733b      	strb	r3, [r7, #12]
			PinCfg.PinCNF = GPIO_CNF_FLOATING_INPUT;
 8000692:	2301      	movs	r3, #1
 8000694:	73fb      	strb	r3, [r7, #15]
			MCAL_GPIO_Init(GPIOA, &PinCfg);
 8000696:	f107 030c 	add.w	r3, r7, #12
 800069a:	4619      	mov	r1, r3
 800069c:	486a      	ldr	r0, [pc, #424]	; (8000848 <MCAL_SPI_Set_GPIO_Pins+0x250>)
 800069e:	f7ff fecb 	bl	8000438 <MCAL_GPIO_Init>
			PinCfg.PinMode = GPIO_OUTPUT_10MHZ;
 80006a2:	2301      	movs	r3, #1
 80006a4:	737b      	strb	r3, [r7, #13]
			PinCfg.PinNum = GPIO_PIN7;
 80006a6:	2307      	movs	r3, #7
 80006a8:	733b      	strb	r3, [r7, #12]
			PinCfg.PinCNF = GPIO_CNF_AF_PUSH_PULL_OUTPUT;
 80006aa:	2302      	movs	r3, #2
 80006ac:	73fb      	strb	r3, [r7, #15]
			MCAL_GPIO_Init(GPIOA, &PinCfg);
 80006ae:	f107 030c 	add.w	r3, r7, #12
 80006b2:	4619      	mov	r1, r3
 80006b4:	4864      	ldr	r0, [pc, #400]	; (8000848 <MCAL_SPI_Set_GPIO_Pins+0x250>)
 80006b6:	f7ff febf 	bl	8000438 <MCAL_GPIO_Init>
			PinCfg.PinMode = GPIO_OUTPUT_10MHZ;
 80006ba:	2301      	movs	r3, #1
 80006bc:	737b      	strb	r3, [r7, #13]
			PinCfg.PinNum = GPIO_PIN5;
 80006be:	2305      	movs	r3, #5
 80006c0:	733b      	strb	r3, [r7, #12]
			PinCfg.PinCNF = GPIO_CNF_AF_PUSH_PULL_OUTPUT;
 80006c2:	2302      	movs	r3, #2
 80006c4:	73fb      	strb	r3, [r7, #15]
			MCAL_GPIO_Init(GPIOA, &PinCfg);
 80006c6:	f107 030c 	add.w	r3, r7, #12
 80006ca:	4619      	mov	r1, r3
 80006cc:	485e      	ldr	r0, [pc, #376]	; (8000848 <MCAL_SPI_Set_GPIO_Pins+0x250>)
 80006ce:	f7ff feb3 	bl	8000438 <MCAL_GPIO_Init>
			if(SPI_config->ssm == SPI_SSM_DISABLED){  // Hardware NSS management
 80006d2:	687b      	ldr	r3, [r7, #4]
 80006d4:	7a9b      	ldrb	r3, [r3, #10]
 80006d6:	2b00      	cmp	r3, #0
 80006d8:	f040 80af 	bne.w	800083a <MCAL_SPI_Set_GPIO_Pins+0x242>
				if(SPI_config->ssoe == SPI_SSOE_DISABLED){
 80006dc:	687b      	ldr	r3, [r7, #4]
 80006de:	7d1b      	ldrb	r3, [r3, #20]
 80006e0:	2b00      	cmp	r3, #0
 80006e2:	d10c      	bne.n	80006fe <MCAL_SPI_Set_GPIO_Pins+0x106>
					PinCfg.PinMode = GPIO_INPUT;
 80006e4:	2300      	movs	r3, #0
 80006e6:	737b      	strb	r3, [r7, #13]
					PinCfg.PinNum = GPIO_PIN4;
 80006e8:	2304      	movs	r3, #4
 80006ea:	733b      	strb	r3, [r7, #12]
					PinCfg.PinCNF = GPIO_CNF_FLOATING_INPUT;
 80006ec:	2301      	movs	r3, #1
 80006ee:	73fb      	strb	r3, [r7, #15]
					MCAL_GPIO_Init(GPIOA, &PinCfg);
 80006f0:	f107 030c 	add.w	r3, r7, #12
 80006f4:	4619      	mov	r1, r3
 80006f6:	4854      	ldr	r0, [pc, #336]	; (8000848 <MCAL_SPI_Set_GPIO_Pins+0x250>)
 80006f8:	f7ff fe9e 	bl	8000438 <MCAL_GPIO_Init>
}
 80006fc:	e09d      	b.n	800083a <MCAL_SPI_Set_GPIO_Pins+0x242>
				else if(SPI_config->ssoe == SPI_SSOE_ENABLED){
 80006fe:	687b      	ldr	r3, [r7, #4]
 8000700:	7d1b      	ldrb	r3, [r3, #20]
 8000702:	2b01      	cmp	r3, #1
 8000704:	f040 8099 	bne.w	800083a <MCAL_SPI_Set_GPIO_Pins+0x242>
					PinCfg.PinMode = GPIO_OUTPUT_10MHZ;
 8000708:	2301      	movs	r3, #1
 800070a:	737b      	strb	r3, [r7, #13]
					PinCfg.PinNum = GPIO_PIN4;
 800070c:	2304      	movs	r3, #4
 800070e:	733b      	strb	r3, [r7, #12]
					PinCfg.PinCNF = GPIO_CNF_AF_PUSH_PULL_OUTPUT;
 8000710:	2302      	movs	r3, #2
 8000712:	73fb      	strb	r3, [r7, #15]
					MCAL_GPIO_Init(GPIOA, &PinCfg);
 8000714:	f107 030c 	add.w	r3, r7, #12
 8000718:	4619      	mov	r1, r3
 800071a:	484b      	ldr	r0, [pc, #300]	; (8000848 <MCAL_SPI_Set_GPIO_Pins+0x250>)
 800071c:	f7ff fe8c 	bl	8000438 <MCAL_GPIO_Init>
}
 8000720:	e08b      	b.n	800083a <MCAL_SPI_Set_GPIO_Pins+0x242>
	else if(SPI_config->SPIx == SPI2){
 8000722:	687b      	ldr	r3, [r7, #4]
 8000724:	681b      	ldr	r3, [r3, #0]
 8000726:	4a49      	ldr	r2, [pc, #292]	; (800084c <MCAL_SPI_Set_GPIO_Pins+0x254>)
 8000728:	4293      	cmp	r3, r2
 800072a:	f040 8086 	bne.w	800083a <MCAL_SPI_Set_GPIO_Pins+0x242>
		if(SPI_config->mode == SPI_MODE_SLAVE){
 800072e:	687b      	ldr	r3, [r7, #4]
 8000730:	791b      	ldrb	r3, [r3, #4]
 8000732:	2b00      	cmp	r3, #0
 8000734:	d134      	bne.n	80007a0 <MCAL_SPI_Set_GPIO_Pins+0x1a8>
			PinCfg.PinMode = GPIO_OUTPUT_10MHZ;
 8000736:	2301      	movs	r3, #1
 8000738:	737b      	strb	r3, [r7, #13]
			PinCfg.PinNum = GPIO_PIN14;
 800073a:	230e      	movs	r3, #14
 800073c:	733b      	strb	r3, [r7, #12]
			PinCfg.PinCNF = GPIO_CNF_AF_PUSH_PULL_OUTPUT;
 800073e:	2302      	movs	r3, #2
 8000740:	73fb      	strb	r3, [r7, #15]
			MCAL_GPIO_Init(GPIOB, &PinCfg);
 8000742:	f107 030c 	add.w	r3, r7, #12
 8000746:	4619      	mov	r1, r3
 8000748:	4841      	ldr	r0, [pc, #260]	; (8000850 <MCAL_SPI_Set_GPIO_Pins+0x258>)
 800074a:	f7ff fe75 	bl	8000438 <MCAL_GPIO_Init>
			PinCfg.PinMode = GPIO_INPUT;
 800074e:	2300      	movs	r3, #0
 8000750:	737b      	strb	r3, [r7, #13]
			PinCfg.PinNum = GPIO_PIN15;
 8000752:	230f      	movs	r3, #15
 8000754:	733b      	strb	r3, [r7, #12]
			PinCfg.PinCNF = GPIO_CNF_FLOATING_INPUT;
 8000756:	2301      	movs	r3, #1
 8000758:	73fb      	strb	r3, [r7, #15]
			MCAL_GPIO_Init(GPIOB, &PinCfg);
 800075a:	f107 030c 	add.w	r3, r7, #12
 800075e:	4619      	mov	r1, r3
 8000760:	483b      	ldr	r0, [pc, #236]	; (8000850 <MCAL_SPI_Set_GPIO_Pins+0x258>)
 8000762:	f7ff fe69 	bl	8000438 <MCAL_GPIO_Init>
			PinCfg.PinMode = GPIO_INPUT;
 8000766:	2300      	movs	r3, #0
 8000768:	737b      	strb	r3, [r7, #13]
			PinCfg.PinNum = GPIO_PIN13;
 800076a:	230d      	movs	r3, #13
 800076c:	733b      	strb	r3, [r7, #12]
			PinCfg.PinCNF = GPIO_CNF_FLOATING_INPUT;
 800076e:	2301      	movs	r3, #1
 8000770:	73fb      	strb	r3, [r7, #15]
			MCAL_GPIO_Init(GPIOB, &PinCfg);
 8000772:	f107 030c 	add.w	r3, r7, #12
 8000776:	4619      	mov	r1, r3
 8000778:	4835      	ldr	r0, [pc, #212]	; (8000850 <MCAL_SPI_Set_GPIO_Pins+0x258>)
 800077a:	f7ff fe5d 	bl	8000438 <MCAL_GPIO_Init>
			if(SPI_config->ssm == SPI_SSM_DISABLED){  // Hardware NSS management
 800077e:	687b      	ldr	r3, [r7, #4]
 8000780:	7a9b      	ldrb	r3, [r3, #10]
 8000782:	2b00      	cmp	r3, #0
 8000784:	d159      	bne.n	800083a <MCAL_SPI_Set_GPIO_Pins+0x242>
				PinCfg.PinMode = GPIO_INPUT;
 8000786:	2300      	movs	r3, #0
 8000788:	737b      	strb	r3, [r7, #13]
				PinCfg.PinNum = GPIO_PIN12;
 800078a:	230c      	movs	r3, #12
 800078c:	733b      	strb	r3, [r7, #12]
				PinCfg.PinCNF = GPIO_CNF_FLOATING_INPUT;
 800078e:	2301      	movs	r3, #1
 8000790:	73fb      	strb	r3, [r7, #15]
				MCAL_GPIO_Init(GPIOB, &PinCfg);
 8000792:	f107 030c 	add.w	r3, r7, #12
 8000796:	4619      	mov	r1, r3
 8000798:	482d      	ldr	r0, [pc, #180]	; (8000850 <MCAL_SPI_Set_GPIO_Pins+0x258>)
 800079a:	f7ff fe4d 	bl	8000438 <MCAL_GPIO_Init>
}
 800079e:	e04c      	b.n	800083a <MCAL_SPI_Set_GPIO_Pins+0x242>
		else if(SPI_config->mode == SPI_MODE_MASTER){
 80007a0:	687b      	ldr	r3, [r7, #4]
 80007a2:	791b      	ldrb	r3, [r3, #4]
 80007a4:	2b01      	cmp	r3, #1
 80007a6:	d148      	bne.n	800083a <MCAL_SPI_Set_GPIO_Pins+0x242>
			PinCfg.PinMode = GPIO_INPUT;
 80007a8:	2300      	movs	r3, #0
 80007aa:	737b      	strb	r3, [r7, #13]
			PinCfg.PinNum = GPIO_PIN14;
 80007ac:	230e      	movs	r3, #14
 80007ae:	733b      	strb	r3, [r7, #12]
			PinCfg.PinCNF = GPIO_CNF_FLOATING_INPUT;
 80007b0:	2301      	movs	r3, #1
 80007b2:	73fb      	strb	r3, [r7, #15]
			MCAL_GPIO_Init(GPIOB, &PinCfg);
 80007b4:	f107 030c 	add.w	r3, r7, #12
 80007b8:	4619      	mov	r1, r3
 80007ba:	4825      	ldr	r0, [pc, #148]	; (8000850 <MCAL_SPI_Set_GPIO_Pins+0x258>)
 80007bc:	f7ff fe3c 	bl	8000438 <MCAL_GPIO_Init>
			PinCfg.PinMode = GPIO_OUTPUT_10MHZ;
 80007c0:	2301      	movs	r3, #1
 80007c2:	737b      	strb	r3, [r7, #13]
			PinCfg.PinNum = GPIO_PIN15;
 80007c4:	230f      	movs	r3, #15
 80007c6:	733b      	strb	r3, [r7, #12]
			PinCfg.PinCNF = GPIO_CNF_AF_PUSH_PULL_OUTPUT;
 80007c8:	2302      	movs	r3, #2
 80007ca:	73fb      	strb	r3, [r7, #15]
			MCAL_GPIO_Init(GPIOB, &PinCfg);
 80007cc:	f107 030c 	add.w	r3, r7, #12
 80007d0:	4619      	mov	r1, r3
 80007d2:	481f      	ldr	r0, [pc, #124]	; (8000850 <MCAL_SPI_Set_GPIO_Pins+0x258>)
 80007d4:	f7ff fe30 	bl	8000438 <MCAL_GPIO_Init>
			PinCfg.PinMode = GPIO_OUTPUT_10MHZ;
 80007d8:	2301      	movs	r3, #1
 80007da:	737b      	strb	r3, [r7, #13]
			PinCfg.PinNum = GPIO_PIN13;
 80007dc:	230d      	movs	r3, #13
 80007de:	733b      	strb	r3, [r7, #12]
			PinCfg.PinCNF = GPIO_CNF_AF_PUSH_PULL_OUTPUT;
 80007e0:	2302      	movs	r3, #2
 80007e2:	73fb      	strb	r3, [r7, #15]
			MCAL_GPIO_Init(GPIOB, &PinCfg);
 80007e4:	f107 030c 	add.w	r3, r7, #12
 80007e8:	4619      	mov	r1, r3
 80007ea:	4819      	ldr	r0, [pc, #100]	; (8000850 <MCAL_SPI_Set_GPIO_Pins+0x258>)
 80007ec:	f7ff fe24 	bl	8000438 <MCAL_GPIO_Init>
			if(SPI_config->ssm == SPI_SSM_DISABLED){  // Hardware NSS management
 80007f0:	687b      	ldr	r3, [r7, #4]
 80007f2:	7a9b      	ldrb	r3, [r3, #10]
 80007f4:	2b00      	cmp	r3, #0
 80007f6:	d120      	bne.n	800083a <MCAL_SPI_Set_GPIO_Pins+0x242>
				if(SPI_config->ssoe == SPI_SSOE_DISABLED){
 80007f8:	687b      	ldr	r3, [r7, #4]
 80007fa:	7d1b      	ldrb	r3, [r3, #20]
 80007fc:	2b00      	cmp	r3, #0
 80007fe:	d10c      	bne.n	800081a <MCAL_SPI_Set_GPIO_Pins+0x222>
					PinCfg.PinMode = GPIO_INPUT;
 8000800:	2300      	movs	r3, #0
 8000802:	737b      	strb	r3, [r7, #13]
					PinCfg.PinNum = GPIO_PIN12;
 8000804:	230c      	movs	r3, #12
 8000806:	733b      	strb	r3, [r7, #12]
					PinCfg.PinCNF = GPIO_CNF_FLOATING_INPUT;
 8000808:	2301      	movs	r3, #1
 800080a:	73fb      	strb	r3, [r7, #15]
					MCAL_GPIO_Init(GPIOB, &PinCfg);
 800080c:	f107 030c 	add.w	r3, r7, #12
 8000810:	4619      	mov	r1, r3
 8000812:	480f      	ldr	r0, [pc, #60]	; (8000850 <MCAL_SPI_Set_GPIO_Pins+0x258>)
 8000814:	f7ff fe10 	bl	8000438 <MCAL_GPIO_Init>
}
 8000818:	e00f      	b.n	800083a <MCAL_SPI_Set_GPIO_Pins+0x242>
				else if(SPI_config->ssoe == SPI_SSOE_ENABLED){
 800081a:	687b      	ldr	r3, [r7, #4]
 800081c:	7d1b      	ldrb	r3, [r3, #20]
 800081e:	2b01      	cmp	r3, #1
 8000820:	d10b      	bne.n	800083a <MCAL_SPI_Set_GPIO_Pins+0x242>
					PinCfg.PinMode = GPIO_OUTPUT_10MHZ;
 8000822:	2301      	movs	r3, #1
 8000824:	737b      	strb	r3, [r7, #13]
					PinCfg.PinNum = GPIO_PIN12;
 8000826:	230c      	movs	r3, #12
 8000828:	733b      	strb	r3, [r7, #12]
					PinCfg.PinCNF = GPIO_CNF_AF_PUSH_PULL_OUTPUT;
 800082a:	2302      	movs	r3, #2
 800082c:	73fb      	strb	r3, [r7, #15]
					MCAL_GPIO_Init(GPIOB, &PinCfg);
 800082e:	f107 030c 	add.w	r3, r7, #12
 8000832:	4619      	mov	r1, r3
 8000834:	4806      	ldr	r0, [pc, #24]	; (8000850 <MCAL_SPI_Set_GPIO_Pins+0x258>)
 8000836:	f7ff fdff 	bl	8000438 <MCAL_GPIO_Init>
}
 800083a:	bf00      	nop
 800083c:	3710      	adds	r7, #16
 800083e:	46bd      	mov	sp, r7
 8000840:	bd80      	pop	{r7, pc}
 8000842:	bf00      	nop
 8000844:	40013000 	.word	0x40013000
 8000848:	40010800 	.word	0x40010800
 800084c:	40003800 	.word	0x40003800
 8000850:	40010c00 	.word	0x40010c00

08000854 <MCAL_SPI_SetCallBackFunction>:

static void MCAL_SPI_SetCallBackFunction(SPI_Config_t *SPI_config){
 8000854:	b480      	push	{r7}
 8000856:	b083      	sub	sp, #12
 8000858:	af00      	add	r7, sp, #0
 800085a:	6078      	str	r0, [r7, #4]
	// Set the callback function for both SPI1/SPI2
	if(SPI_config->SPIx == SPI1){
 800085c:	687b      	ldr	r3, [r7, #4]
 800085e:	681b      	ldr	r3, [r3, #0]
 8000860:	4a0a      	ldr	r2, [pc, #40]	; (800088c <MCAL_SPI_SetCallBackFunction+0x38>)
 8000862:	4293      	cmp	r3, r2
 8000864:	d104      	bne.n	8000870 <MCAL_SPI_SetCallBackFunction+0x1c>
		SPI_CallBackFunction[0] = SPI_config->SPI_CallBackFun;
 8000866:	687b      	ldr	r3, [r7, #4]
 8000868:	699b      	ldr	r3, [r3, #24]
 800086a:	4a09      	ldr	r2, [pc, #36]	; (8000890 <MCAL_SPI_SetCallBackFunction+0x3c>)
 800086c:	6013      	str	r3, [r2, #0]
	}
	else if(SPI_config->SPIx == SPI2){
		SPI_CallBackFunction[1] = SPI_config->SPI_CallBackFun;
	}
}
 800086e:	e008      	b.n	8000882 <MCAL_SPI_SetCallBackFunction+0x2e>
	else if(SPI_config->SPIx == SPI2){
 8000870:	687b      	ldr	r3, [r7, #4]
 8000872:	681b      	ldr	r3, [r3, #0]
 8000874:	4a07      	ldr	r2, [pc, #28]	; (8000894 <MCAL_SPI_SetCallBackFunction+0x40>)
 8000876:	4293      	cmp	r3, r2
 8000878:	d103      	bne.n	8000882 <MCAL_SPI_SetCallBackFunction+0x2e>
		SPI_CallBackFunction[1] = SPI_config->SPI_CallBackFun;
 800087a:	687b      	ldr	r3, [r7, #4]
 800087c:	699b      	ldr	r3, [r3, #24]
 800087e:	4a04      	ldr	r2, [pc, #16]	; (8000890 <MCAL_SPI_SetCallBackFunction+0x3c>)
 8000880:	6053      	str	r3, [r2, #4]
}
 8000882:	bf00      	nop
 8000884:	370c      	adds	r7, #12
 8000886:	46bd      	mov	sp, r7
 8000888:	bc80      	pop	{r7}
 800088a:	4770      	bx	lr
 800088c:	40013000 	.word	0x40013000
 8000890:	20000090 	.word	0x20000090
 8000894:	40003800 	.word	0x40003800

08000898 <MCAL_SPI_Enable_Global_Interrupt>:

static void MCAL_SPI_Enable_Global_Interrupt(SPI_Config_t *SPI_config){
 8000898:	b480      	push	{r7}
 800089a:	b083      	sub	sp, #12
 800089c:	af00      	add	r7, sp, #0
 800089e:	6078      	str	r0, [r7, #4]
	// Enable the clock for SPI1/SPI2
	if(SPI_config->SPIx == SPI1){
 80008a0:	687b      	ldr	r3, [r7, #4]
 80008a2:	681b      	ldr	r3, [r3, #0]
 80008a4:	4a0c      	ldr	r2, [pc, #48]	; (80008d8 <MCAL_SPI_Enable_Global_Interrupt+0x40>)
 80008a6:	4293      	cmp	r3, r2
 80008a8:	d106      	bne.n	80008b8 <MCAL_SPI_Enable_Global_Interrupt+0x20>
		NVIC_IRQ_ENABLE(SPI1_IRQ);
 80008aa:	4b0c      	ldr	r3, [pc, #48]	; (80008dc <MCAL_SPI_Enable_Global_Interrupt+0x44>)
 80008ac:	681b      	ldr	r3, [r3, #0]
 80008ae:	4a0b      	ldr	r2, [pc, #44]	; (80008dc <MCAL_SPI_Enable_Global_Interrupt+0x44>)
 80008b0:	f043 0308 	orr.w	r3, r3, #8
 80008b4:	6013      	str	r3, [r2, #0]
	}
	else if(SPI_config->SPIx == SPI2){
		NVIC_IRQ_ENABLE(SPI2_IRQ);
	}
}
 80008b6:	e00a      	b.n	80008ce <MCAL_SPI_Enable_Global_Interrupt+0x36>
	else if(SPI_config->SPIx == SPI2){
 80008b8:	687b      	ldr	r3, [r7, #4]
 80008ba:	681b      	ldr	r3, [r3, #0]
 80008bc:	4a08      	ldr	r2, [pc, #32]	; (80008e0 <MCAL_SPI_Enable_Global_Interrupt+0x48>)
 80008be:	4293      	cmp	r3, r2
 80008c0:	d105      	bne.n	80008ce <MCAL_SPI_Enable_Global_Interrupt+0x36>
		NVIC_IRQ_ENABLE(SPI2_IRQ);
 80008c2:	4b06      	ldr	r3, [pc, #24]	; (80008dc <MCAL_SPI_Enable_Global_Interrupt+0x44>)
 80008c4:	681b      	ldr	r3, [r3, #0]
 80008c6:	4a05      	ldr	r2, [pc, #20]	; (80008dc <MCAL_SPI_Enable_Global_Interrupt+0x44>)
 80008c8:	f043 0310 	orr.w	r3, r3, #16
 80008cc:	6013      	str	r3, [r2, #0]
}
 80008ce:	bf00      	nop
 80008d0:	370c      	adds	r7, #12
 80008d2:	46bd      	mov	sp, r7
 80008d4:	bc80      	pop	{r7}
 80008d6:	4770      	bx	lr
 80008d8:	40013000 	.word	0x40013000
 80008dc:	e000e104 	.word	0xe000e104
 80008e0:	40003800 	.word	0x40003800

080008e4 <MCAL_SPI_Init>:

/* ================================================================ */
/* ======================== Public APIs =========================== */
/* ================================================================ */

void MCAL_SPI_Init(SPI_Config_t *SPI_config){
 80008e4:	b580      	push	{r7, lr}
 80008e6:	b082      	sub	sp, #8
 80008e8:	af00      	add	r7, sp, #0
 80008ea:	6078      	str	r0, [r7, #4]
	// Enable the clock for SPI1/SPI2
	if(SPI_config->SPIx == SPI1){
 80008ec:	687b      	ldr	r3, [r7, #4]
 80008ee:	681b      	ldr	r3, [r3, #0]
 80008f0:	4a77      	ldr	r2, [pc, #476]	; (8000ad0 <MCAL_SPI_Init+0x1ec>)
 80008f2:	4293      	cmp	r3, r2
 80008f4:	d106      	bne.n	8000904 <MCAL_SPI_Init+0x20>
		SPI1_CLK_EN();
 80008f6:	4b77      	ldr	r3, [pc, #476]	; (8000ad4 <MCAL_SPI_Init+0x1f0>)
 80008f8:	699b      	ldr	r3, [r3, #24]
 80008fa:	4a76      	ldr	r2, [pc, #472]	; (8000ad4 <MCAL_SPI_Init+0x1f0>)
 80008fc:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8000900:	6193      	str	r3, [r2, #24]
 8000902:	e00a      	b.n	800091a <MCAL_SPI_Init+0x36>

	}
	else if(SPI_config->SPIx == SPI2){
 8000904:	687b      	ldr	r3, [r7, #4]
 8000906:	681b      	ldr	r3, [r3, #0]
 8000908:	4a73      	ldr	r2, [pc, #460]	; (8000ad8 <MCAL_SPI_Init+0x1f4>)
 800090a:	4293      	cmp	r3, r2
 800090c:	d105      	bne.n	800091a <MCAL_SPI_Init+0x36>
		SPI1_CLK_EN();
 800090e:	4b71      	ldr	r3, [pc, #452]	; (8000ad4 <MCAL_SPI_Init+0x1f0>)
 8000910:	699b      	ldr	r3, [r3, #24]
 8000912:	4a70      	ldr	r2, [pc, #448]	; (8000ad4 <MCAL_SPI_Init+0x1f0>)
 8000914:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8000918:	6193      	str	r3, [r2, #24]
	/*
		Bit 2 MSTR: Master selection
			0: Slave configuration
			1: Master configuration
	 */
	SPI_config->SPIx->CR1 |= (SPI_config->mode << 2);
 800091a:	687b      	ldr	r3, [r7, #4]
 800091c:	681b      	ldr	r3, [r3, #0]
 800091e:	681a      	ldr	r2, [r3, #0]
 8000920:	687b      	ldr	r3, [r7, #4]
 8000922:	791b      	ldrb	r3, [r3, #4]
 8000924:	009b      	lsls	r3, r3, #2
 8000926:	4619      	mov	r1, r3
 8000928:	687b      	ldr	r3, [r7, #4]
 800092a:	681b      	ldr	r3, [r3, #0]
 800092c:	430a      	orrs	r2, r1
 800092e:	601a      	str	r2, [r3, #0]
	/*
	    Bit 15 BIDIMODE: Bidirectional data mode enable
			0: 2-line unidirectional data mode selected
			1: 1-line bidirectional data mode selected
	 */
	SPI_config->SPIx->CR1 |= (SPI_config->bidirectionalMode << 15);
 8000930:	687b      	ldr	r3, [r7, #4]
 8000932:	681b      	ldr	r3, [r3, #0]
 8000934:	681a      	ldr	r2, [r3, #0]
 8000936:	687b      	ldr	r3, [r7, #4]
 8000938:	79db      	ldrb	r3, [r3, #7]
 800093a:	03db      	lsls	r3, r3, #15
 800093c:	4619      	mov	r1, r3
 800093e:	687b      	ldr	r3, [r7, #4]
 8000940:	681b      	ldr	r3, [r3, #0]
 8000942:	430a      	orrs	r2, r1
 8000944:	601a      	str	r2, [r3, #0]
		Bit 14 BIDIOE: Output enable in bidirectional mode
			This bit combined with the BIDImode bit selects the direction of transfer in bidirectional mode
			0: Output disabled (receive-only mode)
			1: Output enabled (transmit-only mode)
	 */
	if(SPI_config->bidirectionalMode == SPI_BDM_1LINE_BIDIR)
 8000946:	687b      	ldr	r3, [r7, #4]
 8000948:	79db      	ldrb	r3, [r3, #7]
 800094a:	2b01      	cmp	r3, #1
 800094c:	d10a      	bne.n	8000964 <MCAL_SPI_Init+0x80>
		SPI_config->SPIx->CR1 |= (SPI_config->bidiOutputEnable << 14);
 800094e:	687b      	ldr	r3, [r7, #4]
 8000950:	681b      	ldr	r3, [r3, #0]
 8000952:	681a      	ldr	r2, [r3, #0]
 8000954:	687b      	ldr	r3, [r7, #4]
 8000956:	7a1b      	ldrb	r3, [r3, #8]
 8000958:	039b      	lsls	r3, r3, #14
 800095a:	4619      	mov	r1, r3
 800095c:	687b      	ldr	r3, [r7, #4]
 800095e:	681b      	ldr	r3, [r3, #0]
 8000960:	430a      	orrs	r2, r1
 8000962:	601a      	str	r2, [r3, #0]
	/*
		Bit 13 CRCEN: Hardware CRC calculation enable
			0: CRC calculation disabled
			1: CRC calculation enabled
	 */
	SPI_config->SPIx->CR1 |= (SPI_config->crcEnable << 13);
 8000964:	687b      	ldr	r3, [r7, #4]
 8000966:	681b      	ldr	r3, [r3, #0]
 8000968:	681a      	ldr	r2, [r3, #0]
 800096a:	687b      	ldr	r3, [r7, #4]
 800096c:	7b9b      	ldrb	r3, [r3, #14]
 800096e:	035b      	lsls	r3, r3, #13
 8000970:	4619      	mov	r1, r3
 8000972:	687b      	ldr	r3, [r7, #4]
 8000974:	681b      	ldr	r3, [r3, #0]
 8000976:	430a      	orrs	r2, r1
 8000978:	601a      	str	r2, [r3, #0]
	/*
		Bit 13 CRCEN: Hardware CRC calculation enable
			0: CRC calculation disabled
			1: CRC calculation enabled
	 */
	SPI_config->SPIx->CR1 |= (SPI_config->crcEnable << 13);
 800097a:	687b      	ldr	r3, [r7, #4]
 800097c:	681b      	ldr	r3, [r3, #0]
 800097e:	681a      	ldr	r2, [r3, #0]
 8000980:	687b      	ldr	r3, [r7, #4]
 8000982:	7b9b      	ldrb	r3, [r3, #14]
 8000984:	035b      	lsls	r3, r3, #13
 8000986:	4619      	mov	r1, r3
 8000988:	687b      	ldr	r3, [r7, #4]
 800098a:	681b      	ldr	r3, [r3, #0]
 800098c:	430a      	orrs	r2, r1
 800098e:	601a      	str	r2, [r3, #0]
	/*
		Bit 11 DFF: Data frame format
			0: 8-bit data frame format is selected for transmission/reception
			1: 16-bit data frame format is selected for transmission/reception
	 */
	SPI_config->SPIx->CR1 |= (SPI_config->dataSize << 11);
 8000990:	687b      	ldr	r3, [r7, #4]
 8000992:	681b      	ldr	r3, [r3, #0]
 8000994:	681a      	ldr	r2, [r3, #0]
 8000996:	687b      	ldr	r3, [r7, #4]
 8000998:	795b      	ldrb	r3, [r3, #5]
 800099a:	02db      	lsls	r3, r3, #11
 800099c:	4619      	mov	r1, r3
 800099e:	687b      	ldr	r3, [r7, #4]
 80009a0:	681b      	ldr	r3, [r3, #0]
 80009a2:	430a      	orrs	r2, r1
 80009a4:	601a      	str	r2, [r3, #0]
			unidirectional mode. This bit is also useful in a multislave system in which this particular
			slave is not accessed, the output from the accessed slave is not corrupted.
			0: Full duplex (Transmit and receive)
			1: Output disabled (Receive-only mode)
	 */
	if(SPI_config->bidirectionalMode == SPI_BDM_2LINE_UNIDIR)  // Full duplex (2-line unidirectional)
 80009a6:	687b      	ldr	r3, [r7, #4]
 80009a8:	79db      	ldrb	r3, [r3, #7]
 80009aa:	2b00      	cmp	r3, #0
 80009ac:	d10a      	bne.n	80009c4 <MCAL_SPI_Init+0xe0>
		SPI_config->SPIx->CR1 |= (SPI_config->rxOnlyMode << 11);           // Receive-only mode for unidirectional
 80009ae:	687b      	ldr	r3, [r7, #4]
 80009b0:	681b      	ldr	r3, [r3, #0]
 80009b2:	681a      	ldr	r2, [r3, #0]
 80009b4:	687b      	ldr	r3, [r7, #4]
 80009b6:	7a5b      	ldrb	r3, [r3, #9]
 80009b8:	02db      	lsls	r3, r3, #11
 80009ba:	4619      	mov	r1, r3
 80009bc:	687b      	ldr	r3, [r7, #4]
 80009be:	681b      	ldr	r3, [r3, #0]
 80009c0:	430a      	orrs	r2, r1
 80009c2:	601a      	str	r2, [r3, #0]
		Bit 9 SSM: Software slave management
			When the SSM bit is set, the NSS pin input is replaced with the value from the SSI bit.
			0: Software slave management disabled
			1: Software slave management enabled
	 */
	SPI_config->SPIx->CR1 |= (SPI_config->ssm << 9);          				// Hardware or software NSS management
 80009c4:	687b      	ldr	r3, [r7, #4]
 80009c6:	681b      	ldr	r3, [r3, #0]
 80009c8:	681a      	ldr	r2, [r3, #0]
 80009ca:	687b      	ldr	r3, [r7, #4]
 80009cc:	7a9b      	ldrb	r3, [r3, #10]
 80009ce:	025b      	lsls	r3, r3, #9
 80009d0:	4619      	mov	r1, r3
 80009d2:	687b      	ldr	r3, [r7, #4]
 80009d4:	681b      	ldr	r3, [r3, #0]
 80009d6:	430a      	orrs	r2, r1
 80009d8:	601a      	str	r2, [r3, #0]
	/*
		Bit 8 SSI: Internal slave select
			This bit has an effect only when the SSM bit is set. The value of this bit is forced onto the
			NSS pin and the IO value of the NSS pin is ignored.
	 */
	if(SPI_config->ssm == SPI_SSM_ENABLED){
 80009da:	687b      	ldr	r3, [r7, #4]
 80009dc:	7a9b      	ldrb	r3, [r3, #10]
 80009de:	2b01      	cmp	r3, #1
 80009e0:	d118      	bne.n	8000a14 <MCAL_SPI_Init+0x130>
		// Software NSS management
		if(SPI_config->mode == SPI_MODE_MASTER){
 80009e2:	687b      	ldr	r3, [r7, #4]
 80009e4:	791b      	ldrb	r3, [r3, #4]
 80009e6:	2b01      	cmp	r3, #1
 80009e8:	d108      	bne.n	80009fc <MCAL_SPI_Init+0x118>
			// Master mode => Set SSI pin HIGH
			SET_BIT(SPI_config->SPIx->CR1, 8);
 80009ea:	687b      	ldr	r3, [r7, #4]
 80009ec:	681b      	ldr	r3, [r3, #0]
 80009ee:	681a      	ldr	r2, [r3, #0]
 80009f0:	687b      	ldr	r3, [r7, #4]
 80009f2:	681b      	ldr	r3, [r3, #0]
 80009f4:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 80009f8:	601a      	str	r2, [r3, #0]
 80009fa:	e00b      	b.n	8000a14 <MCAL_SPI_Init+0x130>
		}
		else if(SPI_config->mode == SPI_MODE_SLAVE){
 80009fc:	687b      	ldr	r3, [r7, #4]
 80009fe:	791b      	ldrb	r3, [r3, #4]
 8000a00:	2b00      	cmp	r3, #0
 8000a02:	d107      	bne.n	8000a14 <MCAL_SPI_Init+0x130>
			// Slve mode => Set SSI pin LOW
			CLEAR_BIT(SPI_config->SPIx->CR1, 8);
 8000a04:	687b      	ldr	r3, [r7, #4]
 8000a06:	681b      	ldr	r3, [r3, #0]
 8000a08:	681a      	ldr	r2, [r3, #0]
 8000a0a:	687b      	ldr	r3, [r7, #4]
 8000a0c:	681b      	ldr	r3, [r3, #0]
 8000a0e:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 8000a12:	601a      	str	r2, [r3, #0]
	/*
		Bit 7 LSBFIRST: Frame format
			0: MSB transmitted first
			1: LSB transmitted first
	 */
	SPI_config->SPIx->CR1 |= (SPI_config->frameFormat << 7);
 8000a14:	687b      	ldr	r3, [r7, #4]
 8000a16:	681b      	ldr	r3, [r3, #0]
 8000a18:	681a      	ldr	r2, [r3, #0]
 8000a1a:	687b      	ldr	r3, [r7, #4]
 8000a1c:	799b      	ldrb	r3, [r3, #6]
 8000a1e:	01db      	lsls	r3, r3, #7
 8000a20:	4619      	mov	r1, r3
 8000a22:	687b      	ldr	r3, [r7, #4]
 8000a24:	681b      	ldr	r3, [r3, #0]
 8000a26:	430a      	orrs	r2, r1
 8000a28:	601a      	str	r2, [r3, #0]
			100: fPCLK/32
			101: fPCLK/64
			110: fPCLK/128
			111: fPCLK/256
	 */
	if(SPI_config->mode == SPI_MODE_MASTER){    // Master mode
 8000a2a:	687b      	ldr	r3, [r7, #4]
 8000a2c:	791b      	ldrb	r3, [r3, #4]
 8000a2e:	2b01      	cmp	r3, #1
 8000a30:	d113      	bne.n	8000a5a <MCAL_SPI_Init+0x176>
		SPI_config->SPIx->CR1 &= ~(0b111 << 3);
 8000a32:	687b      	ldr	r3, [r7, #4]
 8000a34:	681b      	ldr	r3, [r3, #0]
 8000a36:	681a      	ldr	r2, [r3, #0]
 8000a38:	687b      	ldr	r3, [r7, #4]
 8000a3a:	681b      	ldr	r3, [r3, #0]
 8000a3c:	f022 0238 	bic.w	r2, r2, #56	; 0x38
 8000a40:	601a      	str	r2, [r3, #0]
		SPI_config->SPIx->CR1 |= ((SPI_config->baudRate & 0x7) << 3);
 8000a42:	687b      	ldr	r3, [r7, #4]
 8000a44:	681b      	ldr	r3, [r3, #0]
 8000a46:	6819      	ldr	r1, [r3, #0]
 8000a48:	687b      	ldr	r3, [r7, #4]
 8000a4a:	7b5b      	ldrb	r3, [r3, #13]
 8000a4c:	00db      	lsls	r3, r3, #3
 8000a4e:	f003 0238 	and.w	r2, r3, #56	; 0x38
 8000a52:	687b      	ldr	r3, [r7, #4]
 8000a54:	681b      	ldr	r3, [r3, #0]
 8000a56:	430a      	orrs	r2, r1
 8000a58:	601a      	str	r2, [r3, #0]
		Bit 2 SSOE: SS output enable
			0: SS output is disabled in master mode and the cell can work in multimaster configuration
			1: SS output is enabled in master mode and when the cell is enabled. The cell cannot work
			in a multimaster environment.
	 */
	SPI_config->SPIx->CR2 |= (SPI_config->ssoe << 2);
 8000a5a:	687b      	ldr	r3, [r7, #4]
 8000a5c:	681b      	ldr	r3, [r3, #0]
 8000a5e:	685a      	ldr	r2, [r3, #4]
 8000a60:	687b      	ldr	r3, [r7, #4]
 8000a62:	7d1b      	ldrb	r3, [r3, #20]
 8000a64:	009b      	lsls	r3, r3, #2
 8000a66:	4619      	mov	r1, r3
 8000a68:	687b      	ldr	r3, [r7, #4]
 8000a6a:	681b      	ldr	r3, [r3, #0]
 8000a6c:	430a      	orrs	r2, r1
 8000a6e:	605a      	str	r2, [r3, #4]
	/*
		Bit 7 TXEIE: Tx buffer empty interrupt enable
			0: TXE interrupt masked
			1: TXE interrupt not masked. Used to generate an interrupt request when the TXE flag is set.
	 */
	if(SPI_config->txeInterrupt == SPI_TXE_IRQ_ENABLED){
 8000a70:	687b      	ldr	r3, [r7, #4]
 8000a72:	7c9b      	ldrb	r3, [r3, #18]
 8000a74:	2b01      	cmp	r3, #1
 8000a76:	d10a      	bne.n	8000a8e <MCAL_SPI_Init+0x1aa>
		SET_BIT(SPI_config->SPIx->CR2, 7);
 8000a78:	687b      	ldr	r3, [r7, #4]
 8000a7a:	681b      	ldr	r3, [r3, #0]
 8000a7c:	685a      	ldr	r2, [r3, #4]
 8000a7e:	687b      	ldr	r3, [r7, #4]
 8000a80:	681b      	ldr	r3, [r3, #0]
 8000a82:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8000a86:	605a      	str	r2, [r3, #4]
		// Enable Global Interrupt
		MCAL_SPI_Enable_Global_Interrupt(SPI_config);
 8000a88:	6878      	ldr	r0, [r7, #4]
 8000a8a:	f7ff ff05 	bl	8000898 <MCAL_SPI_Enable_Global_Interrupt>
	/*
		Bit 6 RXNEIE: RX buffer not empty interrupt enable
			0: RXNE interrupt masked
			1: RXNE interrupt not masked. Used to generate an interrupt request when the RXNE flag is.
	 */
	if(SPI_config->rxneInterrupt == SPI_RXNE_IRQ_ENABLED){
 8000a8e:	687b      	ldr	r3, [r7, #4]
 8000a90:	7cdb      	ldrb	r3, [r3, #19]
 8000a92:	2b01      	cmp	r3, #1
 8000a94:	d10a      	bne.n	8000aac <MCAL_SPI_Init+0x1c8>
		SET_BIT(SPI_config->SPIx->CR2, 6);
 8000a96:	687b      	ldr	r3, [r7, #4]
 8000a98:	681b      	ldr	r3, [r3, #0]
 8000a9a:	685a      	ldr	r2, [r3, #4]
 8000a9c:	687b      	ldr	r3, [r7, #4]
 8000a9e:	681b      	ldr	r3, [r3, #0]
 8000aa0:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8000aa4:	605a      	str	r2, [r3, #4]
		// Enable Global Interrupt
		MCAL_SPI_Enable_Global_Interrupt(SPI_config);
 8000aa6:	6878      	ldr	r0, [r7, #4]
 8000aa8:	f7ff fef6 	bl	8000898 <MCAL_SPI_Enable_Global_Interrupt>
	}

	// Set the function callback
	MCAL_SPI_SetCallBackFunction(SPI_config);
 8000aac:	6878      	ldr	r0, [r7, #4]
 8000aae:	f7ff fed1 	bl	8000854 <MCAL_SPI_SetCallBackFunction>

	// Set GPIO pins for SPI
	MCAL_SPI_Set_GPIO_Pins(SPI_config);
 8000ab2:	6878      	ldr	r0, [r7, #4]
 8000ab4:	f7ff fda0 	bl	80005f8 <MCAL_SPI_Set_GPIO_Pins>
	/*
	 	 Bit 6 SPE: SPI enable
			0: Peripheral disabled
			1: Peripheral enabled
	 */
	SET_BIT(SPI_config->SPIx->CR1, 6);
 8000ab8:	687b      	ldr	r3, [r7, #4]
 8000aba:	681b      	ldr	r3, [r3, #0]
 8000abc:	681a      	ldr	r2, [r3, #0]
 8000abe:	687b      	ldr	r3, [r7, #4]
 8000ac0:	681b      	ldr	r3, [r3, #0]
 8000ac2:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8000ac6:	601a      	str	r2, [r3, #0]
}
 8000ac8:	bf00      	nop
 8000aca:	3708      	adds	r7, #8
 8000acc:	46bd      	mov	sp, r7
 8000ace:	bd80      	pop	{r7, pc}
 8000ad0:	40013000 	.word	0x40013000
 8000ad4:	40021000 	.word	0x40021000
 8000ad8:	40003800 	.word	0x40003800

08000adc <MCAL_SPI_Transmit>:


void MCAL_SPI_Transmit(SPI_Config_t *SPI_config, uint16 data){
 8000adc:	b480      	push	{r7}
 8000ade:	b083      	sub	sp, #12
 8000ae0:	af00      	add	r7, sp, #0
 8000ae2:	6078      	str	r0, [r7, #4]
 8000ae4:	460b      	mov	r3, r1
 8000ae6:	807b      	strh	r3, [r7, #2]
	/*
	 	 Bit 1 TXE: Transmit buffer empty
			0: Tx buffer not empty
			1: Tx buffer empty
	 */
	while(!(READ_BIT(SPI_config->SPIx->SR, 1)));
 8000ae8:	bf00      	nop
 8000aea:	687b      	ldr	r3, [r7, #4]
 8000aec:	681b      	ldr	r3, [r3, #0]
 8000aee:	689b      	ldr	r3, [r3, #8]
 8000af0:	085b      	lsrs	r3, r3, #1
 8000af2:	f003 0301 	and.w	r3, r3, #1
 8000af6:	2b00      	cmp	r3, #0
 8000af8:	d0f7      	beq.n	8000aea <MCAL_SPI_Transmit+0xe>
	SPI_config->SPIx->DR = data;
 8000afa:	687b      	ldr	r3, [r7, #4]
 8000afc:	681b      	ldr	r3, [r3, #0]
 8000afe:	887a      	ldrh	r2, [r7, #2]
 8000b00:	60da      	str	r2, [r3, #12]
}
 8000b02:	bf00      	nop
 8000b04:	370c      	adds	r7, #12
 8000b06:	46bd      	mov	sp, r7
 8000b08:	bc80      	pop	{r7}
 8000b0a:	4770      	bx	lr

08000b0c <MCAL_SPI_Recieve>:

uint16 MCAL_SPI_Recieve(SPI_Config_t *SPI_config){
 8000b0c:	b480      	push	{r7}
 8000b0e:	b085      	sub	sp, #20
 8000b10:	af00      	add	r7, sp, #0
 8000b12:	6078      	str	r0, [r7, #4]
	/*
		 Bit 0 RXNE: Receive buffer not empty
			0: Rx buffer empty
			1: Rx buffer not empty
	 */
	while(!(READ_BIT(SPI_config->SPIx->SR, 0)));
 8000b14:	bf00      	nop
 8000b16:	687b      	ldr	r3, [r7, #4]
 8000b18:	681b      	ldr	r3, [r3, #0]
 8000b1a:	689b      	ldr	r3, [r3, #8]
 8000b1c:	f003 0301 	and.w	r3, r3, #1
 8000b20:	2b00      	cmp	r3, #0
 8000b22:	d0f8      	beq.n	8000b16 <MCAL_SPI_Recieve+0xa>
	RecievedData = SPI_config->SPIx->DR;
 8000b24:	687b      	ldr	r3, [r7, #4]
 8000b26:	681b      	ldr	r3, [r3, #0]
 8000b28:	68db      	ldr	r3, [r3, #12]
 8000b2a:	81fb      	strh	r3, [r7, #14]
	return RecievedData;
 8000b2c:	89fb      	ldrh	r3, [r7, #14]
}
 8000b2e:	4618      	mov	r0, r3
 8000b30:	3714      	adds	r7, #20
 8000b32:	46bd      	mov	sp, r7
 8000b34:	bc80      	pop	{r7}
 8000b36:	4770      	bx	lr

08000b38 <MCAL_SPI_Transmit_Recieve>:

uint16 MCAL_SPI_Transmit_Recieve(SPI_Config_t *SPI_config, uint16 data){
 8000b38:	b580      	push	{r7, lr}
 8000b3a:	b084      	sub	sp, #16
 8000b3c:	af00      	add	r7, sp, #0
 8000b3e:	6078      	str	r0, [r7, #4]
 8000b40:	460b      	mov	r3, r1
 8000b42:	807b      	strh	r3, [r7, #2]
	uint16 RecievedData;
	MCAL_SPI_Transmit(SPI_config, data);
 8000b44:	887b      	ldrh	r3, [r7, #2]
 8000b46:	4619      	mov	r1, r3
 8000b48:	6878      	ldr	r0, [r7, #4]
 8000b4a:	f7ff ffc7 	bl	8000adc <MCAL_SPI_Transmit>
	RecievedData = MCAL_SPI_Recieve(SPI_config);
 8000b4e:	6878      	ldr	r0, [r7, #4]
 8000b50:	f7ff ffdc 	bl	8000b0c <MCAL_SPI_Recieve>
 8000b54:	4603      	mov	r3, r0
 8000b56:	81fb      	strh	r3, [r7, #14]
	return RecievedData;
 8000b58:	89fb      	ldrh	r3, [r7, #14]
}
 8000b5a:	4618      	mov	r0, r3
 8000b5c:	3710      	adds	r7, #16
 8000b5e:	46bd      	mov	sp, r7
 8000b60:	bd80      	pop	{r7, pc}
	...

08000b64 <SPI1_IRQHandler>:

/* ================================================================ */
/* ============================= ISR ============================== */
/* ================================================================ */

void SPI1_IRQHandler(void){
 8000b64:	b580      	push	{r7, lr}
 8000b66:	af00      	add	r7, sp, #0
	SPI_CallBackFunction[0]();
 8000b68:	4b02      	ldr	r3, [pc, #8]	; (8000b74 <SPI1_IRQHandler+0x10>)
 8000b6a:	681b      	ldr	r3, [r3, #0]
 8000b6c:	4798      	blx	r3
}
 8000b6e:	bf00      	nop
 8000b70:	bd80      	pop	{r7, pc}
 8000b72:	bf00      	nop
 8000b74:	20000090 	.word	0x20000090

08000b78 <SPI2_IRQHandler>:

void SPI2_IRQHandler(void){
 8000b78:	b580      	push	{r7, lr}
 8000b7a:	af00      	add	r7, sp, #0
	SPI_CallBackFunction[1]();
 8000b7c:	4b02      	ldr	r3, [pc, #8]	; (8000b88 <SPI2_IRQHandler+0x10>)
 8000b7e:	685b      	ldr	r3, [r3, #4]
 8000b80:	4798      	blx	r3
}
 8000b82:	bf00      	nop
 8000b84:	bd80      	pop	{r7, pc}
 8000b86:	bf00      	nop
 8000b88:	20000090 	.word	0x20000090

08000b8c <MCAL_USART_WaitForTc>:
 * @Retval      None
 *
 * @Note        This function is static and intended for internal use only.
 *              It ensures that all data is transmitted before proceeding.
 */
static void MCAL_USART_WaitForTc(USART_Config_t *USART_Config){
 8000b8c:	b480      	push	{r7}
 8000b8e:	b083      	sub	sp, #12
 8000b90:	af00      	add	r7, sp, #0
 8000b92:	6078      	str	r0, [r7, #4]
	while (!(READ_BIT(USART_Config->USARTx->SR, 6)));
 8000b94:	bf00      	nop
 8000b96:	687b      	ldr	r3, [r7, #4]
 8000b98:	681b      	ldr	r3, [r3, #0]
 8000b9a:	681b      	ldr	r3, [r3, #0]
 8000b9c:	099b      	lsrs	r3, r3, #6
 8000b9e:	f003 0301 	and.w	r3, r3, #1
 8000ba2:	2b00      	cmp	r3, #0
 8000ba4:	d0f7      	beq.n	8000b96 <MCAL_USART_WaitForTc+0xa>
}
 8000ba6:	bf00      	nop
 8000ba8:	370c      	adds	r7, #12
 8000baa:	46bd      	mov	sp, r7
 8000bac:	bc80      	pop	{r7}
 8000bae:	4770      	bx	lr

08000bb0 <MCAL_USART_SetBaudRate>:
 * @Retval      None
 *
 * @Note        This function is static and intended for internal use only.
 *              The calculation for the baud rate register depends on the clock frequency.
 */
static void MCAL_USART_SetBaudRate(USART_Config_t *USART_Config, uint32 F_CLK){
 8000bb0:	b480      	push	{r7}
 8000bb2:	b087      	sub	sp, #28
 8000bb4:	af00      	add	r7, sp, #0
 8000bb6:	6078      	str	r0, [r7, #4]
 8000bb8:	6039      	str	r1, [r7, #0]
	/*
	     * USARTDIV = fCK / (16 * baud_rate)
	     * BRR[15:4] = Mantissa
	     * BRR[3:0] = Fraction
	 */
	uint32 USARTDIV = (F_CLK / (16UL * (USART_Config->baud_rate)));
 8000bba:	687b      	ldr	r3, [r7, #4]
 8000bbc:	691b      	ldr	r3, [r3, #16]
 8000bbe:	011b      	lsls	r3, r3, #4
 8000bc0:	683a      	ldr	r2, [r7, #0]
 8000bc2:	fbb2 f3f3 	udiv	r3, r2, r3
 8000bc6:	617b      	str	r3, [r7, #20]
	uint32 USARTDIV_MUL100 = ((F_CLK / (16UL * (USART_Config->baud_rate))) * 100);
 8000bc8:	687b      	ldr	r3, [r7, #4]
 8000bca:	691b      	ldr	r3, [r3, #16]
 8000bcc:	011b      	lsls	r3, r3, #4
 8000bce:	683a      	ldr	r2, [r7, #0]
 8000bd0:	fbb2 f3f3 	udiv	r3, r2, r3
 8000bd4:	2264      	movs	r2, #100	; 0x64
 8000bd6:	fb02 f303 	mul.w	r3, r2, r3
 8000bda:	613b      	str	r3, [r7, #16]
	uint16 DIV_Mantissa = USARTDIV;                       // Mantissa part
 8000bdc:	697b      	ldr	r3, [r7, #20]
 8000bde:	81fb      	strh	r3, [r7, #14]
	uint16 DIV_Mantissa_MUL100 = DIV_Mantissa * 100;
 8000be0:	89fb      	ldrh	r3, [r7, #14]
 8000be2:	461a      	mov	r2, r3
 8000be4:	0092      	lsls	r2, r2, #2
 8000be6:	4413      	add	r3, r2
 8000be8:	461a      	mov	r2, r3
 8000bea:	0091      	lsls	r1, r2, #2
 8000bec:	461a      	mov	r2, r3
 8000bee:	460b      	mov	r3, r1
 8000bf0:	4413      	add	r3, r2
 8000bf2:	009b      	lsls	r3, r3, #2
 8000bf4:	81bb      	strh	r3, [r7, #12]
	uint8 DIV_Fraction = ((USARTDIV_MUL100 - DIV_Mantissa_MUL100 ) * 16) / 100;       // Function part
 8000bf6:	89bb      	ldrh	r3, [r7, #12]
 8000bf8:	693a      	ldr	r2, [r7, #16]
 8000bfa:	1ad3      	subs	r3, r2, r3
 8000bfc:	011b      	lsls	r3, r3, #4
 8000bfe:	4a09      	ldr	r2, [pc, #36]	; (8000c24 <MCAL_USART_SetBaudRate+0x74>)
 8000c00:	fba2 2303 	umull	r2, r3, r2, r3
 8000c04:	095b      	lsrs	r3, r3, #5
 8000c06:	72fb      	strb	r3, [r7, #11]

	USART_Config->USARTx->BRR = ((DIV_Mantissa << 4) | (DIV_Fraction & 0xF));
 8000c08:	89fb      	ldrh	r3, [r7, #14]
 8000c0a:	011a      	lsls	r2, r3, #4
 8000c0c:	7afb      	ldrb	r3, [r7, #11]
 8000c0e:	f003 030f 	and.w	r3, r3, #15
 8000c12:	431a      	orrs	r2, r3
 8000c14:	687b      	ldr	r3, [r7, #4]
 8000c16:	681b      	ldr	r3, [r3, #0]
 8000c18:	609a      	str	r2, [r3, #8]
}
 8000c1a:	bf00      	nop
 8000c1c:	371c      	adds	r7, #28
 8000c1e:	46bd      	mov	sp, r7
 8000c20:	bc80      	pop	{r7}
 8000c22:	4770      	bx	lr
 8000c24:	51eb851f 	.word	0x51eb851f

08000c28 <MCAL_USART_GPIO_Set_Pins>:
 * @Retval      None
 *
 * @Note        This function is static and intended for internal use only.
 *              Ensure that the GPIO peripheral is properly initialized before calling this function.
 */
static void MCAL_USART_GPIO_Set_Pins(USART_Config_t *USART_Config) {
 8000c28:	b580      	push	{r7, lr}
 8000c2a:	b084      	sub	sp, #16
 8000c2c:	af00      	add	r7, sp, #0
 8000c2e:	6078      	str	r0, [r7, #4]
    GPIO_PinConfig_t pinConfig;

    if (USART_Config->USARTx == USART1) {
 8000c30:	687b      	ldr	r3, [r7, #4]
 8000c32:	681b      	ldr	r3, [r3, #0]
 8000c34:	4a5d      	ldr	r2, [pc, #372]	; (8000dac <MCAL_USART_GPIO_Set_Pins+0x184>)
 8000c36:	4293      	cmp	r3, r2
 8000c38:	d139      	bne.n	8000cae <MCAL_USART_GPIO_Set_Pins+0x86>
        // Configure Tx (PA9 or PB6)
        pinConfig.PinNum = GPIO_PIN9;  // Default: PA9
 8000c3a:	2309      	movs	r3, #9
 8000c3c:	733b      	strb	r3, [r7, #12]
        pinConfig.PinMode = GPIO_OUTPUT_10MHZ;
 8000c3e:	2301      	movs	r3, #1
 8000c40:	737b      	strb	r3, [r7, #13]
        pinConfig.PinCNF = GPIO_CNF_AF_PUSH_PULL_OUTPUT;
 8000c42:	2302      	movs	r3, #2
 8000c44:	73fb      	strb	r3, [r7, #15]
        MCAL_GPIO_Init(GPIOA, &pinConfig);
 8000c46:	f107 030c 	add.w	r3, r7, #12
 8000c4a:	4619      	mov	r1, r3
 8000c4c:	4858      	ldr	r0, [pc, #352]	; (8000db0 <MCAL_USART_GPIO_Set_Pins+0x188>)
 8000c4e:	f7ff fbf3 	bl	8000438 <MCAL_GPIO_Init>

        // Configure Rx (PA10 or PB7)
        pinConfig.PinNum = GPIO_PIN10;  // Default: PA10
 8000c52:	230a      	movs	r3, #10
 8000c54:	733b      	strb	r3, [r7, #12]
        pinConfig.PinMode = GPIO_INPUT;
 8000c56:	2300      	movs	r3, #0
 8000c58:	737b      	strb	r3, [r7, #13]
        pinConfig.PinCNF = GPIO_CNF_FLOATING_INPUT;
 8000c5a:	2301      	movs	r3, #1
 8000c5c:	73fb      	strb	r3, [r7, #15]
        MCAL_GPIO_Init(GPIOA, &pinConfig);
 8000c5e:	f107 030c 	add.w	r3, r7, #12
 8000c62:	4619      	mov	r1, r3
 8000c64:	4852      	ldr	r0, [pc, #328]	; (8000db0 <MCAL_USART_GPIO_Set_Pins+0x188>)
 8000c66:	f7ff fbe7 	bl	8000438 <MCAL_GPIO_Init>

        // Configure CTS (PA11) if enabled
        if (USART_Config->CTS_CTRL == USART_CTS_ENABLED) {
 8000c6a:	687b      	ldr	r3, [r7, #4]
 8000c6c:	7b1b      	ldrb	r3, [r3, #12]
 8000c6e:	2b01      	cmp	r3, #1
 8000c70:	d10b      	bne.n	8000c8a <MCAL_USART_GPIO_Set_Pins+0x62>
            pinConfig.PinNum = GPIO_PIN11;  // CTS: PA11
 8000c72:	230b      	movs	r3, #11
 8000c74:	733b      	strb	r3, [r7, #12]
            pinConfig.PinMode = GPIO_INPUT;
 8000c76:	2300      	movs	r3, #0
 8000c78:	737b      	strb	r3, [r7, #13]
            pinConfig.PinCNF = GPIO_CNF_FLOATING_INPUT;
 8000c7a:	2301      	movs	r3, #1
 8000c7c:	73fb      	strb	r3, [r7, #15]
            MCAL_GPIO_Init(GPIOA, &pinConfig);
 8000c7e:	f107 030c 	add.w	r3, r7, #12
 8000c82:	4619      	mov	r1, r3
 8000c84:	484a      	ldr	r0, [pc, #296]	; (8000db0 <MCAL_USART_GPIO_Set_Pins+0x188>)
 8000c86:	f7ff fbd7 	bl	8000438 <MCAL_GPIO_Init>
        }

        // Configure RTS (PA12) if enabled
        if (USART_Config->RTS_CTRL == USART_RTS_ENABLED) {
 8000c8a:	687b      	ldr	r3, [r7, #4]
 8000c8c:	7b5b      	ldrb	r3, [r3, #13]
 8000c8e:	2b01      	cmp	r3, #1
 8000c90:	f040 8088 	bne.w	8000da4 <MCAL_USART_GPIO_Set_Pins+0x17c>
            pinConfig.PinNum = GPIO_PIN12;  // RTS: PA12
 8000c94:	230c      	movs	r3, #12
 8000c96:	733b      	strb	r3, [r7, #12]
            pinConfig.PinMode = GPIO_OUTPUT_10MHZ;
 8000c98:	2301      	movs	r3, #1
 8000c9a:	737b      	strb	r3, [r7, #13]
            pinConfig.PinCNF = GPIO_CNF_AF_PUSH_PULL_OUTPUT;
 8000c9c:	2302      	movs	r3, #2
 8000c9e:	73fb      	strb	r3, [r7, #15]
            MCAL_GPIO_Init(GPIOA, &pinConfig);
 8000ca0:	f107 030c 	add.w	r3, r7, #12
 8000ca4:	4619      	mov	r1, r3
 8000ca6:	4842      	ldr	r0, [pc, #264]	; (8000db0 <MCAL_USART_GPIO_Set_Pins+0x188>)
 8000ca8:	f7ff fbc6 	bl	8000438 <MCAL_GPIO_Init>
            pinConfig.PinMode = GPIO_OUTPUT_10MHZ;
            pinConfig.PinCNF = GPIO_CNF_AF_PUSH_PULL_OUTPUT;
            MCAL_GPIO_Init(GPIOB, &pinConfig);
        }
    }
}
 8000cac:	e07a      	b.n	8000da4 <MCAL_USART_GPIO_Set_Pins+0x17c>
    else if (USART_Config->USARTx == USART2) {
 8000cae:	687b      	ldr	r3, [r7, #4]
 8000cb0:	681b      	ldr	r3, [r3, #0]
 8000cb2:	4a40      	ldr	r2, [pc, #256]	; (8000db4 <MCAL_USART_GPIO_Set_Pins+0x18c>)
 8000cb4:	4293      	cmp	r3, r2
 8000cb6:	d138      	bne.n	8000d2a <MCAL_USART_GPIO_Set_Pins+0x102>
        pinConfig.PinNum = GPIO_PIN2;  // Tx: PA2
 8000cb8:	2302      	movs	r3, #2
 8000cba:	733b      	strb	r3, [r7, #12]
        pinConfig.PinMode = GPIO_OUTPUT_10MHZ;
 8000cbc:	2301      	movs	r3, #1
 8000cbe:	737b      	strb	r3, [r7, #13]
        pinConfig.PinCNF = GPIO_CNF_AF_PUSH_PULL_OUTPUT;
 8000cc0:	2302      	movs	r3, #2
 8000cc2:	73fb      	strb	r3, [r7, #15]
        MCAL_GPIO_Init(GPIOA, &pinConfig);
 8000cc4:	f107 030c 	add.w	r3, r7, #12
 8000cc8:	4619      	mov	r1, r3
 8000cca:	4839      	ldr	r0, [pc, #228]	; (8000db0 <MCAL_USART_GPIO_Set_Pins+0x188>)
 8000ccc:	f7ff fbb4 	bl	8000438 <MCAL_GPIO_Init>
        pinConfig.PinNum = GPIO_PIN3;  // Rx: PA3
 8000cd0:	2303      	movs	r3, #3
 8000cd2:	733b      	strb	r3, [r7, #12]
        pinConfig.PinMode = GPIO_INPUT;
 8000cd4:	2300      	movs	r3, #0
 8000cd6:	737b      	strb	r3, [r7, #13]
        pinConfig.PinCNF = GPIO_CNF_FLOATING_INPUT;
 8000cd8:	2301      	movs	r3, #1
 8000cda:	73fb      	strb	r3, [r7, #15]
        MCAL_GPIO_Init(GPIOA, &pinConfig);
 8000cdc:	f107 030c 	add.w	r3, r7, #12
 8000ce0:	4619      	mov	r1, r3
 8000ce2:	4833      	ldr	r0, [pc, #204]	; (8000db0 <MCAL_USART_GPIO_Set_Pins+0x188>)
 8000ce4:	f7ff fba8 	bl	8000438 <MCAL_GPIO_Init>
        if (USART_Config->CTS_CTRL == USART_CTS_ENABLED) {
 8000ce8:	687b      	ldr	r3, [r7, #4]
 8000cea:	7b1b      	ldrb	r3, [r3, #12]
 8000cec:	2b01      	cmp	r3, #1
 8000cee:	d10b      	bne.n	8000d08 <MCAL_USART_GPIO_Set_Pins+0xe0>
            pinConfig.PinNum = GPIO_PIN0;  // CTS: PA0
 8000cf0:	2300      	movs	r3, #0
 8000cf2:	733b      	strb	r3, [r7, #12]
            pinConfig.PinMode = GPIO_INPUT;
 8000cf4:	2300      	movs	r3, #0
 8000cf6:	737b      	strb	r3, [r7, #13]
            pinConfig.PinCNF = GPIO_CNF_FLOATING_INPUT;
 8000cf8:	2301      	movs	r3, #1
 8000cfa:	73fb      	strb	r3, [r7, #15]
            MCAL_GPIO_Init(GPIOA, &pinConfig);
 8000cfc:	f107 030c 	add.w	r3, r7, #12
 8000d00:	4619      	mov	r1, r3
 8000d02:	482b      	ldr	r0, [pc, #172]	; (8000db0 <MCAL_USART_GPIO_Set_Pins+0x188>)
 8000d04:	f7ff fb98 	bl	8000438 <MCAL_GPIO_Init>
        if (USART_Config->RTS_CTRL == USART_RTS_ENABLED) {
 8000d08:	687b      	ldr	r3, [r7, #4]
 8000d0a:	7b5b      	ldrb	r3, [r3, #13]
 8000d0c:	2b01      	cmp	r3, #1
 8000d0e:	d149      	bne.n	8000da4 <MCAL_USART_GPIO_Set_Pins+0x17c>
            pinConfig.PinNum = GPIO_PIN1;  // RTS: PA1
 8000d10:	2301      	movs	r3, #1
 8000d12:	733b      	strb	r3, [r7, #12]
            pinConfig.PinMode = GPIO_OUTPUT_10MHZ;
 8000d14:	2301      	movs	r3, #1
 8000d16:	737b      	strb	r3, [r7, #13]
            pinConfig.PinCNF = GPIO_CNF_AF_PUSH_PULL_OUTPUT;
 8000d18:	2302      	movs	r3, #2
 8000d1a:	73fb      	strb	r3, [r7, #15]
            MCAL_GPIO_Init(GPIOA, &pinConfig);
 8000d1c:	f107 030c 	add.w	r3, r7, #12
 8000d20:	4619      	mov	r1, r3
 8000d22:	4823      	ldr	r0, [pc, #140]	; (8000db0 <MCAL_USART_GPIO_Set_Pins+0x188>)
 8000d24:	f7ff fb88 	bl	8000438 <MCAL_GPIO_Init>
}
 8000d28:	e03c      	b.n	8000da4 <MCAL_USART_GPIO_Set_Pins+0x17c>
    else if (USART_Config->USARTx == USART3) {
 8000d2a:	687b      	ldr	r3, [r7, #4]
 8000d2c:	681b      	ldr	r3, [r3, #0]
 8000d2e:	4a22      	ldr	r2, [pc, #136]	; (8000db8 <MCAL_USART_GPIO_Set_Pins+0x190>)
 8000d30:	4293      	cmp	r3, r2
 8000d32:	d137      	bne.n	8000da4 <MCAL_USART_GPIO_Set_Pins+0x17c>
        pinConfig.PinNum = GPIO_PIN10;  // Tx: PB10
 8000d34:	230a      	movs	r3, #10
 8000d36:	733b      	strb	r3, [r7, #12]
        pinConfig.PinMode = GPIO_OUTPUT_10MHZ;
 8000d38:	2301      	movs	r3, #1
 8000d3a:	737b      	strb	r3, [r7, #13]
        pinConfig.PinCNF = GPIO_CNF_AF_PUSH_PULL_OUTPUT;
 8000d3c:	2302      	movs	r3, #2
 8000d3e:	73fb      	strb	r3, [r7, #15]
        MCAL_GPIO_Init(GPIOB, &pinConfig);
 8000d40:	f107 030c 	add.w	r3, r7, #12
 8000d44:	4619      	mov	r1, r3
 8000d46:	481d      	ldr	r0, [pc, #116]	; (8000dbc <MCAL_USART_GPIO_Set_Pins+0x194>)
 8000d48:	f7ff fb76 	bl	8000438 <MCAL_GPIO_Init>
        pinConfig.PinNum = GPIO_PIN11;  // Rx: PB11
 8000d4c:	230b      	movs	r3, #11
 8000d4e:	733b      	strb	r3, [r7, #12]
        pinConfig.PinMode = GPIO_INPUT;
 8000d50:	2300      	movs	r3, #0
 8000d52:	737b      	strb	r3, [r7, #13]
        pinConfig.PinCNF = GPIO_CNF_FLOATING_INPUT;
 8000d54:	2301      	movs	r3, #1
 8000d56:	73fb      	strb	r3, [r7, #15]
        MCAL_GPIO_Init(GPIOB, &pinConfig);
 8000d58:	f107 030c 	add.w	r3, r7, #12
 8000d5c:	4619      	mov	r1, r3
 8000d5e:	4817      	ldr	r0, [pc, #92]	; (8000dbc <MCAL_USART_GPIO_Set_Pins+0x194>)
 8000d60:	f7ff fb6a 	bl	8000438 <MCAL_GPIO_Init>
        if (USART_Config->CTS_CTRL == USART_CTS_ENABLED) {
 8000d64:	687b      	ldr	r3, [r7, #4]
 8000d66:	7b1b      	ldrb	r3, [r3, #12]
 8000d68:	2b01      	cmp	r3, #1
 8000d6a:	d10b      	bne.n	8000d84 <MCAL_USART_GPIO_Set_Pins+0x15c>
            pinConfig.PinNum = GPIO_PIN13;  // CTS: PB13
 8000d6c:	230d      	movs	r3, #13
 8000d6e:	733b      	strb	r3, [r7, #12]
            pinConfig.PinMode = GPIO_INPUT;
 8000d70:	2300      	movs	r3, #0
 8000d72:	737b      	strb	r3, [r7, #13]
            pinConfig.PinCNF = GPIO_CNF_FLOATING_INPUT;
 8000d74:	2301      	movs	r3, #1
 8000d76:	73fb      	strb	r3, [r7, #15]
            MCAL_GPIO_Init(GPIOB, &pinConfig);
 8000d78:	f107 030c 	add.w	r3, r7, #12
 8000d7c:	4619      	mov	r1, r3
 8000d7e:	480f      	ldr	r0, [pc, #60]	; (8000dbc <MCAL_USART_GPIO_Set_Pins+0x194>)
 8000d80:	f7ff fb5a 	bl	8000438 <MCAL_GPIO_Init>
        if (USART_Config->RTS_CTRL == USART_RTS_ENABLED) {
 8000d84:	687b      	ldr	r3, [r7, #4]
 8000d86:	7b5b      	ldrb	r3, [r3, #13]
 8000d88:	2b01      	cmp	r3, #1
 8000d8a:	d10b      	bne.n	8000da4 <MCAL_USART_GPIO_Set_Pins+0x17c>
            pinConfig.PinNum = GPIO_PIN14;  // RTS: PB14
 8000d8c:	230e      	movs	r3, #14
 8000d8e:	733b      	strb	r3, [r7, #12]
            pinConfig.PinMode = GPIO_OUTPUT_10MHZ;
 8000d90:	2301      	movs	r3, #1
 8000d92:	737b      	strb	r3, [r7, #13]
            pinConfig.PinCNF = GPIO_CNF_AF_PUSH_PULL_OUTPUT;
 8000d94:	2302      	movs	r3, #2
 8000d96:	73fb      	strb	r3, [r7, #15]
            MCAL_GPIO_Init(GPIOB, &pinConfig);
 8000d98:	f107 030c 	add.w	r3, r7, #12
 8000d9c:	4619      	mov	r1, r3
 8000d9e:	4807      	ldr	r0, [pc, #28]	; (8000dbc <MCAL_USART_GPIO_Set_Pins+0x194>)
 8000da0:	f7ff fb4a 	bl	8000438 <MCAL_GPIO_Init>
}
 8000da4:	bf00      	nop
 8000da6:	3710      	adds	r7, #16
 8000da8:	46bd      	mov	sp, r7
 8000daa:	bd80      	pop	{r7, pc}
 8000dac:	40013800 	.word	0x40013800
 8000db0:	40010800 	.word	0x40010800
 8000db4:	40004400 	.word	0x40004400
 8000db8:	40004800 	.word	0x40004800
 8000dbc:	40010c00 	.word	0x40010c00

08000dc0 <MCAL_USART_Init>:
 *
 * @Retval      None
 *
 * @Note        This function must be called before using any USART transmit or receive APIs.
 */
void MCAL_USART_Init(USART_Config_t *USART_Config){
 8000dc0:	b580      	push	{r7, lr}
 8000dc2:	b084      	sub	sp, #16
 8000dc4:	af00      	add	r7, sp, #0
 8000dc6:	6078      	str	r0, [r7, #4]
	uint32 F_CLK;

	// Enable the clock for configured USART (1, 2, 3)
	if(USART_Config->USARTx == USART1){
 8000dc8:	687b      	ldr	r3, [r7, #4]
 8000dca:	681b      	ldr	r3, [r3, #0]
 8000dcc:	4a76      	ldr	r2, [pc, #472]	; (8000fa8 <MCAL_USART_Init+0x1e8>)
 8000dce:	4293      	cmp	r3, r2
 8000dd0:	d10c      	bne.n	8000dec <MCAL_USART_Init+0x2c>
		USART1_CLK_EN();
 8000dd2:	4b76      	ldr	r3, [pc, #472]	; (8000fac <MCAL_USART_Init+0x1ec>)
 8000dd4:	699b      	ldr	r3, [r3, #24]
 8000dd6:	4a75      	ldr	r2, [pc, #468]	; (8000fac <MCAL_USART_Init+0x1ec>)
 8000dd8:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8000ddc:	6193      	str	r3, [r2, #24]
		// PCLK2 for USART1
		Global_USART_Config[0] = USART_Config;
 8000dde:	4a74      	ldr	r2, [pc, #464]	; (8000fb0 <MCAL_USART_Init+0x1f0>)
 8000de0:	687b      	ldr	r3, [r7, #4]
 8000de2:	6013      	str	r3, [r2, #0]
		F_CLK = MCAL_RCC_GetPCLK2_Freq();
 8000de4:	f7ff fbea 	bl	80005bc <MCAL_RCC_GetPCLK2_Freq>
 8000de8:	60f8      	str	r0, [r7, #12]
 8000dea:	e022      	b.n	8000e32 <MCAL_USART_Init+0x72>
	}
	else if(USART_Config->USARTx == USART2){
 8000dec:	687b      	ldr	r3, [r7, #4]
 8000dee:	681b      	ldr	r3, [r3, #0]
 8000df0:	4a70      	ldr	r2, [pc, #448]	; (8000fb4 <MCAL_USART_Init+0x1f4>)
 8000df2:	4293      	cmp	r3, r2
 8000df4:	d10c      	bne.n	8000e10 <MCAL_USART_Init+0x50>
		USART2_CLK_EN();
 8000df6:	4b6d      	ldr	r3, [pc, #436]	; (8000fac <MCAL_USART_Init+0x1ec>)
 8000df8:	699b      	ldr	r3, [r3, #24]
 8000dfa:	4a6c      	ldr	r2, [pc, #432]	; (8000fac <MCAL_USART_Init+0x1ec>)
 8000dfc:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8000e00:	6193      	str	r3, [r2, #24]
		// PCLK1 for USART2
		F_CLK = MCAL_RCC_GetPCLK1_Freq();
 8000e02:	f7ff fbbd 	bl	8000580 <MCAL_RCC_GetPCLK1_Freq>
 8000e06:	60f8      	str	r0, [r7, #12]
		Global_USART_Config[1] = USART_Config;
 8000e08:	4a69      	ldr	r2, [pc, #420]	; (8000fb0 <MCAL_USART_Init+0x1f0>)
 8000e0a:	687b      	ldr	r3, [r7, #4]
 8000e0c:	6053      	str	r3, [r2, #4]
 8000e0e:	e010      	b.n	8000e32 <MCAL_USART_Init+0x72>
	}
	else if(USART_Config->USARTx == USART3){
 8000e10:	687b      	ldr	r3, [r7, #4]
 8000e12:	681b      	ldr	r3, [r3, #0]
 8000e14:	4a68      	ldr	r2, [pc, #416]	; (8000fb8 <MCAL_USART_Init+0x1f8>)
 8000e16:	4293      	cmp	r3, r2
 8000e18:	d10b      	bne.n	8000e32 <MCAL_USART_Init+0x72>
		USART3_CLK_EN();
 8000e1a:	4b64      	ldr	r3, [pc, #400]	; (8000fac <MCAL_USART_Init+0x1ec>)
 8000e1c:	699b      	ldr	r3, [r3, #24]
 8000e1e:	4a63      	ldr	r2, [pc, #396]	; (8000fac <MCAL_USART_Init+0x1ec>)
 8000e20:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 8000e24:	6193      	str	r3, [r2, #24]
		// PCLK1 for USART3
		F_CLK = MCAL_RCC_GetPCLK1_Freq();
 8000e26:	f7ff fbab 	bl	8000580 <MCAL_RCC_GetPCLK1_Freq>
 8000e2a:	60f8      	str	r0, [r7, #12]
		Global_USART_Config[2] = USART_Config;
 8000e2c:	4a60      	ldr	r2, [pc, #384]	; (8000fb0 <MCAL_USART_Init+0x1f0>)
 8000e2e:	687b      	ldr	r3, [r7, #4]
 8000e30:	6093      	str	r3, [r2, #8]
	}

	// Configure the GPIO pins for Tx, Rx, CTS, RTS
	MCAL_USART_GPIO_Set_Pins(USART_Config);
 8000e32:	6878      	ldr	r0, [r7, #4]
 8000e34:	f7ff fef8 	bl	8000c28 <MCAL_USART_GPIO_Set_Pins>

	// Enable the USART by writing the UE bit in USART_CR1 register to 1
	SET_BIT(USART_Config->USARTx->CR1, 13);
 8000e38:	687b      	ldr	r3, [r7, #4]
 8000e3a:	681b      	ldr	r3, [r3, #0]
 8000e3c:	68da      	ldr	r2, [r3, #12]
 8000e3e:	687b      	ldr	r3, [r7, #4]
 8000e40:	681b      	ldr	r3, [r3, #0]
 8000e42:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 8000e46:	60da      	str	r2, [r3, #12]

	// Disable/Enable TX/RX
	if(USART_Config->TxMode == USART_TX_ENABLED)
 8000e48:	687b      	ldr	r3, [r7, #4]
 8000e4a:	7a1b      	ldrb	r3, [r3, #8]
 8000e4c:	2b01      	cmp	r3, #1
 8000e4e:	d107      	bne.n	8000e60 <MCAL_USART_Init+0xa0>
		SET_BIT(USART_Config->USARTx->CR1, 3);
 8000e50:	687b      	ldr	r3, [r7, #4]
 8000e52:	681b      	ldr	r3, [r3, #0]
 8000e54:	68da      	ldr	r2, [r3, #12]
 8000e56:	687b      	ldr	r3, [r7, #4]
 8000e58:	681b      	ldr	r3, [r3, #0]
 8000e5a:	f042 0208 	orr.w	r2, r2, #8
 8000e5e:	60da      	str	r2, [r3, #12]
	if(USART_Config->TxMode == USART_RX_ENABLED)
 8000e60:	687b      	ldr	r3, [r7, #4]
 8000e62:	7a1b      	ldrb	r3, [r3, #8]
 8000e64:	2b01      	cmp	r3, #1
 8000e66:	d107      	bne.n	8000e78 <MCAL_USART_Init+0xb8>
		SET_BIT(USART_Config->USARTx->CR1, 2);
 8000e68:	687b      	ldr	r3, [r7, #4]
 8000e6a:	681b      	ldr	r3, [r3, #0]
 8000e6c:	68da      	ldr	r2, [r3, #12]
 8000e6e:	687b      	ldr	r3, [r7, #4]
 8000e70:	681b      	ldr	r3, [r3, #0]
 8000e72:	f042 0204 	orr.w	r2, r2, #4
 8000e76:	60da      	str	r2, [r3, #12]

	// Set the Word Length
	if(USART_Config->wordLength == USART_9_BIT_WORD_LENGTH)
 8000e78:	687b      	ldr	r3, [r7, #4]
 8000e7a:	791b      	ldrb	r3, [r3, #4]
 8000e7c:	2b01      	cmp	r3, #1
 8000e7e:	d108      	bne.n	8000e92 <MCAL_USART_Init+0xd2>
		SET_BIT(USART_Config->USARTx->CR1, 12);   // 9 bit data
 8000e80:	687b      	ldr	r3, [r7, #4]
 8000e82:	681b      	ldr	r3, [r3, #0]
 8000e84:	68da      	ldr	r2, [r3, #12]
 8000e86:	687b      	ldr	r3, [r7, #4]
 8000e88:	681b      	ldr	r3, [r3, #0]
 8000e8a:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8000e8e:	60da      	str	r2, [r3, #12]
 8000e90:	e007      	b.n	8000ea2 <MCAL_USART_Init+0xe2>
	else
		CLEAR_BIT(USART_Config->USARTx->CR1, 12); // 8 bit data
 8000e92:	687b      	ldr	r3, [r7, #4]
 8000e94:	681b      	ldr	r3, [r3, #0]
 8000e96:	68da      	ldr	r2, [r3, #12]
 8000e98:	687b      	ldr	r3, [r7, #4]
 8000e9a:	681b      	ldr	r3, [r3, #0]
 8000e9c:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 8000ea0:	60da      	str	r2, [r3, #12]

	// Enable/Disable Parity bit
	if(USART_Config->parityMode == USART_ENABLED_PARITY)
 8000ea2:	687b      	ldr	r3, [r7, #4]
 8000ea4:	795b      	ldrb	r3, [r3, #5]
 8000ea6:	2b01      	cmp	r3, #1
 8000ea8:	d108      	bne.n	8000ebc <MCAL_USART_Init+0xfc>
		SET_BIT(USART_Config->USARTx->CR1, 10);    // Enable Parity
 8000eaa:	687b      	ldr	r3, [r7, #4]
 8000eac:	681b      	ldr	r3, [r3, #0]
 8000eae:	68da      	ldr	r2, [r3, #12]
 8000eb0:	687b      	ldr	r3, [r7, #4]
 8000eb2:	681b      	ldr	r3, [r3, #0]
 8000eb4:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8000eb8:	60da      	str	r2, [r3, #12]
 8000eba:	e007      	b.n	8000ecc <MCAL_USART_Init+0x10c>
	else
		CLEAR_BIT(USART_Config->USARTx->CR1, 10);  // Disable Parity
 8000ebc:	687b      	ldr	r3, [r7, #4]
 8000ebe:	681b      	ldr	r3, [r3, #0]
 8000ec0:	68da      	ldr	r2, [r3, #12]
 8000ec2:	687b      	ldr	r3, [r7, #4]
 8000ec4:	681b      	ldr	r3, [r3, #0]
 8000ec6:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8000eca:	60da      	str	r2, [r3, #12]

	// Enable/Disable Hardware Flow Control (CTS, RTS)
	if(USART_Config->CTS_CTRL == USART_CTS_ENABLED)
 8000ecc:	687b      	ldr	r3, [r7, #4]
 8000ece:	7b1b      	ldrb	r3, [r3, #12]
 8000ed0:	2b01      	cmp	r3, #1
 8000ed2:	d107      	bne.n	8000ee4 <MCAL_USART_Init+0x124>
		SET_BIT(USART_Config->USARTx->CR3, 9);    // Enable CTS Pin
 8000ed4:	687b      	ldr	r3, [r7, #4]
 8000ed6:	681b      	ldr	r3, [r3, #0]
 8000ed8:	695a      	ldr	r2, [r3, #20]
 8000eda:	687b      	ldr	r3, [r7, #4]
 8000edc:	681b      	ldr	r3, [r3, #0]
 8000ede:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8000ee2:	615a      	str	r2, [r3, #20]
	if(USART_Config->RTS_CTRL == USART_RTS_ENABLED)
 8000ee4:	687b      	ldr	r3, [r7, #4]
 8000ee6:	7b5b      	ldrb	r3, [r3, #13]
 8000ee8:	2b01      	cmp	r3, #1
 8000eea:	d107      	bne.n	8000efc <MCAL_USART_Init+0x13c>
		SET_BIT(USART_Config->USARTx->CR3, 8);  // Enable RTS Pin
 8000eec:	687b      	ldr	r3, [r7, #4]
 8000eee:	681b      	ldr	r3, [r3, #0]
 8000ef0:	695a      	ldr	r2, [r3, #20]
 8000ef2:	687b      	ldr	r3, [r7, #4]
 8000ef4:	681b      	ldr	r3, [r3, #0]
 8000ef6:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8000efa:	615a      	str	r2, [r3, #20]

	// Configure the number of stop bits
	USART_Config->USARTx->CR2 |= (USART_Config->stopBits << 12);
 8000efc:	687b      	ldr	r3, [r7, #4]
 8000efe:	681b      	ldr	r3, [r3, #0]
 8000f00:	691a      	ldr	r2, [r3, #16]
 8000f02:	687b      	ldr	r3, [r7, #4]
 8000f04:	79db      	ldrb	r3, [r3, #7]
 8000f06:	031b      	lsls	r3, r3, #12
 8000f08:	4619      	mov	r1, r3
 8000f0a:	687b      	ldr	r3, [r7, #4]
 8000f0c:	681b      	ldr	r3, [r3, #0]
 8000f0e:	430a      	orrs	r2, r1
 8000f10:	611a      	str	r2, [r3, #16]

	// Configure the BaudRate
	MCAL_USART_SetBaudRate(USART_Config, F_CLK);
 8000f12:	68f9      	ldr	r1, [r7, #12]
 8000f14:	6878      	ldr	r0, [r7, #4]
 8000f16:	f7ff fe4b 	bl	8000bb0 <MCAL_USART_SetBaudRate>

	// Enable/Disable Interrupt
	if((USART_Config->Tx_Interrupt_Enable == USART_TX_INTERRUPT_ENABLED) || (USART_Config->Rx_Interrupt_Enable == USART_RX_INTERRUPT_ENABLED)){
 8000f1a:	687b      	ldr	r3, [r7, #4]
 8000f1c:	7a9b      	ldrb	r3, [r3, #10]
 8000f1e:	2b01      	cmp	r3, #1
 8000f20:	d003      	beq.n	8000f2a <MCAL_USART_Init+0x16a>
 8000f22:	687b      	ldr	r3, [r7, #4]
 8000f24:	7adb      	ldrb	r3, [r3, #11]
 8000f26:	2b01      	cmp	r3, #1
 8000f28:	d13a      	bne.n	8000fa0 <MCAL_USART_Init+0x1e0>
		// Enable NVIC for USARTx IRQ
		if(USART_Config->USARTx == USART1){
 8000f2a:	687b      	ldr	r3, [r7, #4]
 8000f2c:	681b      	ldr	r3, [r3, #0]
 8000f2e:	4a1e      	ldr	r2, [pc, #120]	; (8000fa8 <MCAL_USART_Init+0x1e8>)
 8000f30:	4293      	cmp	r3, r2
 8000f32:	d106      	bne.n	8000f42 <MCAL_USART_Init+0x182>
			NVIC_IRQ_ENABLE(USART1_IRQ);
 8000f34:	4b21      	ldr	r3, [pc, #132]	; (8000fbc <MCAL_USART_Init+0x1fc>)
 8000f36:	681b      	ldr	r3, [r3, #0]
 8000f38:	4a20      	ldr	r2, [pc, #128]	; (8000fbc <MCAL_USART_Init+0x1fc>)
 8000f3a:	f043 0320 	orr.w	r3, r3, #32
 8000f3e:	6013      	str	r3, [r2, #0]
 8000f40:	e016      	b.n	8000f70 <MCAL_USART_Init+0x1b0>
		}
		else if(USART_Config->USARTx == USART2){
 8000f42:	687b      	ldr	r3, [r7, #4]
 8000f44:	681b      	ldr	r3, [r3, #0]
 8000f46:	4a1b      	ldr	r2, [pc, #108]	; (8000fb4 <MCAL_USART_Init+0x1f4>)
 8000f48:	4293      	cmp	r3, r2
 8000f4a:	d106      	bne.n	8000f5a <MCAL_USART_Init+0x19a>
			NVIC_IRQ_ENABLE(USART2_IRQ);
 8000f4c:	4b1b      	ldr	r3, [pc, #108]	; (8000fbc <MCAL_USART_Init+0x1fc>)
 8000f4e:	681b      	ldr	r3, [r3, #0]
 8000f50:	4a1a      	ldr	r2, [pc, #104]	; (8000fbc <MCAL_USART_Init+0x1fc>)
 8000f52:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8000f56:	6013      	str	r3, [r2, #0]
 8000f58:	e00a      	b.n	8000f70 <MCAL_USART_Init+0x1b0>
		}
		else if(USART_Config->USARTx == USART3){
 8000f5a:	687b      	ldr	r3, [r7, #4]
 8000f5c:	681b      	ldr	r3, [r3, #0]
 8000f5e:	4a16      	ldr	r2, [pc, #88]	; (8000fb8 <MCAL_USART_Init+0x1f8>)
 8000f60:	4293      	cmp	r3, r2
 8000f62:	d105      	bne.n	8000f70 <MCAL_USART_Init+0x1b0>
			NVIC_IRQ_ENABLE(USART3_IRQ);
 8000f64:	4b15      	ldr	r3, [pc, #84]	; (8000fbc <MCAL_USART_Init+0x1fc>)
 8000f66:	681b      	ldr	r3, [r3, #0]
 8000f68:	4a14      	ldr	r2, [pc, #80]	; (8000fbc <MCAL_USART_Init+0x1fc>)
 8000f6a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8000f6e:	6013      	str	r3, [r2, #0]
		}

		// Enable Tx/Rx Interrupt Based on configuration
		if(USART_Config->Tx_Interrupt_Enable == USART_TX_INTERRUPT_ENABLED)
 8000f70:	687b      	ldr	r3, [r7, #4]
 8000f72:	7a9b      	ldrb	r3, [r3, #10]
 8000f74:	2b01      	cmp	r3, #1
 8000f76:	d107      	bne.n	8000f88 <MCAL_USART_Init+0x1c8>
			SET_BIT(USART_Config->USARTx->CR1, 6);    // TCIE: Transmission complete interrupt enable
 8000f78:	687b      	ldr	r3, [r7, #4]
 8000f7a:	681b      	ldr	r3, [r3, #0]
 8000f7c:	68da      	ldr	r2, [r3, #12]
 8000f7e:	687b      	ldr	r3, [r7, #4]
 8000f80:	681b      	ldr	r3, [r3, #0]
 8000f82:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8000f86:	60da      	str	r2, [r3, #12]
		if(USART_Config->Rx_Interrupt_Enable == USART_RX_INTERRUPT_ENABLED)
 8000f88:	687b      	ldr	r3, [r7, #4]
 8000f8a:	7adb      	ldrb	r3, [r3, #11]
 8000f8c:	2b01      	cmp	r3, #1
 8000f8e:	d107      	bne.n	8000fa0 <MCAL_USART_Init+0x1e0>
			SET_BIT(USART_Config->USARTx->CR1, 5);    // Bit 5 RXNEIE: RXNE interrupt enable
 8000f90:	687b      	ldr	r3, [r7, #4]
 8000f92:	681b      	ldr	r3, [r3, #0]
 8000f94:	68da      	ldr	r2, [r3, #12]
 8000f96:	687b      	ldr	r3, [r7, #4]
 8000f98:	681b      	ldr	r3, [r3, #0]
 8000f9a:	f042 0220 	orr.w	r2, r2, #32
 8000f9e:	60da      	str	r2, [r3, #12]
	}
}
 8000fa0:	bf00      	nop
 8000fa2:	3710      	adds	r7, #16
 8000fa4:	46bd      	mov	sp, r7
 8000fa6:	bd80      	pop	{r7, pc}
 8000fa8:	40013800 	.word	0x40013800
 8000fac:	40021000 	.word	0x40021000
 8000fb0:	20000098 	.word	0x20000098
 8000fb4:	40004400 	.word	0x40004400
 8000fb8:	40004800 	.word	0x40004800
 8000fbc:	e000e104 	.word	0xe000e104

08000fc0 <MCAL_USART_TransmitByte>:
 *
 * @Retval      None
 *
 * @Note        Ensure that the USART peripheral is initialized before calling this function.
 */
void MCAL_USART_TransmitByte(USART_Config_t *USART_Config, uint16 data){
 8000fc0:	b580      	push	{r7, lr}
 8000fc2:	b082      	sub	sp, #8
 8000fc4:	af00      	add	r7, sp, #0
 8000fc6:	6078      	str	r0, [r7, #4]
 8000fc8:	460b      	mov	r3, r1
 8000fca:	807b      	strh	r3, [r7, #2]
	// Wait until the Transmit Data Register (TXE) is empty
	while (!(READ_BIT(USART_Config->USARTx->SR, 7)));
 8000fcc:	bf00      	nop
 8000fce:	687b      	ldr	r3, [r7, #4]
 8000fd0:	681b      	ldr	r3, [r3, #0]
 8000fd2:	681b      	ldr	r3, [r3, #0]
 8000fd4:	09db      	lsrs	r3, r3, #7
 8000fd6:	f003 0301 	and.w	r3, r3, #1
 8000fda:	2b00      	cmp	r3, #0
 8000fdc:	d0f7      	beq.n	8000fce <MCAL_USART_TransmitByte+0xe>

	// Load the data into the Data Register (DR) to start transmission
	USART_Config->USARTx->DR = data;
 8000fde:	687b      	ldr	r3, [r7, #4]
 8000fe0:	681b      	ldr	r3, [r3, #0]
 8000fe2:	887a      	ldrh	r2, [r7, #2]
 8000fe4:	605a      	str	r2, [r3, #4]

	// Optionally wait for Transmission Complete (TC) if required
	// (e.g., if this is the last byte of the transmission)
	MCAL_USART_WaitForTc(USART_Config);
 8000fe6:	6878      	ldr	r0, [r7, #4]
 8000fe8:	f7ff fdd0 	bl	8000b8c <MCAL_USART_WaitForTc>
}
 8000fec:	bf00      	nop
 8000fee:	3708      	adds	r7, #8
 8000ff0:	46bd      	mov	sp, r7
 8000ff2:	bd80      	pop	{r7, pc}

08000ff4 <USART1_IRQHandler>:

/* ================================================================ */
/* ============================= ISR ============================== */
/* ================================================================ */

void USART1_IRQHandler(void){
 8000ff4:	b580      	push	{r7, lr}
 8000ff6:	af00      	add	r7, sp, #0
	Global_USART_Config[0]->USARTx_CallBackFunction();
 8000ff8:	4b02      	ldr	r3, [pc, #8]	; (8001004 <USART1_IRQHandler+0x10>)
 8000ffa:	681b      	ldr	r3, [r3, #0]
 8000ffc:	695b      	ldr	r3, [r3, #20]
 8000ffe:	4798      	blx	r3
}
 8001000:	bf00      	nop
 8001002:	bd80      	pop	{r7, pc}
 8001004:	20000098 	.word	0x20000098

08001008 <USART2_IRQHandler>:

void USART2_IRQHandler(void){
 8001008:	b580      	push	{r7, lr}
 800100a:	af00      	add	r7, sp, #0
	Global_USART_Config[1]->USARTx_CallBackFunction();
 800100c:	4b02      	ldr	r3, [pc, #8]	; (8001018 <USART2_IRQHandler+0x10>)
 800100e:	685b      	ldr	r3, [r3, #4]
 8001010:	695b      	ldr	r3, [r3, #20]
 8001012:	4798      	blx	r3
}
 8001014:	bf00      	nop
 8001016:	bd80      	pop	{r7, pc}
 8001018:	20000098 	.word	0x20000098

0800101c <USART3_IRQHandler>:

void USART3_IRQHandler(void){
 800101c:	b580      	push	{r7, lr}
 800101e:	af00      	add	r7, sp, #0
	Global_USART_Config[2]->USARTx_CallBackFunction();
 8001020:	4b02      	ldr	r3, [pc, #8]	; (800102c <USART3_IRQHandler+0x10>)
 8001022:	689b      	ldr	r3, [r3, #8]
 8001024:	695b      	ldr	r3, [r3, #20]
 8001026:	4798      	blx	r3
}
 8001028:	bf00      	nop
 800102a:	bd80      	pop	{r7, pc}
 800102c:	20000098 	.word	0x20000098

08001030 <main>:

};
#endif

int main(void)
{
 8001030:	b580      	push	{r7, lr}
 8001032:	af00      	add	r7, sp, #0


	// Initializing the clock
	clock_Init();
 8001034:	f000 f80c 	bl	8001050 <clock_Init>
	MCAL_GPIO_Init(GPIOA, &PA4_Pin);
	// Set the logic of PA4 to HIGH
	MCAL_GPIO_WritePin(GPIOA, GPIO_PIN4, GPIO_HIGH);
	#endif
	// Initializing USART1
	MCAL_USART_Init(&UART1_Config);
 8001038:	4803      	ldr	r0, [pc, #12]	; (8001048 <main+0x18>)
 800103a:	f7ff fec1 	bl	8000dc0 <MCAL_USART_Init>
	// Initializing SPI1
	MCAL_SPI_Init(&SPI1_Config);
 800103e:	4803      	ldr	r0, [pc, #12]	; (800104c <main+0x1c>)
 8001040:	f7ff fc50 	bl	80008e4 <MCAL_SPI_Init>


	while(1)
 8001044:	e7fe      	b.n	8001044 <main+0x14>
 8001046:	bf00      	nop
 8001048:	20000000 	.word	0x20000000
 800104c:	20000018 	.word	0x20000018

08001050 <clock_Init>:
	{

	}
}

void clock_Init(){
 8001050:	b480      	push	{r7}
 8001052:	af00      	add	r7, sp, #0
	GPIOA_CLK_EN(); // IO port A clock enabled
 8001054:	4b0a      	ldr	r3, [pc, #40]	; (8001080 <clock_Init+0x30>)
 8001056:	699b      	ldr	r3, [r3, #24]
 8001058:	4a09      	ldr	r2, [pc, #36]	; (8001080 <clock_Init+0x30>)
 800105a:	f043 0304 	orr.w	r3, r3, #4
 800105e:	6193      	str	r3, [r2, #24]
	GPIOB_CLK_EN(); // IO port B clock enabled
 8001060:	4b07      	ldr	r3, [pc, #28]	; (8001080 <clock_Init+0x30>)
 8001062:	699b      	ldr	r3, [r3, #24]
 8001064:	4a06      	ldr	r2, [pc, #24]	; (8001080 <clock_Init+0x30>)
 8001066:	f043 0308 	orr.w	r3, r3, #8
 800106a:	6193      	str	r3, [r2, #24]
	AFIO_CLK_EN();  // AFIO cock enabled
 800106c:	4b04      	ldr	r3, [pc, #16]	; (8001080 <clock_Init+0x30>)
 800106e:	699b      	ldr	r3, [r3, #24]
 8001070:	4a03      	ldr	r2, [pc, #12]	; (8001080 <clock_Init+0x30>)
 8001072:	f043 0301 	orr.w	r3, r3, #1
 8001076:	6193      	str	r3, [r2, #24]
}
 8001078:	bf00      	nop
 800107a:	46bd      	mov	sp, r7
 800107c:	bc80      	pop	{r7}
 800107e:	4770      	bx	lr
 8001080:	40021000 	.word	0x40021000

08001084 <MyUSART1_IRQHandler>:

void MyUSART1_IRQHandler(void)
{
 8001084:	b480      	push	{r7}
 8001086:	af00      	add	r7, sp, #0
	MCAL_GPIO_WritePin(GPIOA, GPIO_PIN4,  GPIO_LOW);  // Chip select
	uint16 RecievedDataFromSPI = MCAL_SPI_Transmit_Recieve(&SPI1_Config, received_byte);
	// Set the logic of PA4 to LOW
	MCAL_GPIO_WritePin(GPIOA, GPIO_PIN4,  GPIO_HIGH);  // Chip select
	#endif
}
 8001088:	bf00      	nop
 800108a:	46bd      	mov	sp, r7
 800108c:	bc80      	pop	{r7}
 800108e:	4770      	bx	lr

08001090 <MySPI1_IRQHandler>:

void MySPI1_IRQHandler(void){
 8001090:	b580      	push	{r7, lr}
 8001092:	b082      	sub	sp, #8
 8001094:	af00      	add	r7, sp, #0
	#ifdef MCU_SPI_SLAVE
	uint16 RecievedDataFromSPI;
	uint16 DummyData = 0xFF;
 8001096:	23ff      	movs	r3, #255	; 0xff
 8001098:	80fb      	strh	r3, [r7, #6]
	RecievedDataFromSPI = MCAL_SPI_Transmit_Recieve(&SPI1_Config, DummyData);
 800109a:	88fb      	ldrh	r3, [r7, #6]
 800109c:	4619      	mov	r1, r3
 800109e:	4807      	ldr	r0, [pc, #28]	; (80010bc <MySPI1_IRQHandler+0x2c>)
 80010a0:	f7ff fd4a 	bl	8000b38 <MCAL_SPI_Transmit_Recieve>
 80010a4:	4603      	mov	r3, r0
 80010a6:	80bb      	strh	r3, [r7, #4]
	// Transmit Recieved Data From SPI to USART
	MCAL_USART_TransmitByte(&UART1_Config, RecievedDataFromSPI);
 80010a8:	88bb      	ldrh	r3, [r7, #4]
 80010aa:	4619      	mov	r1, r3
 80010ac:	4804      	ldr	r0, [pc, #16]	; (80010c0 <MySPI1_IRQHandler+0x30>)
 80010ae:	f7ff ff87 	bl	8000fc0 <MCAL_USART_TransmitByte>
	#endif
}
 80010b2:	bf00      	nop
 80010b4:	3708      	adds	r7, #8
 80010b6:	46bd      	mov	sp, r7
 80010b8:	bd80      	pop	{r7, pc}
 80010ba:	bf00      	nop
 80010bc:	20000018 	.word	0x20000018
 80010c0:	20000000 	.word	0x20000000

080010c4 <Reset_Handler>:

  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_estack
 80010c4:	480d      	ldr	r0, [pc, #52]	; (80010fc <LoopForever+0x2>)
  mov   sp, r0          /* set stack pointer */
 80010c6:	4685      	mov	sp, r0
/* Call the clock system intitialization function.*/
  bl  SystemInit
 80010c8:	f3af 8000 	nop.w

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
 80010cc:	480c      	ldr	r0, [pc, #48]	; (8001100 <LoopForever+0x6>)
  ldr r1, =_edata
 80010ce:	490d      	ldr	r1, [pc, #52]	; (8001104 <LoopForever+0xa>)
  ldr r2, =_sidata
 80010d0:	4a0d      	ldr	r2, [pc, #52]	; (8001108 <LoopForever+0xe>)
  movs r3, #0
 80010d2:	2300      	movs	r3, #0
  b LoopCopyDataInit
 80010d4:	e002      	b.n	80010dc <LoopCopyDataInit>

080010d6 <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 80010d6:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 80010d8:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 80010da:	3304      	adds	r3, #4

080010dc <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 80010dc:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 80010de:	428c      	cmp	r4, r1
  bcc CopyDataInit
 80010e0:	d3f9      	bcc.n	80010d6 <CopyDataInit>

/* Zero fill the bss segment. */
  ldr r2, =_sbss
 80010e2:	4a0a      	ldr	r2, [pc, #40]	; (800110c <LoopForever+0x12>)
  ldr r4, =_ebss
 80010e4:	4c0a      	ldr	r4, [pc, #40]	; (8001110 <LoopForever+0x16>)
  movs r3, #0
 80010e6:	2300      	movs	r3, #0
  b LoopFillZerobss
 80010e8:	e001      	b.n	80010ee <LoopFillZerobss>

080010ea <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 80010ea:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 80010ec:	3204      	adds	r2, #4

080010ee <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 80010ee:	42a2      	cmp	r2, r4
  bcc FillZerobss
 80010f0:	d3fb      	bcc.n	80010ea <FillZerobss>

/* Call static constructors */
  bl __libc_init_array
 80010f2:	f000 f811 	bl	8001118 <__libc_init_array>
/* Call the application's entry point.*/
  bl main
 80010f6:	f7ff ff9b 	bl	8001030 <main>

080010fa <LoopForever>:

LoopForever:
    b LoopForever
 80010fa:	e7fe      	b.n	80010fa <LoopForever>
  ldr   r0, =_estack
 80010fc:	20002800 	.word	0x20002800
  ldr r0, =_sdata
 8001100:	20000000 	.word	0x20000000
  ldr r1, =_edata
 8001104:	20000034 	.word	0x20000034
  ldr r2, =_sidata
 8001108:	080011e0 	.word	0x080011e0
  ldr r2, =_sbss
 800110c:	20000034 	.word	0x20000034
  ldr r4, =_ebss
 8001110:	200000a4 	.word	0x200000a4

08001114 <ADC1_2_IRQHandler>:
 * @retval : None
*/
  .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
 8001114:	e7fe      	b.n	8001114 <ADC1_2_IRQHandler>
	...

08001118 <__libc_init_array>:
 8001118:	b570      	push	{r4, r5, r6, lr}
 800111a:	2500      	movs	r5, #0
 800111c:	4e0c      	ldr	r6, [pc, #48]	; (8001150 <__libc_init_array+0x38>)
 800111e:	4c0d      	ldr	r4, [pc, #52]	; (8001154 <__libc_init_array+0x3c>)
 8001120:	1ba4      	subs	r4, r4, r6
 8001122:	10a4      	asrs	r4, r4, #2
 8001124:	42a5      	cmp	r5, r4
 8001126:	d109      	bne.n	800113c <__libc_init_array+0x24>
 8001128:	f000 f81a 	bl	8001160 <_init>
 800112c:	2500      	movs	r5, #0
 800112e:	4e0a      	ldr	r6, [pc, #40]	; (8001158 <__libc_init_array+0x40>)
 8001130:	4c0a      	ldr	r4, [pc, #40]	; (800115c <__libc_init_array+0x44>)
 8001132:	1ba4      	subs	r4, r4, r6
 8001134:	10a4      	asrs	r4, r4, #2
 8001136:	42a5      	cmp	r5, r4
 8001138:	d105      	bne.n	8001146 <__libc_init_array+0x2e>
 800113a:	bd70      	pop	{r4, r5, r6, pc}
 800113c:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 8001140:	4798      	blx	r3
 8001142:	3501      	adds	r5, #1
 8001144:	e7ee      	b.n	8001124 <__libc_init_array+0xc>
 8001146:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 800114a:	4798      	blx	r3
 800114c:	3501      	adds	r5, #1
 800114e:	e7f2      	b.n	8001136 <__libc_init_array+0x1e>
 8001150:	080011d8 	.word	0x080011d8
 8001154:	080011d8 	.word	0x080011d8
 8001158:	080011d8 	.word	0x080011d8
 800115c:	080011dc 	.word	0x080011dc

08001160 <_init>:
 8001160:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001162:	bf00      	nop
 8001164:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8001166:	bc08      	pop	{r3}
 8001168:	469e      	mov	lr, r3
 800116a:	4770      	bx	lr

0800116c <_fini>:
 800116c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800116e:	bf00      	nop
 8001170:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8001172:	bc08      	pop	{r3}
 8001174:	469e      	mov	lr, r3
 8001176:	4770      	bx	lr
