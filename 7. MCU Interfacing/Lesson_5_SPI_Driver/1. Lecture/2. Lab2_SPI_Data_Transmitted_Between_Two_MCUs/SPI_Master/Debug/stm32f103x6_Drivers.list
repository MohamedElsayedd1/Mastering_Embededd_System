
stm32f103x6_Drivers.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000130  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00001060  08000130  08000130  00010130  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000060  08001190  08001190  00011190  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  080011f0  080011f0  00020038  2**0
                  CONTENTS
  4 .ARM          00000000  080011f0  080011f0  00020038  2**0
                  CONTENTS
  5 .preinit_array 00000000  080011f0  080011f0  00020038  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  080011f0  080011f0  000111f0  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000004  080011f4  080011f4  000111f4  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         00000038  20000000  080011f8  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          00000070  20000038  08001230  00020038  2**2
                  ALLOC
 10 ._user_heap_stack 00000600  200000a8  08001230  000200a8  2**0
                  ALLOC
 11 .ARM.attributes 00000029  00000000  00000000  00020038  2**0
                  CONTENTS, READONLY
 12 .debug_info   000029bc  00000000  00000000  00020061  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_abbrev 000007e6  00000000  00000000  00022a1d  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_loc    00000eb0  00000000  00000000  00023203  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_aranges 00000248  00000000  00000000  000240b8  2**3
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_ranges 000001e0  00000000  00000000  00024300  2**3
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_macro  00000296  00000000  00000000  000244e0  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_line   000010b2  00000000  00000000  00024776  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_str    00004eb6  00000000  00000000  00025828  2**0
                  CONTENTS, READONLY, DEBUGGING
 20 .comment      0000007b  00000000  00000000  0002a6de  2**0
                  CONTENTS, READONLY
 21 .debug_frame  0000077c  00000000  00000000  0002a75c  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

08000130 <__do_global_dtors_aux>:
 8000130:	b510      	push	{r4, lr}
 8000132:	4c05      	ldr	r4, [pc, #20]	; (8000148 <__do_global_dtors_aux+0x18>)
 8000134:	7823      	ldrb	r3, [r4, #0]
 8000136:	b933      	cbnz	r3, 8000146 <__do_global_dtors_aux+0x16>
 8000138:	4b04      	ldr	r3, [pc, #16]	; (800014c <__do_global_dtors_aux+0x1c>)
 800013a:	b113      	cbz	r3, 8000142 <__do_global_dtors_aux+0x12>
 800013c:	4804      	ldr	r0, [pc, #16]	; (8000150 <__do_global_dtors_aux+0x20>)
 800013e:	f3af 8000 	nop.w
 8000142:	2301      	movs	r3, #1
 8000144:	7023      	strb	r3, [r4, #0]
 8000146:	bd10      	pop	{r4, pc}
 8000148:	20000038 	.word	0x20000038
 800014c:	00000000 	.word	0x00000000
 8000150:	08001178 	.word	0x08001178

08000154 <frame_dummy>:
 8000154:	b508      	push	{r3, lr}
 8000156:	4b03      	ldr	r3, [pc, #12]	; (8000164 <frame_dummy+0x10>)
 8000158:	b11b      	cbz	r3, 8000162 <frame_dummy+0xe>
 800015a:	4903      	ldr	r1, [pc, #12]	; (8000168 <frame_dummy+0x14>)
 800015c:	4803      	ldr	r0, [pc, #12]	; (800016c <frame_dummy+0x18>)
 800015e:	f3af 8000 	nop.w
 8000162:	bd08      	pop	{r3, pc}
 8000164:	00000000 	.word	0x00000000
 8000168:	2000003c 	.word	0x2000003c
 800016c:	08001178 	.word	0x08001178

08000170 <EXTI0_IRQHandler>:

/* ================================================================ */
/* ========================= ISR Functions ======================== */
/* ================================================================ */

void EXTI0_IRQHandler(void){
 8000170:	b580      	push	{r7, lr}
 8000172:	af00      	add	r7, sp, #0
	// This bit is cleared by writing a ‘1’ into the bit
	SET_BIT(EXTI->PR, 0);
 8000174:	4b07      	ldr	r3, [pc, #28]	; (8000194 <EXTI0_IRQHandler+0x24>)
 8000176:	695b      	ldr	r3, [r3, #20]
 8000178:	4a06      	ldr	r2, [pc, #24]	; (8000194 <EXTI0_IRQHandler+0x24>)
 800017a:	f043 0301 	orr.w	r3, r3, #1
 800017e:	6153      	str	r3, [r2, #20]
	// Call IRQ Call Back Function
	if (EXTI_CallBacks[0] != NULL) {
 8000180:	4b05      	ldr	r3, [pc, #20]	; (8000198 <EXTI0_IRQHandler+0x28>)
 8000182:	681b      	ldr	r3, [r3, #0]
 8000184:	2b00      	cmp	r3, #0
 8000186:	d002      	beq.n	800018e <EXTI0_IRQHandler+0x1e>
		EXTI_CallBacks[0]();
 8000188:	4b03      	ldr	r3, [pc, #12]	; (8000198 <EXTI0_IRQHandler+0x28>)
 800018a:	681b      	ldr	r3, [r3, #0]
 800018c:	4798      	blx	r3
	}
}
 800018e:	bf00      	nop
 8000190:	bd80      	pop	{r7, pc}
 8000192:	bf00      	nop
 8000194:	40010400 	.word	0x40010400
 8000198:	20000054 	.word	0x20000054

0800019c <EXTI1_IRQHandler>:

void EXTI1_IRQHandler(void){
 800019c:	b580      	push	{r7, lr}
 800019e:	af00      	add	r7, sp, #0
	// This bit is cleared by writing a ‘1’ into the bit
	SET_BIT(EXTI->PR, 1);
 80001a0:	4b07      	ldr	r3, [pc, #28]	; (80001c0 <EXTI1_IRQHandler+0x24>)
 80001a2:	695b      	ldr	r3, [r3, #20]
 80001a4:	4a06      	ldr	r2, [pc, #24]	; (80001c0 <EXTI1_IRQHandler+0x24>)
 80001a6:	f043 0302 	orr.w	r3, r3, #2
 80001aa:	6153      	str	r3, [r2, #20]
	// Call IRQ Call Back Function
	if (EXTI_CallBacks[1] != NULL) {
 80001ac:	4b05      	ldr	r3, [pc, #20]	; (80001c4 <EXTI1_IRQHandler+0x28>)
 80001ae:	685b      	ldr	r3, [r3, #4]
 80001b0:	2b00      	cmp	r3, #0
 80001b2:	d002      	beq.n	80001ba <EXTI1_IRQHandler+0x1e>
		EXTI_CallBacks[1]();
 80001b4:	4b03      	ldr	r3, [pc, #12]	; (80001c4 <EXTI1_IRQHandler+0x28>)
 80001b6:	685b      	ldr	r3, [r3, #4]
 80001b8:	4798      	blx	r3
	}
}
 80001ba:	bf00      	nop
 80001bc:	bd80      	pop	{r7, pc}
 80001be:	bf00      	nop
 80001c0:	40010400 	.word	0x40010400
 80001c4:	20000054 	.word	0x20000054

080001c8 <EXTI2_IRQHandler>:

void EXTI2_IRQHandler(void){
 80001c8:	b580      	push	{r7, lr}
 80001ca:	af00      	add	r7, sp, #0
	// This bit is cleared by writing a ‘1’ into the bit
	SET_BIT(EXTI->PR, 2);
 80001cc:	4b07      	ldr	r3, [pc, #28]	; (80001ec <EXTI2_IRQHandler+0x24>)
 80001ce:	695b      	ldr	r3, [r3, #20]
 80001d0:	4a06      	ldr	r2, [pc, #24]	; (80001ec <EXTI2_IRQHandler+0x24>)
 80001d2:	f043 0304 	orr.w	r3, r3, #4
 80001d6:	6153      	str	r3, [r2, #20]
	// Call IRQ Call Back Function
	if (EXTI_CallBacks[2] != NULL) {
 80001d8:	4b05      	ldr	r3, [pc, #20]	; (80001f0 <EXTI2_IRQHandler+0x28>)
 80001da:	689b      	ldr	r3, [r3, #8]
 80001dc:	2b00      	cmp	r3, #0
 80001de:	d002      	beq.n	80001e6 <EXTI2_IRQHandler+0x1e>
		EXTI_CallBacks[2]();
 80001e0:	4b03      	ldr	r3, [pc, #12]	; (80001f0 <EXTI2_IRQHandler+0x28>)
 80001e2:	689b      	ldr	r3, [r3, #8]
 80001e4:	4798      	blx	r3
	}
}
 80001e6:	bf00      	nop
 80001e8:	bd80      	pop	{r7, pc}
 80001ea:	bf00      	nop
 80001ec:	40010400 	.word	0x40010400
 80001f0:	20000054 	.word	0x20000054

080001f4 <EXTI3_IRQHandler>:

void EXTI3_IRQHandler(void){
 80001f4:	b580      	push	{r7, lr}
 80001f6:	af00      	add	r7, sp, #0
	// This bit is cleared by writing a ‘1’ into the bit
	SET_BIT(EXTI->PR, 3);
 80001f8:	4b07      	ldr	r3, [pc, #28]	; (8000218 <EXTI3_IRQHandler+0x24>)
 80001fa:	695b      	ldr	r3, [r3, #20]
 80001fc:	4a06      	ldr	r2, [pc, #24]	; (8000218 <EXTI3_IRQHandler+0x24>)
 80001fe:	f043 0308 	orr.w	r3, r3, #8
 8000202:	6153      	str	r3, [r2, #20]
	// Call IRQ Call Back Function
	if (EXTI_CallBacks[3] != NULL) {
 8000204:	4b05      	ldr	r3, [pc, #20]	; (800021c <EXTI3_IRQHandler+0x28>)
 8000206:	68db      	ldr	r3, [r3, #12]
 8000208:	2b00      	cmp	r3, #0
 800020a:	d002      	beq.n	8000212 <EXTI3_IRQHandler+0x1e>
		EXTI_CallBacks[3]();
 800020c:	4b03      	ldr	r3, [pc, #12]	; (800021c <EXTI3_IRQHandler+0x28>)
 800020e:	68db      	ldr	r3, [r3, #12]
 8000210:	4798      	blx	r3
	}
}
 8000212:	bf00      	nop
 8000214:	bd80      	pop	{r7, pc}
 8000216:	bf00      	nop
 8000218:	40010400 	.word	0x40010400
 800021c:	20000054 	.word	0x20000054

08000220 <EXTI4_IRQHandler>:

void EXTI4_IRQHandler(void){
 8000220:	b580      	push	{r7, lr}
 8000222:	af00      	add	r7, sp, #0
	// This bit is cleared by writing a ‘1’ into the bit
	SET_BIT(EXTI->PR, 4);
 8000224:	4b07      	ldr	r3, [pc, #28]	; (8000244 <EXTI4_IRQHandler+0x24>)
 8000226:	695b      	ldr	r3, [r3, #20]
 8000228:	4a06      	ldr	r2, [pc, #24]	; (8000244 <EXTI4_IRQHandler+0x24>)
 800022a:	f043 0310 	orr.w	r3, r3, #16
 800022e:	6153      	str	r3, [r2, #20]
	// Call IRQ Call Back Function
	if (EXTI_CallBacks[4] != NULL) {
 8000230:	4b05      	ldr	r3, [pc, #20]	; (8000248 <EXTI4_IRQHandler+0x28>)
 8000232:	691b      	ldr	r3, [r3, #16]
 8000234:	2b00      	cmp	r3, #0
 8000236:	d002      	beq.n	800023e <EXTI4_IRQHandler+0x1e>
		EXTI_CallBacks[4]();
 8000238:	4b03      	ldr	r3, [pc, #12]	; (8000248 <EXTI4_IRQHandler+0x28>)
 800023a:	691b      	ldr	r3, [r3, #16]
 800023c:	4798      	blx	r3
	}
}
 800023e:	bf00      	nop
 8000240:	bd80      	pop	{r7, pc}
 8000242:	bf00      	nop
 8000244:	40010400 	.word	0x40010400
 8000248:	20000054 	.word	0x20000054

0800024c <EXTI9_5_IRQHandler>:

void EXTI9_5_IRQHandler(void){
 800024c:	b580      	push	{r7, lr}
 800024e:	af00      	add	r7, sp, #0
	if(EXTI_INTERRUPET_TRIGGERED == READ_BIT(EXTI->PR, 5)){
 8000250:	4b34      	ldr	r3, [pc, #208]	; (8000324 <EXTI9_5_IRQHandler+0xd8>)
 8000252:	695b      	ldr	r3, [r3, #20]
 8000254:	095b      	lsrs	r3, r3, #5
 8000256:	f003 0301 	and.w	r3, r3, #1
 800025a:	2b01      	cmp	r3, #1
 800025c:	d10d      	bne.n	800027a <EXTI9_5_IRQHandler+0x2e>
		// This bit is cleared by writing a ‘1’ into the bit
		SET_BIT(EXTI->PR, 5);
 800025e:	4b31      	ldr	r3, [pc, #196]	; (8000324 <EXTI9_5_IRQHandler+0xd8>)
 8000260:	695b      	ldr	r3, [r3, #20]
 8000262:	4a30      	ldr	r2, [pc, #192]	; (8000324 <EXTI9_5_IRQHandler+0xd8>)
 8000264:	f043 0320 	orr.w	r3, r3, #32
 8000268:	6153      	str	r3, [r2, #20]
		// Call IRQ Call Back Function
		if (EXTI_CallBacks[5] != NULL) {
 800026a:	4b2f      	ldr	r3, [pc, #188]	; (8000328 <EXTI9_5_IRQHandler+0xdc>)
 800026c:	695b      	ldr	r3, [r3, #20]
 800026e:	2b00      	cmp	r3, #0
 8000270:	d056      	beq.n	8000320 <EXTI9_5_IRQHandler+0xd4>
			EXTI_CallBacks[5]();
 8000272:	4b2d      	ldr	r3, [pc, #180]	; (8000328 <EXTI9_5_IRQHandler+0xdc>)
 8000274:	695b      	ldr	r3, [r3, #20]
 8000276:	4798      	blx	r3
		// Call IRQ Call Back Function
		if (EXTI_CallBacks[9] != NULL) {
			EXTI_CallBacks[9]();
		}
	}
}
 8000278:	e052      	b.n	8000320 <EXTI9_5_IRQHandler+0xd4>
	else if(EXTI_INTERRUPET_TRIGGERED == READ_BIT(EXTI->PR, 6)){
 800027a:	4b2a      	ldr	r3, [pc, #168]	; (8000324 <EXTI9_5_IRQHandler+0xd8>)
 800027c:	695b      	ldr	r3, [r3, #20]
 800027e:	099b      	lsrs	r3, r3, #6
 8000280:	f003 0301 	and.w	r3, r3, #1
 8000284:	2b01      	cmp	r3, #1
 8000286:	d10d      	bne.n	80002a4 <EXTI9_5_IRQHandler+0x58>
		SET_BIT(EXTI->PR, 6);
 8000288:	4b26      	ldr	r3, [pc, #152]	; (8000324 <EXTI9_5_IRQHandler+0xd8>)
 800028a:	695b      	ldr	r3, [r3, #20]
 800028c:	4a25      	ldr	r2, [pc, #148]	; (8000324 <EXTI9_5_IRQHandler+0xd8>)
 800028e:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8000292:	6153      	str	r3, [r2, #20]
		if (EXTI_CallBacks[6] != NULL) {
 8000294:	4b24      	ldr	r3, [pc, #144]	; (8000328 <EXTI9_5_IRQHandler+0xdc>)
 8000296:	699b      	ldr	r3, [r3, #24]
 8000298:	2b00      	cmp	r3, #0
 800029a:	d041      	beq.n	8000320 <EXTI9_5_IRQHandler+0xd4>
			EXTI_CallBacks[6]();
 800029c:	4b22      	ldr	r3, [pc, #136]	; (8000328 <EXTI9_5_IRQHandler+0xdc>)
 800029e:	699b      	ldr	r3, [r3, #24]
 80002a0:	4798      	blx	r3
}
 80002a2:	e03d      	b.n	8000320 <EXTI9_5_IRQHandler+0xd4>
	else if(EXTI_INTERRUPET_TRIGGERED == READ_BIT(EXTI->PR, 7)){
 80002a4:	4b1f      	ldr	r3, [pc, #124]	; (8000324 <EXTI9_5_IRQHandler+0xd8>)
 80002a6:	695b      	ldr	r3, [r3, #20]
 80002a8:	09db      	lsrs	r3, r3, #7
 80002aa:	f003 0301 	and.w	r3, r3, #1
 80002ae:	2b01      	cmp	r3, #1
 80002b0:	d10d      	bne.n	80002ce <EXTI9_5_IRQHandler+0x82>
		SET_BIT(EXTI->PR, 7);
 80002b2:	4b1c      	ldr	r3, [pc, #112]	; (8000324 <EXTI9_5_IRQHandler+0xd8>)
 80002b4:	695b      	ldr	r3, [r3, #20]
 80002b6:	4a1b      	ldr	r2, [pc, #108]	; (8000324 <EXTI9_5_IRQHandler+0xd8>)
 80002b8:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80002bc:	6153      	str	r3, [r2, #20]
		if (EXTI_CallBacks[7] != NULL) {
 80002be:	4b1a      	ldr	r3, [pc, #104]	; (8000328 <EXTI9_5_IRQHandler+0xdc>)
 80002c0:	69db      	ldr	r3, [r3, #28]
 80002c2:	2b00      	cmp	r3, #0
 80002c4:	d02c      	beq.n	8000320 <EXTI9_5_IRQHandler+0xd4>
			EXTI_CallBacks[7]();
 80002c6:	4b18      	ldr	r3, [pc, #96]	; (8000328 <EXTI9_5_IRQHandler+0xdc>)
 80002c8:	69db      	ldr	r3, [r3, #28]
 80002ca:	4798      	blx	r3
}
 80002cc:	e028      	b.n	8000320 <EXTI9_5_IRQHandler+0xd4>
	else if(EXTI_INTERRUPET_TRIGGERED == READ_BIT(EXTI->PR, 8)){
 80002ce:	4b15      	ldr	r3, [pc, #84]	; (8000324 <EXTI9_5_IRQHandler+0xd8>)
 80002d0:	695b      	ldr	r3, [r3, #20]
 80002d2:	0a1b      	lsrs	r3, r3, #8
 80002d4:	f003 0301 	and.w	r3, r3, #1
 80002d8:	2b01      	cmp	r3, #1
 80002da:	d10d      	bne.n	80002f8 <EXTI9_5_IRQHandler+0xac>
		SET_BIT(EXTI->PR, 8);
 80002dc:	4b11      	ldr	r3, [pc, #68]	; (8000324 <EXTI9_5_IRQHandler+0xd8>)
 80002de:	695b      	ldr	r3, [r3, #20]
 80002e0:	4a10      	ldr	r2, [pc, #64]	; (8000324 <EXTI9_5_IRQHandler+0xd8>)
 80002e2:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80002e6:	6153      	str	r3, [r2, #20]
		if (EXTI_CallBacks[8] != NULL) {
 80002e8:	4b0f      	ldr	r3, [pc, #60]	; (8000328 <EXTI9_5_IRQHandler+0xdc>)
 80002ea:	6a1b      	ldr	r3, [r3, #32]
 80002ec:	2b00      	cmp	r3, #0
 80002ee:	d017      	beq.n	8000320 <EXTI9_5_IRQHandler+0xd4>
			EXTI_CallBacks[8]();
 80002f0:	4b0d      	ldr	r3, [pc, #52]	; (8000328 <EXTI9_5_IRQHandler+0xdc>)
 80002f2:	6a1b      	ldr	r3, [r3, #32]
 80002f4:	4798      	blx	r3
}
 80002f6:	e013      	b.n	8000320 <EXTI9_5_IRQHandler+0xd4>
	else if(EXTI_INTERRUPET_TRIGGERED == READ_BIT(EXTI->PR, 9)){
 80002f8:	4b0a      	ldr	r3, [pc, #40]	; (8000324 <EXTI9_5_IRQHandler+0xd8>)
 80002fa:	695b      	ldr	r3, [r3, #20]
 80002fc:	0a5b      	lsrs	r3, r3, #9
 80002fe:	f003 0301 	and.w	r3, r3, #1
 8000302:	2b01      	cmp	r3, #1
 8000304:	d10c      	bne.n	8000320 <EXTI9_5_IRQHandler+0xd4>
		SET_BIT(EXTI->PR, 9);
 8000306:	4b07      	ldr	r3, [pc, #28]	; (8000324 <EXTI9_5_IRQHandler+0xd8>)
 8000308:	695b      	ldr	r3, [r3, #20]
 800030a:	4a06      	ldr	r2, [pc, #24]	; (8000324 <EXTI9_5_IRQHandler+0xd8>)
 800030c:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8000310:	6153      	str	r3, [r2, #20]
		if (EXTI_CallBacks[9] != NULL) {
 8000312:	4b05      	ldr	r3, [pc, #20]	; (8000328 <EXTI9_5_IRQHandler+0xdc>)
 8000314:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8000316:	2b00      	cmp	r3, #0
 8000318:	d002      	beq.n	8000320 <EXTI9_5_IRQHandler+0xd4>
			EXTI_CallBacks[9]();
 800031a:	4b03      	ldr	r3, [pc, #12]	; (8000328 <EXTI9_5_IRQHandler+0xdc>)
 800031c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800031e:	4798      	blx	r3
}
 8000320:	bf00      	nop
 8000322:	bd80      	pop	{r7, pc}
 8000324:	40010400 	.word	0x40010400
 8000328:	20000054 	.word	0x20000054

0800032c <EXTI15_10_IRQHandler>:

void EXTI15_10_IRQHandler(void){
 800032c:	b580      	push	{r7, lr}
 800032e:	af00      	add	r7, sp, #0
	if(EXTI_INTERRUPET_TRIGGERED == READ_BIT(EXTI->PR, 10)){
 8000330:	4b3f      	ldr	r3, [pc, #252]	; (8000430 <EXTI15_10_IRQHandler+0x104>)
 8000332:	695b      	ldr	r3, [r3, #20]
 8000334:	0a9b      	lsrs	r3, r3, #10
 8000336:	f003 0301 	and.w	r3, r3, #1
 800033a:	2b01      	cmp	r3, #1
 800033c:	d10d      	bne.n	800035a <EXTI15_10_IRQHandler+0x2e>
		// This bit is cleared by writing a ‘1’ into the bit
		SET_BIT(EXTI->PR, 10);
 800033e:	4b3c      	ldr	r3, [pc, #240]	; (8000430 <EXTI15_10_IRQHandler+0x104>)
 8000340:	695b      	ldr	r3, [r3, #20]
 8000342:	4a3b      	ldr	r2, [pc, #236]	; (8000430 <EXTI15_10_IRQHandler+0x104>)
 8000344:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8000348:	6153      	str	r3, [r2, #20]
		// Call IRQ Call Back Function
		if (EXTI_CallBacks[10] != NULL) {
 800034a:	4b3a      	ldr	r3, [pc, #232]	; (8000434 <EXTI15_10_IRQHandler+0x108>)
 800034c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800034e:	2b00      	cmp	r3, #0
 8000350:	d06b      	beq.n	800042a <EXTI15_10_IRQHandler+0xfe>
			EXTI_CallBacks[10]();
 8000352:	4b38      	ldr	r3, [pc, #224]	; (8000434 <EXTI15_10_IRQHandler+0x108>)
 8000354:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8000356:	4798      	blx	r3
		// Call IRQ Call Back Function
		if (EXTI_CallBacks[15] != NULL) {
			EXTI_CallBacks[15]();
		}
	}
}
 8000358:	e067      	b.n	800042a <EXTI15_10_IRQHandler+0xfe>
	else if(EXTI_INTERRUPET_TRIGGERED == READ_BIT(EXTI->PR, 11)){
 800035a:	4b35      	ldr	r3, [pc, #212]	; (8000430 <EXTI15_10_IRQHandler+0x104>)
 800035c:	695b      	ldr	r3, [r3, #20]
 800035e:	0adb      	lsrs	r3, r3, #11
 8000360:	f003 0301 	and.w	r3, r3, #1
 8000364:	2b01      	cmp	r3, #1
 8000366:	d10d      	bne.n	8000384 <EXTI15_10_IRQHandler+0x58>
		SET_BIT(EXTI->PR, 11);
 8000368:	4b31      	ldr	r3, [pc, #196]	; (8000430 <EXTI15_10_IRQHandler+0x104>)
 800036a:	695b      	ldr	r3, [r3, #20]
 800036c:	4a30      	ldr	r2, [pc, #192]	; (8000430 <EXTI15_10_IRQHandler+0x104>)
 800036e:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8000372:	6153      	str	r3, [r2, #20]
		if (EXTI_CallBacks[11] != NULL) {
 8000374:	4b2f      	ldr	r3, [pc, #188]	; (8000434 <EXTI15_10_IRQHandler+0x108>)
 8000376:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8000378:	2b00      	cmp	r3, #0
 800037a:	d056      	beq.n	800042a <EXTI15_10_IRQHandler+0xfe>
			EXTI_CallBacks[11]();
 800037c:	4b2d      	ldr	r3, [pc, #180]	; (8000434 <EXTI15_10_IRQHandler+0x108>)
 800037e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8000380:	4798      	blx	r3
}
 8000382:	e052      	b.n	800042a <EXTI15_10_IRQHandler+0xfe>
	else if(EXTI_INTERRUPET_TRIGGERED == READ_BIT(EXTI->PR, 12)){
 8000384:	4b2a      	ldr	r3, [pc, #168]	; (8000430 <EXTI15_10_IRQHandler+0x104>)
 8000386:	695b      	ldr	r3, [r3, #20]
 8000388:	0b1b      	lsrs	r3, r3, #12
 800038a:	f003 0301 	and.w	r3, r3, #1
 800038e:	2b01      	cmp	r3, #1
 8000390:	d10d      	bne.n	80003ae <EXTI15_10_IRQHandler+0x82>
		SET_BIT(EXTI->PR, 12);
 8000392:	4b27      	ldr	r3, [pc, #156]	; (8000430 <EXTI15_10_IRQHandler+0x104>)
 8000394:	695b      	ldr	r3, [r3, #20]
 8000396:	4a26      	ldr	r2, [pc, #152]	; (8000430 <EXTI15_10_IRQHandler+0x104>)
 8000398:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 800039c:	6153      	str	r3, [r2, #20]
		if (EXTI_CallBacks[12] != NULL) {
 800039e:	4b25      	ldr	r3, [pc, #148]	; (8000434 <EXTI15_10_IRQHandler+0x108>)
 80003a0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80003a2:	2b00      	cmp	r3, #0
 80003a4:	d041      	beq.n	800042a <EXTI15_10_IRQHandler+0xfe>
			EXTI_CallBacks[12]();
 80003a6:	4b23      	ldr	r3, [pc, #140]	; (8000434 <EXTI15_10_IRQHandler+0x108>)
 80003a8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80003aa:	4798      	blx	r3
}
 80003ac:	e03d      	b.n	800042a <EXTI15_10_IRQHandler+0xfe>
	else if(EXTI_INTERRUPET_TRIGGERED == READ_BIT(EXTI->PR, 13)){
 80003ae:	4b20      	ldr	r3, [pc, #128]	; (8000430 <EXTI15_10_IRQHandler+0x104>)
 80003b0:	695b      	ldr	r3, [r3, #20]
 80003b2:	0b5b      	lsrs	r3, r3, #13
 80003b4:	f003 0301 	and.w	r3, r3, #1
 80003b8:	2b01      	cmp	r3, #1
 80003ba:	d10d      	bne.n	80003d8 <EXTI15_10_IRQHandler+0xac>
		SET_BIT(EXTI->PR, 13);
 80003bc:	4b1c      	ldr	r3, [pc, #112]	; (8000430 <EXTI15_10_IRQHandler+0x104>)
 80003be:	695b      	ldr	r3, [r3, #20]
 80003c0:	4a1b      	ldr	r2, [pc, #108]	; (8000430 <EXTI15_10_IRQHandler+0x104>)
 80003c2:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 80003c6:	6153      	str	r3, [r2, #20]
		if (EXTI_CallBacks[13] != NULL) {
 80003c8:	4b1a      	ldr	r3, [pc, #104]	; (8000434 <EXTI15_10_IRQHandler+0x108>)
 80003ca:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80003cc:	2b00      	cmp	r3, #0
 80003ce:	d02c      	beq.n	800042a <EXTI15_10_IRQHandler+0xfe>
			EXTI_CallBacks[13]();
 80003d0:	4b18      	ldr	r3, [pc, #96]	; (8000434 <EXTI15_10_IRQHandler+0x108>)
 80003d2:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80003d4:	4798      	blx	r3
}
 80003d6:	e028      	b.n	800042a <EXTI15_10_IRQHandler+0xfe>
	else if(EXTI_INTERRUPET_TRIGGERED == READ_BIT(EXTI->PR, 14)){
 80003d8:	4b15      	ldr	r3, [pc, #84]	; (8000430 <EXTI15_10_IRQHandler+0x104>)
 80003da:	695b      	ldr	r3, [r3, #20]
 80003dc:	0b9b      	lsrs	r3, r3, #14
 80003de:	f003 0301 	and.w	r3, r3, #1
 80003e2:	2b01      	cmp	r3, #1
 80003e4:	d10d      	bne.n	8000402 <EXTI15_10_IRQHandler+0xd6>
		SET_BIT(EXTI->PR, 14);
 80003e6:	4b12      	ldr	r3, [pc, #72]	; (8000430 <EXTI15_10_IRQHandler+0x104>)
 80003e8:	695b      	ldr	r3, [r3, #20]
 80003ea:	4a11      	ldr	r2, [pc, #68]	; (8000430 <EXTI15_10_IRQHandler+0x104>)
 80003ec:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 80003f0:	6153      	str	r3, [r2, #20]
		if (EXTI_CallBacks[14] != NULL) {
 80003f2:	4b10      	ldr	r3, [pc, #64]	; (8000434 <EXTI15_10_IRQHandler+0x108>)
 80003f4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80003f6:	2b00      	cmp	r3, #0
 80003f8:	d017      	beq.n	800042a <EXTI15_10_IRQHandler+0xfe>
			EXTI_CallBacks[14]();
 80003fa:	4b0e      	ldr	r3, [pc, #56]	; (8000434 <EXTI15_10_IRQHandler+0x108>)
 80003fc:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80003fe:	4798      	blx	r3
}
 8000400:	e013      	b.n	800042a <EXTI15_10_IRQHandler+0xfe>
	else if(EXTI_INTERRUPET_TRIGGERED == READ_BIT(EXTI->PR, 15)){
 8000402:	4b0b      	ldr	r3, [pc, #44]	; (8000430 <EXTI15_10_IRQHandler+0x104>)
 8000404:	695b      	ldr	r3, [r3, #20]
 8000406:	0bdb      	lsrs	r3, r3, #15
 8000408:	f003 0301 	and.w	r3, r3, #1
 800040c:	2b01      	cmp	r3, #1
 800040e:	d10c      	bne.n	800042a <EXTI15_10_IRQHandler+0xfe>
		SET_BIT(EXTI->PR, 15);
 8000410:	4b07      	ldr	r3, [pc, #28]	; (8000430 <EXTI15_10_IRQHandler+0x104>)
 8000412:	695b      	ldr	r3, [r3, #20]
 8000414:	4a06      	ldr	r2, [pc, #24]	; (8000430 <EXTI15_10_IRQHandler+0x104>)
 8000416:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800041a:	6153      	str	r3, [r2, #20]
		if (EXTI_CallBacks[15] != NULL) {
 800041c:	4b05      	ldr	r3, [pc, #20]	; (8000434 <EXTI15_10_IRQHandler+0x108>)
 800041e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8000420:	2b00      	cmp	r3, #0
 8000422:	d002      	beq.n	800042a <EXTI15_10_IRQHandler+0xfe>
			EXTI_CallBacks[15]();
 8000424:	4b03      	ldr	r3, [pc, #12]	; (8000434 <EXTI15_10_IRQHandler+0x108>)
 8000426:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8000428:	4798      	blx	r3
}
 800042a:	bf00      	nop
 800042c:	bd80      	pop	{r7, pc}
 800042e:	bf00      	nop
 8000430:	40010400 	.word	0x40010400
 8000434:	20000054 	.word	0x20000054

08000438 <MCAL_GPIO_Init>:
 *
 * @Retval    None
 *
 * @Note      This function must be called before performing any operation on the pin.
 */
void MCAL_GPIO_Init(GPIO_t *GPIOx, GPIO_PinConfig_t *PinConfig){
 8000438:	b480      	push	{r7}
 800043a:	b085      	sub	sp, #20
 800043c:	af00      	add	r7, sp, #0
 800043e:	6078      	str	r0, [r7, #4]
 8000440:	6039      	str	r1, [r7, #0]
	volatile uint32 *configRegister = NULL;
 8000442:	2300      	movs	r3, #0
 8000444:	60fb      	str	r3, [r7, #12]
	uint8 shift = 0;
 8000446:	2300      	movs	r3, #0
 8000448:	72fb      	strb	r3, [r7, #11]
	uint8 pin = PinConfig->PinNum ;
 800044a:	683b      	ldr	r3, [r7, #0]
 800044c:	781b      	ldrb	r3, [r3, #0]
 800044e:	72bb      	strb	r3, [r7, #10]

	if(pin >= 0 && pin <= 7){
 8000450:	7abb      	ldrb	r3, [r7, #10]
 8000452:	2b07      	cmp	r3, #7
 8000454:	d805      	bhi.n	8000462 <MCAL_GPIO_Init+0x2a>
		// Port configuration register low (GPIOx_CRL) 0>>7
		configRegister = &(GPIOx->CRL);
 8000456:	687b      	ldr	r3, [r7, #4]
 8000458:	60fb      	str	r3, [r7, #12]
		shift = (pin * 4);
 800045a:	7abb      	ldrb	r3, [r7, #10]
 800045c:	009b      	lsls	r3, r3, #2
 800045e:	72fb      	strb	r3, [r7, #11]
 8000460:	e00d      	b.n	800047e <MCAL_GPIO_Init+0x46>
	}
	else if(pin >= 8 && pin <= 15){
 8000462:	7abb      	ldrb	r3, [r7, #10]
 8000464:	2b07      	cmp	r3, #7
 8000466:	d94c      	bls.n	8000502 <MCAL_GPIO_Init+0xca>
 8000468:	7abb      	ldrb	r3, [r7, #10]
 800046a:	2b0f      	cmp	r3, #15
 800046c:	d849      	bhi.n	8000502 <MCAL_GPIO_Init+0xca>
		// Port configuration register high (GPIOx_CRH) 8>>15
		configRegister = &(GPIOx->CRH);
 800046e:	687b      	ldr	r3, [r7, #4]
 8000470:	3304      	adds	r3, #4
 8000472:	60fb      	str	r3, [r7, #12]
		shift = ((pin - 8) * 4);
 8000474:	7abb      	ldrb	r3, [r7, #10]
 8000476:	3338      	adds	r3, #56	; 0x38
 8000478:	b2db      	uxtb	r3, r3
 800047a:	009b      	lsls	r3, r3, #2
 800047c:	72fb      	strb	r3, [r7, #11]
	else{
		return;
	}

	// Clear the current configuration for the pin
	*configRegister &= ~(0xF << shift);
 800047e:	68fb      	ldr	r3, [r7, #12]
 8000480:	681b      	ldr	r3, [r3, #0]
 8000482:	7afa      	ldrb	r2, [r7, #11]
 8000484:	210f      	movs	r1, #15
 8000486:	fa01 f202 	lsl.w	r2, r1, r2
 800048a:	43d2      	mvns	r2, r2
 800048c:	401a      	ands	r2, r3
 800048e:	68fb      	ldr	r3, [r7, #12]
 8000490:	601a      	str	r2, [r3, #0]

	if(PinConfig->PinCNF == GPIO_CNF_PULL_UP_DOWN_INPUT){
 8000492:	683b      	ldr	r3, [r7, #0]
 8000494:	78db      	ldrb	r3, [r3, #3]
 8000496:	2b02      	cmp	r3, #2
 8000498:	d119      	bne.n	80004ce <MCAL_GPIO_Init+0x96>
		// Configure Pin State : High OR Low
		if(PinConfig->PinState == GPIO_HIGH){
 800049a:	683b      	ldr	r3, [r7, #0]
 800049c:	789b      	ldrb	r3, [r3, #2]
 800049e:	2b01      	cmp	r3, #1
 80004a0:	d10a      	bne.n	80004b8 <MCAL_GPIO_Init+0x80>
			SET_BIT(GPIOx->ODR, PinConfig->PinNum);		 // Enable pull-up
 80004a2:	687b      	ldr	r3, [r7, #4]
 80004a4:	68db      	ldr	r3, [r3, #12]
 80004a6:	683a      	ldr	r2, [r7, #0]
 80004a8:	7812      	ldrb	r2, [r2, #0]
 80004aa:	4611      	mov	r1, r2
 80004ac:	2201      	movs	r2, #1
 80004ae:	408a      	lsls	r2, r1
 80004b0:	431a      	orrs	r2, r3
 80004b2:	687b      	ldr	r3, [r7, #4]
 80004b4:	60da      	str	r2, [r3, #12]
 80004b6:	e00a      	b.n	80004ce <MCAL_GPIO_Init+0x96>
		}
		else{
			CLEAR_BIT(GPIOx->ODR, PinConfig->PinNum);	// Enable pull-down
 80004b8:	687b      	ldr	r3, [r7, #4]
 80004ba:	68db      	ldr	r3, [r3, #12]
 80004bc:	683a      	ldr	r2, [r7, #0]
 80004be:	7812      	ldrb	r2, [r2, #0]
 80004c0:	4611      	mov	r1, r2
 80004c2:	2201      	movs	r2, #1
 80004c4:	408a      	lsls	r2, r1
 80004c6:	43d2      	mvns	r2, r2
 80004c8:	401a      	ands	r2, r3
 80004ca:	687b      	ldr	r3, [r7, #4]
 80004cc:	60da      	str	r2, [r3, #12]
		}
	}

	// Set the mode and configuration
	*configRegister |= ((PinConfig->PinMode & 0x03) << shift);		 // MODE[1:0]
 80004ce:	68fb      	ldr	r3, [r7, #12]
 80004d0:	681b      	ldr	r3, [r3, #0]
 80004d2:	683a      	ldr	r2, [r7, #0]
 80004d4:	7852      	ldrb	r2, [r2, #1]
 80004d6:	f002 0103 	and.w	r1, r2, #3
 80004da:	7afa      	ldrb	r2, [r7, #11]
 80004dc:	fa01 f202 	lsl.w	r2, r1, r2
 80004e0:	431a      	orrs	r2, r3
 80004e2:	68fb      	ldr	r3, [r7, #12]
 80004e4:	601a      	str	r2, [r3, #0]
	*configRegister |= ((PinConfig->PinCNF & 0x03) << (shift+2));	 // CNF[1:0]
 80004e6:	68fb      	ldr	r3, [r7, #12]
 80004e8:	681b      	ldr	r3, [r3, #0]
 80004ea:	683a      	ldr	r2, [r7, #0]
 80004ec:	78d2      	ldrb	r2, [r2, #3]
 80004ee:	f002 0103 	and.w	r1, r2, #3
 80004f2:	7afa      	ldrb	r2, [r7, #11]
 80004f4:	3202      	adds	r2, #2
 80004f6:	fa01 f202 	lsl.w	r2, r1, r2
 80004fa:	431a      	orrs	r2, r3
 80004fc:	68fb      	ldr	r3, [r7, #12]
 80004fe:	601a      	str	r2, [r3, #0]
 8000500:	e000      	b.n	8000504 <MCAL_GPIO_Init+0xcc>
		return;
 8000502:	bf00      	nop


}
 8000504:	3714      	adds	r7, #20
 8000506:	46bd      	mov	sp, r7
 8000508:	bc80      	pop	{r7}
 800050a:	4770      	bx	lr

0800050c <MCAL_GPIO_WritePin>:
 *
 * @Retval    None
 *
 * @Note      Ensure the pin is configured as an output before calling this function.
 */
void MCAL_GPIO_WritePin(GPIO_t *GPIOx, GPIO_PinNum_t PinNumber, GPIO_PinState_t value){
 800050c:	b480      	push	{r7}
 800050e:	b083      	sub	sp, #12
 8000510:	af00      	add	r7, sp, #0
 8000512:	6078      	str	r0, [r7, #4]
 8000514:	460b      	mov	r3, r1
 8000516:	70fb      	strb	r3, [r7, #3]
 8000518:	4613      	mov	r3, r2
 800051a:	70bb      	strb	r3, [r7, #2]
	if(value == GPIO_HIGH){
 800051c:	78bb      	ldrb	r3, [r7, #2]
 800051e:	2b01      	cmp	r3, #1
 8000520:	d109      	bne.n	8000536 <MCAL_GPIO_WritePin+0x2a>
		SET_BIT(GPIOx->ODR, PinNumber);
 8000522:	687b      	ldr	r3, [r7, #4]
 8000524:	68db      	ldr	r3, [r3, #12]
 8000526:	78fa      	ldrb	r2, [r7, #3]
 8000528:	2101      	movs	r1, #1
 800052a:	fa01 f202 	lsl.w	r2, r1, r2
 800052e:	431a      	orrs	r2, r3
 8000530:	687b      	ldr	r3, [r7, #4]
 8000532:	60da      	str	r2, [r3, #12]
 8000534:	e00e      	b.n	8000554 <MCAL_GPIO_WritePin+0x48>
	}
	else if(value == GPIO_LOW){
 8000536:	78bb      	ldrb	r3, [r7, #2]
 8000538:	2b00      	cmp	r3, #0
 800053a:	d10a      	bne.n	8000552 <MCAL_GPIO_WritePin+0x46>
		CLEAR_BIT(GPIOx->ODR, PinNumber);
 800053c:	687b      	ldr	r3, [r7, #4]
 800053e:	68db      	ldr	r3, [r3, #12]
 8000540:	78fa      	ldrb	r2, [r7, #3]
 8000542:	2101      	movs	r1, #1
 8000544:	fa01 f202 	lsl.w	r2, r1, r2
 8000548:	43d2      	mvns	r2, r2
 800054a:	401a      	ands	r2, r3
 800054c:	687b      	ldr	r3, [r7, #4]
 800054e:	60da      	str	r2, [r3, #12]
 8000550:	e000      	b.n	8000554 <MCAL_GPIO_WritePin+0x48>
	}
	else{
		return;
 8000552:	bf00      	nop
	}
}
 8000554:	370c      	adds	r7, #12
 8000556:	46bd      	mov	sp, r7
 8000558:	bc80      	pop	{r7}
 800055a:	4770      	bx	lr

0800055c <MCAL_RCC_GetSYSCLK_Freq>:
#include "stm32f103x6_RCC_driver.h"

static const uint32 AHP_Prescaler_Table[16] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 6, 7, 8, 9};
static const uint32 ABP_Prescaler_Table[8] = {0, 0, 0, 0, 1, 2, 3, 4};

uint32 MCAL_RCC_GetSYSCLK_Freq(){
 800055c:	b480      	push	{r7}
 800055e:	af00      	add	r7, sp, #0
	switch((RCC->CFGR >> 2) & 0x3){
 8000560:	4b09      	ldr	r3, [pc, #36]	; (8000588 <MCAL_RCC_GetSYSCLK_Freq+0x2c>)
 8000562:	685b      	ldr	r3, [r3, #4]
 8000564:	089b      	lsrs	r3, r3, #2
 8000566:	f003 0303 	and.w	r3, r3, #3
 800056a:	2b01      	cmp	r3, #1
 800056c:	d007      	beq.n	800057e <MCAL_RCC_GetSYSCLK_Freq+0x22>
 800056e:	2b01      	cmp	r3, #1
 8000570:	d303      	bcc.n	800057a <MCAL_RCC_GetSYSCLK_Freq+0x1e>
 8000572:	2b02      	cmp	r3, #2
		case RCC_HSE_CLOCK :
			return HSE_RC_FREQ;
			break;
		case RCC_PLL_CLOCK :
			// Select PLLSRC, Choose PLLMUL, Return PLLCLK
			break;
 8000574:	bf00      	nop
	}
	return RCC_HSI_CLOCK; // by default
 8000576:	2300      	movs	r3, #0
 8000578:	e002      	b.n	8000580 <MCAL_RCC_GetSYSCLK_Freq+0x24>
			return HSI_RC_FREQ;
 800057a:	4b04      	ldr	r3, [pc, #16]	; (800058c <MCAL_RCC_GetSYSCLK_Freq+0x30>)
 800057c:	e000      	b.n	8000580 <MCAL_RCC_GetSYSCLK_Freq+0x24>
			return HSE_RC_FREQ;
 800057e:	4b04      	ldr	r3, [pc, #16]	; (8000590 <MCAL_RCC_GetSYSCLK_Freq+0x34>)
}
 8000580:	4618      	mov	r0, r3
 8000582:	46bd      	mov	sp, r7
 8000584:	bc80      	pop	{r7}
 8000586:	4770      	bx	lr
 8000588:	40021000 	.word	0x40021000
 800058c:	007a1200 	.word	0x007a1200
 8000590:	00f42400 	.word	0x00f42400

08000594 <MCAL_RCC_GetHCLK_Freq>:

uint32 MCAL_RCC_GetHCLK_Freq(){
 8000594:	b580      	push	{r7, lr}
 8000596:	b084      	sub	sp, #16
 8000598:	af00      	add	r7, sp, #0
	uint32 SYSCLK = MCAL_RCC_GetSYSCLK_Freq();
 800059a:	f7ff ffdf 	bl	800055c <MCAL_RCC_GetSYSCLK_Freq>
 800059e:	60f8      	str	r0, [r7, #12]
			1100: SYSCLK divided by 64
			1101: SYSCLK divided by 128
			1110: SYSCLK divided by 256
			1111: SYSCLK divided by 512
	 */
	uint32 AHB_Prescale = ((RCC->CFGR >> 4) & 0xF);
 80005a0:	4b09      	ldr	r3, [pc, #36]	; (80005c8 <MCAL_RCC_GetHCLK_Freq+0x34>)
 80005a2:	685b      	ldr	r3, [r3, #4]
 80005a4:	091b      	lsrs	r3, r3, #4
 80005a6:	f003 030f 	and.w	r3, r3, #15
 80005aa:	60bb      	str	r3, [r7, #8]
	uint32 HCLK = ((uint32)SYSCLK >> AHP_Prescaler_Table[AHB_Prescale]);
 80005ac:	4a07      	ldr	r2, [pc, #28]	; (80005cc <MCAL_RCC_GetHCLK_Freq+0x38>)
 80005ae:	68bb      	ldr	r3, [r7, #8]
 80005b0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80005b4:	68fa      	ldr	r2, [r7, #12]
 80005b6:	fa22 f303 	lsr.w	r3, r2, r3
 80005ba:	607b      	str	r3, [r7, #4]
	return HCLK;
 80005bc:	687b      	ldr	r3, [r7, #4]
}
 80005be:	4618      	mov	r0, r3
 80005c0:	3710      	adds	r7, #16
 80005c2:	46bd      	mov	sp, r7
 80005c4:	bd80      	pop	{r7, pc}
 80005c6:	bf00      	nop
 80005c8:	40021000 	.word	0x40021000
 80005cc:	08001190 	.word	0x08001190

080005d0 <MCAL_RCC_GetPCLK1_Freq>:

uint32 MCAL_RCC_GetPCLK1_Freq(){
 80005d0:	b580      	push	{r7, lr}
 80005d2:	b084      	sub	sp, #16
 80005d4:	af00      	add	r7, sp, #0
	uint32 HCLK = MCAL_RCC_GetHCLK_Freq();
 80005d6:	f7ff ffdd 	bl	8000594 <MCAL_RCC_GetHCLK_Freq>
 80005da:	60f8      	str	r0, [r7, #12]
		100: HCLK divided by 2
		101: HCLK divided by 4
		110: HCLK divided by 8
		111: HCLK divided by 16
	*/
	uint32 ABP1_Prescale = ((RCC->CFGR >> 8) & 0x3);
 80005dc:	4b09      	ldr	r3, [pc, #36]	; (8000604 <MCAL_RCC_GetPCLK1_Freq+0x34>)
 80005de:	685b      	ldr	r3, [r3, #4]
 80005e0:	0a1b      	lsrs	r3, r3, #8
 80005e2:	f003 0303 	and.w	r3, r3, #3
 80005e6:	60bb      	str	r3, [r7, #8]
	uint32 PCLK1 = ((uint32)HCLK >> ABP_Prescaler_Table[ABP1_Prescale]);
 80005e8:	4a07      	ldr	r2, [pc, #28]	; (8000608 <MCAL_RCC_GetPCLK1_Freq+0x38>)
 80005ea:	68bb      	ldr	r3, [r7, #8]
 80005ec:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80005f0:	68fa      	ldr	r2, [r7, #12]
 80005f2:	fa22 f303 	lsr.w	r3, r2, r3
 80005f6:	607b      	str	r3, [r7, #4]
	return PCLK1;
 80005f8:	687b      	ldr	r3, [r7, #4]
}
 80005fa:	4618      	mov	r0, r3
 80005fc:	3710      	adds	r7, #16
 80005fe:	46bd      	mov	sp, r7
 8000600:	bd80      	pop	{r7, pc}
 8000602:	bf00      	nop
 8000604:	40021000 	.word	0x40021000
 8000608:	080011d0 	.word	0x080011d0

0800060c <MCAL_RCC_GetPCLK2_Freq>:

uint32 MCAL_RCC_GetPCLK2_Freq(){
 800060c:	b580      	push	{r7, lr}
 800060e:	b084      	sub	sp, #16
 8000610:	af00      	add	r7, sp, #0
	uint32 HCLK = MCAL_RCC_GetHCLK_Freq();
 8000612:	f7ff ffbf 	bl	8000594 <MCAL_RCC_GetHCLK_Freq>
 8000616:	60f8      	str	r0, [r7, #12]
		100: HCLK divided by 2
		101: HCLK divided by 4
		110: HCLK divided by 8
		111: HCLK divided by 16
	 */
	uint32 ABP2_Prescale = ((RCC->CFGR >> 11) & 0x3);
 8000618:	4b09      	ldr	r3, [pc, #36]	; (8000640 <MCAL_RCC_GetPCLK2_Freq+0x34>)
 800061a:	685b      	ldr	r3, [r3, #4]
 800061c:	0adb      	lsrs	r3, r3, #11
 800061e:	f003 0303 	and.w	r3, r3, #3
 8000622:	60bb      	str	r3, [r7, #8]
	uint32 PCLK2 = ((uint32)HCLK >> ABP_Prescaler_Table[ABP2_Prescale]);
 8000624:	4a07      	ldr	r2, [pc, #28]	; (8000644 <MCAL_RCC_GetPCLK2_Freq+0x38>)
 8000626:	68bb      	ldr	r3, [r7, #8]
 8000628:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800062c:	68fa      	ldr	r2, [r7, #12]
 800062e:	fa22 f303 	lsr.w	r3, r2, r3
 8000632:	607b      	str	r3, [r7, #4]
	return PCLK2;
 8000634:	687b      	ldr	r3, [r7, #4]
}
 8000636:	4618      	mov	r0, r3
 8000638:	3710      	adds	r7, #16
 800063a:	46bd      	mov	sp, r7
 800063c:	bd80      	pop	{r7, pc}
 800063e:	bf00      	nop
 8000640:	40021000 	.word	0x40021000
 8000644:	080011d0 	.word	0x080011d0

08000648 <MCAL_SPI_Set_GPIO_Pins>:

/* ================================================================ */
/* ======================== Static APIs =========================== */
/* ================================================================ */

static void MCAL_SPI_Set_GPIO_Pins(SPI_Config_t *SPI_config){
 8000648:	b580      	push	{r7, lr}
 800064a:	b084      	sub	sp, #16
 800064c:	af00      	add	r7, sp, #0
 800064e:	6078      	str	r0, [r7, #4]
	GPIO_PinConfig_t PinCfg;
	if(SPI_config->SPIx == SPI1){
 8000650:	687b      	ldr	r3, [r7, #4]
 8000652:	681b      	ldr	r3, [r3, #0]
 8000654:	4a8f      	ldr	r2, [pc, #572]	; (8000894 <MCAL_SPI_Set_GPIO_Pins+0x24c>)
 8000656:	4293      	cmp	r3, r2
 8000658:	f040 808b 	bne.w	8000772 <MCAL_SPI_Set_GPIO_Pins+0x12a>
		// SPI1_NSS : PA4
		// SPI1_SCK : PA5
		// SPI1_MISO : PA6
		// SPI1_MOSI : PA7
		if(SPI_config->mode == SPI_MODE_SLAVE){
 800065c:	687b      	ldr	r3, [r7, #4]
 800065e:	791b      	ldrb	r3, [r3, #4]
 8000660:	2b00      	cmp	r3, #0
 8000662:	d135      	bne.n	80006d0 <MCAL_SPI_Set_GPIO_Pins+0x88>
			// Set MISO as Alternate function push-pull
			PinCfg.PinMode = GPIO_OUTPUT_10MHZ;
 8000664:	2301      	movs	r3, #1
 8000666:	737b      	strb	r3, [r7, #13]
			PinCfg.PinNum = GPIO_PIN6;
 8000668:	2306      	movs	r3, #6
 800066a:	733b      	strb	r3, [r7, #12]
			PinCfg.PinCNF = GPIO_CNF_AF_PUSH_PULL_OUTPUT;
 800066c:	2302      	movs	r3, #2
 800066e:	73fb      	strb	r3, [r7, #15]
			MCAL_GPIO_Init(GPIOA, &PinCfg);
 8000670:	f107 030c 	add.w	r3, r7, #12
 8000674:	4619      	mov	r1, r3
 8000676:	4888      	ldr	r0, [pc, #544]	; (8000898 <MCAL_SPI_Set_GPIO_Pins+0x250>)
 8000678:	f7ff fede 	bl	8000438 <MCAL_GPIO_Init>
			// Set MOSI as input floating / Input pull-up
			PinCfg.PinMode = GPIO_INPUT;
 800067c:	2300      	movs	r3, #0
 800067e:	737b      	strb	r3, [r7, #13]
			PinCfg.PinNum = GPIO_PIN7;
 8000680:	2307      	movs	r3, #7
 8000682:	733b      	strb	r3, [r7, #12]
			PinCfg.PinCNF = GPIO_CNF_FLOATING_INPUT;
 8000684:	2301      	movs	r3, #1
 8000686:	73fb      	strb	r3, [r7, #15]
			MCAL_GPIO_Init(GPIOA, &PinCfg);
 8000688:	f107 030c 	add.w	r3, r7, #12
 800068c:	4619      	mov	r1, r3
 800068e:	4882      	ldr	r0, [pc, #520]	; (8000898 <MCAL_SPI_Set_GPIO_Pins+0x250>)
 8000690:	f7ff fed2 	bl	8000438 <MCAL_GPIO_Init>
			// Set SPI1_SCK as input floating
			PinCfg.PinMode = GPIO_INPUT;
 8000694:	2300      	movs	r3, #0
 8000696:	737b      	strb	r3, [r7, #13]
			PinCfg.PinNum = GPIO_PIN5;
 8000698:	2305      	movs	r3, #5
 800069a:	733b      	strb	r3, [r7, #12]
			PinCfg.PinCNF = GPIO_CNF_FLOATING_INPUT;
 800069c:	2301      	movs	r3, #1
 800069e:	73fb      	strb	r3, [r7, #15]
			MCAL_GPIO_Init(GPIOA, &PinCfg);
 80006a0:	f107 030c 	add.w	r3, r7, #12
 80006a4:	4619      	mov	r1, r3
 80006a6:	487c      	ldr	r0, [pc, #496]	; (8000898 <MCAL_SPI_Set_GPIO_Pins+0x250>)
 80006a8:	f7ff fec6 	bl	8000438 <MCAL_GPIO_Init>
			if(SPI_config->ssm == SPI_SSM_DISABLED){  // Hardware NSS management
 80006ac:	687b      	ldr	r3, [r7, #4]
 80006ae:	7a9b      	ldrb	r3, [r3, #10]
 80006b0:	2b00      	cmp	r3, #0
 80006b2:	f040 80ea 	bne.w	800088a <MCAL_SPI_Set_GPIO_Pins+0x242>
				// Set SPIx_NSS as Input floating
				PinCfg.PinMode = GPIO_INPUT;
 80006b6:	2300      	movs	r3, #0
 80006b8:	737b      	strb	r3, [r7, #13]
				PinCfg.PinNum = GPIO_PIN4;
 80006ba:	2304      	movs	r3, #4
 80006bc:	733b      	strb	r3, [r7, #12]
				PinCfg.PinCNF = GPIO_CNF_FLOATING_INPUT;
 80006be:	2301      	movs	r3, #1
 80006c0:	73fb      	strb	r3, [r7, #15]
				MCAL_GPIO_Init(GPIOA, &PinCfg);
 80006c2:	f107 030c 	add.w	r3, r7, #12
 80006c6:	4619      	mov	r1, r3
 80006c8:	4873      	ldr	r0, [pc, #460]	; (8000898 <MCAL_SPI_Set_GPIO_Pins+0x250>)
 80006ca:	f7ff feb5 	bl	8000438 <MCAL_GPIO_Init>
					MCAL_GPIO_Init(GPIOB, &PinCfg);
				}
			}
		}
	}
}
 80006ce:	e0dc      	b.n	800088a <MCAL_SPI_Set_GPIO_Pins+0x242>
		else if(SPI_config->mode == SPI_MODE_MASTER){
 80006d0:	687b      	ldr	r3, [r7, #4]
 80006d2:	791b      	ldrb	r3, [r3, #4]
 80006d4:	2b01      	cmp	r3, #1
 80006d6:	f040 80d8 	bne.w	800088a <MCAL_SPI_Set_GPIO_Pins+0x242>
			PinCfg.PinMode = GPIO_INPUT;
 80006da:	2300      	movs	r3, #0
 80006dc:	737b      	strb	r3, [r7, #13]
			PinCfg.PinNum = GPIO_PIN6;
 80006de:	2306      	movs	r3, #6
 80006e0:	733b      	strb	r3, [r7, #12]
			PinCfg.PinCNF = GPIO_CNF_FLOATING_INPUT;
 80006e2:	2301      	movs	r3, #1
 80006e4:	73fb      	strb	r3, [r7, #15]
			MCAL_GPIO_Init(GPIOA, &PinCfg);
 80006e6:	f107 030c 	add.w	r3, r7, #12
 80006ea:	4619      	mov	r1, r3
 80006ec:	486a      	ldr	r0, [pc, #424]	; (8000898 <MCAL_SPI_Set_GPIO_Pins+0x250>)
 80006ee:	f7ff fea3 	bl	8000438 <MCAL_GPIO_Init>
			PinCfg.PinMode = GPIO_OUTPUT_10MHZ;
 80006f2:	2301      	movs	r3, #1
 80006f4:	737b      	strb	r3, [r7, #13]
			PinCfg.PinNum = GPIO_PIN7;
 80006f6:	2307      	movs	r3, #7
 80006f8:	733b      	strb	r3, [r7, #12]
			PinCfg.PinCNF = GPIO_CNF_AF_PUSH_PULL_OUTPUT;
 80006fa:	2302      	movs	r3, #2
 80006fc:	73fb      	strb	r3, [r7, #15]
			MCAL_GPIO_Init(GPIOA, &PinCfg);
 80006fe:	f107 030c 	add.w	r3, r7, #12
 8000702:	4619      	mov	r1, r3
 8000704:	4864      	ldr	r0, [pc, #400]	; (8000898 <MCAL_SPI_Set_GPIO_Pins+0x250>)
 8000706:	f7ff fe97 	bl	8000438 <MCAL_GPIO_Init>
			PinCfg.PinMode = GPIO_OUTPUT_10MHZ;
 800070a:	2301      	movs	r3, #1
 800070c:	737b      	strb	r3, [r7, #13]
			PinCfg.PinNum = GPIO_PIN5;
 800070e:	2305      	movs	r3, #5
 8000710:	733b      	strb	r3, [r7, #12]
			PinCfg.PinCNF = GPIO_CNF_AF_PUSH_PULL_OUTPUT;
 8000712:	2302      	movs	r3, #2
 8000714:	73fb      	strb	r3, [r7, #15]
			MCAL_GPIO_Init(GPIOA, &PinCfg);
 8000716:	f107 030c 	add.w	r3, r7, #12
 800071a:	4619      	mov	r1, r3
 800071c:	485e      	ldr	r0, [pc, #376]	; (8000898 <MCAL_SPI_Set_GPIO_Pins+0x250>)
 800071e:	f7ff fe8b 	bl	8000438 <MCAL_GPIO_Init>
			if(SPI_config->ssm == SPI_SSM_DISABLED){  // Hardware NSS management
 8000722:	687b      	ldr	r3, [r7, #4]
 8000724:	7a9b      	ldrb	r3, [r3, #10]
 8000726:	2b00      	cmp	r3, #0
 8000728:	f040 80af 	bne.w	800088a <MCAL_SPI_Set_GPIO_Pins+0x242>
				if(SPI_config->ssoe == SPI_SSOE_DISABLED){
 800072c:	687b      	ldr	r3, [r7, #4]
 800072e:	7d1b      	ldrb	r3, [r3, #20]
 8000730:	2b00      	cmp	r3, #0
 8000732:	d10c      	bne.n	800074e <MCAL_SPI_Set_GPIO_Pins+0x106>
					PinCfg.PinMode = GPIO_INPUT;
 8000734:	2300      	movs	r3, #0
 8000736:	737b      	strb	r3, [r7, #13]
					PinCfg.PinNum = GPIO_PIN4;
 8000738:	2304      	movs	r3, #4
 800073a:	733b      	strb	r3, [r7, #12]
					PinCfg.PinCNF = GPIO_CNF_FLOATING_INPUT;
 800073c:	2301      	movs	r3, #1
 800073e:	73fb      	strb	r3, [r7, #15]
					MCAL_GPIO_Init(GPIOA, &PinCfg);
 8000740:	f107 030c 	add.w	r3, r7, #12
 8000744:	4619      	mov	r1, r3
 8000746:	4854      	ldr	r0, [pc, #336]	; (8000898 <MCAL_SPI_Set_GPIO_Pins+0x250>)
 8000748:	f7ff fe76 	bl	8000438 <MCAL_GPIO_Init>
}
 800074c:	e09d      	b.n	800088a <MCAL_SPI_Set_GPIO_Pins+0x242>
				else if(SPI_config->ssoe == SPI_SSOE_ENABLED){
 800074e:	687b      	ldr	r3, [r7, #4]
 8000750:	7d1b      	ldrb	r3, [r3, #20]
 8000752:	2b01      	cmp	r3, #1
 8000754:	f040 8099 	bne.w	800088a <MCAL_SPI_Set_GPIO_Pins+0x242>
					PinCfg.PinMode = GPIO_OUTPUT_10MHZ;
 8000758:	2301      	movs	r3, #1
 800075a:	737b      	strb	r3, [r7, #13]
					PinCfg.PinNum = GPIO_PIN4;
 800075c:	2304      	movs	r3, #4
 800075e:	733b      	strb	r3, [r7, #12]
					PinCfg.PinCNF = GPIO_CNF_AF_PUSH_PULL_OUTPUT;
 8000760:	2302      	movs	r3, #2
 8000762:	73fb      	strb	r3, [r7, #15]
					MCAL_GPIO_Init(GPIOA, &PinCfg);
 8000764:	f107 030c 	add.w	r3, r7, #12
 8000768:	4619      	mov	r1, r3
 800076a:	484b      	ldr	r0, [pc, #300]	; (8000898 <MCAL_SPI_Set_GPIO_Pins+0x250>)
 800076c:	f7ff fe64 	bl	8000438 <MCAL_GPIO_Init>
}
 8000770:	e08b      	b.n	800088a <MCAL_SPI_Set_GPIO_Pins+0x242>
	else if(SPI_config->SPIx == SPI2){
 8000772:	687b      	ldr	r3, [r7, #4]
 8000774:	681b      	ldr	r3, [r3, #0]
 8000776:	4a49      	ldr	r2, [pc, #292]	; (800089c <MCAL_SPI_Set_GPIO_Pins+0x254>)
 8000778:	4293      	cmp	r3, r2
 800077a:	f040 8086 	bne.w	800088a <MCAL_SPI_Set_GPIO_Pins+0x242>
		if(SPI_config->mode == SPI_MODE_SLAVE){
 800077e:	687b      	ldr	r3, [r7, #4]
 8000780:	791b      	ldrb	r3, [r3, #4]
 8000782:	2b00      	cmp	r3, #0
 8000784:	d134      	bne.n	80007f0 <MCAL_SPI_Set_GPIO_Pins+0x1a8>
			PinCfg.PinMode = GPIO_OUTPUT_10MHZ;
 8000786:	2301      	movs	r3, #1
 8000788:	737b      	strb	r3, [r7, #13]
			PinCfg.PinNum = GPIO_PIN14;
 800078a:	230e      	movs	r3, #14
 800078c:	733b      	strb	r3, [r7, #12]
			PinCfg.PinCNF = GPIO_CNF_AF_PUSH_PULL_OUTPUT;
 800078e:	2302      	movs	r3, #2
 8000790:	73fb      	strb	r3, [r7, #15]
			MCAL_GPIO_Init(GPIOB, &PinCfg);
 8000792:	f107 030c 	add.w	r3, r7, #12
 8000796:	4619      	mov	r1, r3
 8000798:	4841      	ldr	r0, [pc, #260]	; (80008a0 <MCAL_SPI_Set_GPIO_Pins+0x258>)
 800079a:	f7ff fe4d 	bl	8000438 <MCAL_GPIO_Init>
			PinCfg.PinMode = GPIO_INPUT;
 800079e:	2300      	movs	r3, #0
 80007a0:	737b      	strb	r3, [r7, #13]
			PinCfg.PinNum = GPIO_PIN15;
 80007a2:	230f      	movs	r3, #15
 80007a4:	733b      	strb	r3, [r7, #12]
			PinCfg.PinCNF = GPIO_CNF_FLOATING_INPUT;
 80007a6:	2301      	movs	r3, #1
 80007a8:	73fb      	strb	r3, [r7, #15]
			MCAL_GPIO_Init(GPIOB, &PinCfg);
 80007aa:	f107 030c 	add.w	r3, r7, #12
 80007ae:	4619      	mov	r1, r3
 80007b0:	483b      	ldr	r0, [pc, #236]	; (80008a0 <MCAL_SPI_Set_GPIO_Pins+0x258>)
 80007b2:	f7ff fe41 	bl	8000438 <MCAL_GPIO_Init>
			PinCfg.PinMode = GPIO_INPUT;
 80007b6:	2300      	movs	r3, #0
 80007b8:	737b      	strb	r3, [r7, #13]
			PinCfg.PinNum = GPIO_PIN13;
 80007ba:	230d      	movs	r3, #13
 80007bc:	733b      	strb	r3, [r7, #12]
			PinCfg.PinCNF = GPIO_CNF_FLOATING_INPUT;
 80007be:	2301      	movs	r3, #1
 80007c0:	73fb      	strb	r3, [r7, #15]
			MCAL_GPIO_Init(GPIOB, &PinCfg);
 80007c2:	f107 030c 	add.w	r3, r7, #12
 80007c6:	4619      	mov	r1, r3
 80007c8:	4835      	ldr	r0, [pc, #212]	; (80008a0 <MCAL_SPI_Set_GPIO_Pins+0x258>)
 80007ca:	f7ff fe35 	bl	8000438 <MCAL_GPIO_Init>
			if(SPI_config->ssm == SPI_SSM_DISABLED){  // Hardware NSS management
 80007ce:	687b      	ldr	r3, [r7, #4]
 80007d0:	7a9b      	ldrb	r3, [r3, #10]
 80007d2:	2b00      	cmp	r3, #0
 80007d4:	d159      	bne.n	800088a <MCAL_SPI_Set_GPIO_Pins+0x242>
				PinCfg.PinMode = GPIO_INPUT;
 80007d6:	2300      	movs	r3, #0
 80007d8:	737b      	strb	r3, [r7, #13]
				PinCfg.PinNum = GPIO_PIN12;
 80007da:	230c      	movs	r3, #12
 80007dc:	733b      	strb	r3, [r7, #12]
				PinCfg.PinCNF = GPIO_CNF_FLOATING_INPUT;
 80007de:	2301      	movs	r3, #1
 80007e0:	73fb      	strb	r3, [r7, #15]
				MCAL_GPIO_Init(GPIOB, &PinCfg);
 80007e2:	f107 030c 	add.w	r3, r7, #12
 80007e6:	4619      	mov	r1, r3
 80007e8:	482d      	ldr	r0, [pc, #180]	; (80008a0 <MCAL_SPI_Set_GPIO_Pins+0x258>)
 80007ea:	f7ff fe25 	bl	8000438 <MCAL_GPIO_Init>
}
 80007ee:	e04c      	b.n	800088a <MCAL_SPI_Set_GPIO_Pins+0x242>
		else if(SPI_config->mode == SPI_MODE_MASTER){
 80007f0:	687b      	ldr	r3, [r7, #4]
 80007f2:	791b      	ldrb	r3, [r3, #4]
 80007f4:	2b01      	cmp	r3, #1
 80007f6:	d148      	bne.n	800088a <MCAL_SPI_Set_GPIO_Pins+0x242>
			PinCfg.PinMode = GPIO_INPUT;
 80007f8:	2300      	movs	r3, #0
 80007fa:	737b      	strb	r3, [r7, #13]
			PinCfg.PinNum = GPIO_PIN14;
 80007fc:	230e      	movs	r3, #14
 80007fe:	733b      	strb	r3, [r7, #12]
			PinCfg.PinCNF = GPIO_CNF_FLOATING_INPUT;
 8000800:	2301      	movs	r3, #1
 8000802:	73fb      	strb	r3, [r7, #15]
			MCAL_GPIO_Init(GPIOB, &PinCfg);
 8000804:	f107 030c 	add.w	r3, r7, #12
 8000808:	4619      	mov	r1, r3
 800080a:	4825      	ldr	r0, [pc, #148]	; (80008a0 <MCAL_SPI_Set_GPIO_Pins+0x258>)
 800080c:	f7ff fe14 	bl	8000438 <MCAL_GPIO_Init>
			PinCfg.PinMode = GPIO_OUTPUT_10MHZ;
 8000810:	2301      	movs	r3, #1
 8000812:	737b      	strb	r3, [r7, #13]
			PinCfg.PinNum = GPIO_PIN15;
 8000814:	230f      	movs	r3, #15
 8000816:	733b      	strb	r3, [r7, #12]
			PinCfg.PinCNF = GPIO_CNF_AF_PUSH_PULL_OUTPUT;
 8000818:	2302      	movs	r3, #2
 800081a:	73fb      	strb	r3, [r7, #15]
			MCAL_GPIO_Init(GPIOB, &PinCfg);
 800081c:	f107 030c 	add.w	r3, r7, #12
 8000820:	4619      	mov	r1, r3
 8000822:	481f      	ldr	r0, [pc, #124]	; (80008a0 <MCAL_SPI_Set_GPIO_Pins+0x258>)
 8000824:	f7ff fe08 	bl	8000438 <MCAL_GPIO_Init>
			PinCfg.PinMode = GPIO_OUTPUT_10MHZ;
 8000828:	2301      	movs	r3, #1
 800082a:	737b      	strb	r3, [r7, #13]
			PinCfg.PinNum = GPIO_PIN13;
 800082c:	230d      	movs	r3, #13
 800082e:	733b      	strb	r3, [r7, #12]
			PinCfg.PinCNF = GPIO_CNF_AF_PUSH_PULL_OUTPUT;
 8000830:	2302      	movs	r3, #2
 8000832:	73fb      	strb	r3, [r7, #15]
			MCAL_GPIO_Init(GPIOB, &PinCfg);
 8000834:	f107 030c 	add.w	r3, r7, #12
 8000838:	4619      	mov	r1, r3
 800083a:	4819      	ldr	r0, [pc, #100]	; (80008a0 <MCAL_SPI_Set_GPIO_Pins+0x258>)
 800083c:	f7ff fdfc 	bl	8000438 <MCAL_GPIO_Init>
			if(SPI_config->ssm == SPI_SSM_DISABLED){  // Hardware NSS management
 8000840:	687b      	ldr	r3, [r7, #4]
 8000842:	7a9b      	ldrb	r3, [r3, #10]
 8000844:	2b00      	cmp	r3, #0
 8000846:	d120      	bne.n	800088a <MCAL_SPI_Set_GPIO_Pins+0x242>
				if(SPI_config->ssoe == SPI_SSOE_DISABLED){
 8000848:	687b      	ldr	r3, [r7, #4]
 800084a:	7d1b      	ldrb	r3, [r3, #20]
 800084c:	2b00      	cmp	r3, #0
 800084e:	d10c      	bne.n	800086a <MCAL_SPI_Set_GPIO_Pins+0x222>
					PinCfg.PinMode = GPIO_INPUT;
 8000850:	2300      	movs	r3, #0
 8000852:	737b      	strb	r3, [r7, #13]
					PinCfg.PinNum = GPIO_PIN12;
 8000854:	230c      	movs	r3, #12
 8000856:	733b      	strb	r3, [r7, #12]
					PinCfg.PinCNF = GPIO_CNF_FLOATING_INPUT;
 8000858:	2301      	movs	r3, #1
 800085a:	73fb      	strb	r3, [r7, #15]
					MCAL_GPIO_Init(GPIOB, &PinCfg);
 800085c:	f107 030c 	add.w	r3, r7, #12
 8000860:	4619      	mov	r1, r3
 8000862:	480f      	ldr	r0, [pc, #60]	; (80008a0 <MCAL_SPI_Set_GPIO_Pins+0x258>)
 8000864:	f7ff fde8 	bl	8000438 <MCAL_GPIO_Init>
}
 8000868:	e00f      	b.n	800088a <MCAL_SPI_Set_GPIO_Pins+0x242>
				else if(SPI_config->ssoe == SPI_SSOE_ENABLED){
 800086a:	687b      	ldr	r3, [r7, #4]
 800086c:	7d1b      	ldrb	r3, [r3, #20]
 800086e:	2b01      	cmp	r3, #1
 8000870:	d10b      	bne.n	800088a <MCAL_SPI_Set_GPIO_Pins+0x242>
					PinCfg.PinMode = GPIO_OUTPUT_10MHZ;
 8000872:	2301      	movs	r3, #1
 8000874:	737b      	strb	r3, [r7, #13]
					PinCfg.PinNum = GPIO_PIN12;
 8000876:	230c      	movs	r3, #12
 8000878:	733b      	strb	r3, [r7, #12]
					PinCfg.PinCNF = GPIO_CNF_AF_PUSH_PULL_OUTPUT;
 800087a:	2302      	movs	r3, #2
 800087c:	73fb      	strb	r3, [r7, #15]
					MCAL_GPIO_Init(GPIOB, &PinCfg);
 800087e:	f107 030c 	add.w	r3, r7, #12
 8000882:	4619      	mov	r1, r3
 8000884:	4806      	ldr	r0, [pc, #24]	; (80008a0 <MCAL_SPI_Set_GPIO_Pins+0x258>)
 8000886:	f7ff fdd7 	bl	8000438 <MCAL_GPIO_Init>
}
 800088a:	bf00      	nop
 800088c:	3710      	adds	r7, #16
 800088e:	46bd      	mov	sp, r7
 8000890:	bd80      	pop	{r7, pc}
 8000892:	bf00      	nop
 8000894:	40013000 	.word	0x40013000
 8000898:	40010800 	.word	0x40010800
 800089c:	40003800 	.word	0x40003800
 80008a0:	40010c00 	.word	0x40010c00

080008a4 <MCAL_SPI_SetCallBackFunction>:

static void MCAL_SPI_SetCallBackFunction(SPI_Config_t *SPI_config){
 80008a4:	b480      	push	{r7}
 80008a6:	b083      	sub	sp, #12
 80008a8:	af00      	add	r7, sp, #0
 80008aa:	6078      	str	r0, [r7, #4]
	// Set the callback function for both SPI1/SPI2
	if(SPI_config->SPIx == SPI1){
 80008ac:	687b      	ldr	r3, [r7, #4]
 80008ae:	681b      	ldr	r3, [r3, #0]
 80008b0:	4a0a      	ldr	r2, [pc, #40]	; (80008dc <MCAL_SPI_SetCallBackFunction+0x38>)
 80008b2:	4293      	cmp	r3, r2
 80008b4:	d104      	bne.n	80008c0 <MCAL_SPI_SetCallBackFunction+0x1c>
		SPI_CallBackFunction[0] = SPI_config->SPI_CallBackFun;
 80008b6:	687b      	ldr	r3, [r7, #4]
 80008b8:	699b      	ldr	r3, [r3, #24]
 80008ba:	4a09      	ldr	r2, [pc, #36]	; (80008e0 <MCAL_SPI_SetCallBackFunction+0x3c>)
 80008bc:	6013      	str	r3, [r2, #0]
	}
	else if(SPI_config->SPIx == SPI2){
		SPI_CallBackFunction[1] = SPI_config->SPI_CallBackFun;
	}
}
 80008be:	e008      	b.n	80008d2 <MCAL_SPI_SetCallBackFunction+0x2e>
	else if(SPI_config->SPIx == SPI2){
 80008c0:	687b      	ldr	r3, [r7, #4]
 80008c2:	681b      	ldr	r3, [r3, #0]
 80008c4:	4a07      	ldr	r2, [pc, #28]	; (80008e4 <MCAL_SPI_SetCallBackFunction+0x40>)
 80008c6:	4293      	cmp	r3, r2
 80008c8:	d103      	bne.n	80008d2 <MCAL_SPI_SetCallBackFunction+0x2e>
		SPI_CallBackFunction[1] = SPI_config->SPI_CallBackFun;
 80008ca:	687b      	ldr	r3, [r7, #4]
 80008cc:	699b      	ldr	r3, [r3, #24]
 80008ce:	4a04      	ldr	r2, [pc, #16]	; (80008e0 <MCAL_SPI_SetCallBackFunction+0x3c>)
 80008d0:	6053      	str	r3, [r2, #4]
}
 80008d2:	bf00      	nop
 80008d4:	370c      	adds	r7, #12
 80008d6:	46bd      	mov	sp, r7
 80008d8:	bc80      	pop	{r7}
 80008da:	4770      	bx	lr
 80008dc:	40013000 	.word	0x40013000
 80008e0:	20000094 	.word	0x20000094
 80008e4:	40003800 	.word	0x40003800

080008e8 <MCAL_SPI_Enable_Global_Interrupt>:

static void MCAL_SPI_Enable_Global_Interrupt(SPI_Config_t *SPI_config){
 80008e8:	b480      	push	{r7}
 80008ea:	b083      	sub	sp, #12
 80008ec:	af00      	add	r7, sp, #0
 80008ee:	6078      	str	r0, [r7, #4]
	// Enable the clock for SPI1/SPI2
	if(SPI_config->SPIx == SPI1){
 80008f0:	687b      	ldr	r3, [r7, #4]
 80008f2:	681b      	ldr	r3, [r3, #0]
 80008f4:	4a0c      	ldr	r2, [pc, #48]	; (8000928 <MCAL_SPI_Enable_Global_Interrupt+0x40>)
 80008f6:	4293      	cmp	r3, r2
 80008f8:	d106      	bne.n	8000908 <MCAL_SPI_Enable_Global_Interrupt+0x20>
		NVIC_IRQ_ENABLE(SPI1_IRQ);
 80008fa:	4b0c      	ldr	r3, [pc, #48]	; (800092c <MCAL_SPI_Enable_Global_Interrupt+0x44>)
 80008fc:	681b      	ldr	r3, [r3, #0]
 80008fe:	4a0b      	ldr	r2, [pc, #44]	; (800092c <MCAL_SPI_Enable_Global_Interrupt+0x44>)
 8000900:	f043 0308 	orr.w	r3, r3, #8
 8000904:	6013      	str	r3, [r2, #0]
	}
	else if(SPI_config->SPIx == SPI2){
		NVIC_IRQ_ENABLE(SPI2_IRQ);
	}
}
 8000906:	e00a      	b.n	800091e <MCAL_SPI_Enable_Global_Interrupt+0x36>
	else if(SPI_config->SPIx == SPI2){
 8000908:	687b      	ldr	r3, [r7, #4]
 800090a:	681b      	ldr	r3, [r3, #0]
 800090c:	4a08      	ldr	r2, [pc, #32]	; (8000930 <MCAL_SPI_Enable_Global_Interrupt+0x48>)
 800090e:	4293      	cmp	r3, r2
 8000910:	d105      	bne.n	800091e <MCAL_SPI_Enable_Global_Interrupt+0x36>
		NVIC_IRQ_ENABLE(SPI2_IRQ);
 8000912:	4b06      	ldr	r3, [pc, #24]	; (800092c <MCAL_SPI_Enable_Global_Interrupt+0x44>)
 8000914:	681b      	ldr	r3, [r3, #0]
 8000916:	4a05      	ldr	r2, [pc, #20]	; (800092c <MCAL_SPI_Enable_Global_Interrupt+0x44>)
 8000918:	f043 0310 	orr.w	r3, r3, #16
 800091c:	6013      	str	r3, [r2, #0]
}
 800091e:	bf00      	nop
 8000920:	370c      	adds	r7, #12
 8000922:	46bd      	mov	sp, r7
 8000924:	bc80      	pop	{r7}
 8000926:	4770      	bx	lr
 8000928:	40013000 	.word	0x40013000
 800092c:	e000e104 	.word	0xe000e104
 8000930:	40003800 	.word	0x40003800

08000934 <MCAL_SPI_Init>:

/* ================================================================ */
/* ======================== Public APIs =========================== */
/* ================================================================ */

void MCAL_SPI_Init(SPI_Config_t *SPI_config){
 8000934:	b580      	push	{r7, lr}
 8000936:	b082      	sub	sp, #8
 8000938:	af00      	add	r7, sp, #0
 800093a:	6078      	str	r0, [r7, #4]
	// Enable the clock for SPI1/SPI2
	if(SPI_config->SPIx == SPI1){
 800093c:	687b      	ldr	r3, [r7, #4]
 800093e:	681b      	ldr	r3, [r3, #0]
 8000940:	4a77      	ldr	r2, [pc, #476]	; (8000b20 <MCAL_SPI_Init+0x1ec>)
 8000942:	4293      	cmp	r3, r2
 8000944:	d106      	bne.n	8000954 <MCAL_SPI_Init+0x20>
		SPI1_CLK_EN();
 8000946:	4b77      	ldr	r3, [pc, #476]	; (8000b24 <MCAL_SPI_Init+0x1f0>)
 8000948:	699b      	ldr	r3, [r3, #24]
 800094a:	4a76      	ldr	r2, [pc, #472]	; (8000b24 <MCAL_SPI_Init+0x1f0>)
 800094c:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8000950:	6193      	str	r3, [r2, #24]
 8000952:	e00a      	b.n	800096a <MCAL_SPI_Init+0x36>

	}
	else if(SPI_config->SPIx == SPI2){
 8000954:	687b      	ldr	r3, [r7, #4]
 8000956:	681b      	ldr	r3, [r3, #0]
 8000958:	4a73      	ldr	r2, [pc, #460]	; (8000b28 <MCAL_SPI_Init+0x1f4>)
 800095a:	4293      	cmp	r3, r2
 800095c:	d105      	bne.n	800096a <MCAL_SPI_Init+0x36>
		SPI1_CLK_EN();
 800095e:	4b71      	ldr	r3, [pc, #452]	; (8000b24 <MCAL_SPI_Init+0x1f0>)
 8000960:	699b      	ldr	r3, [r3, #24]
 8000962:	4a70      	ldr	r2, [pc, #448]	; (8000b24 <MCAL_SPI_Init+0x1f0>)
 8000964:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8000968:	6193      	str	r3, [r2, #24]
	/*
		Bit 2 MSTR: Master selection
			0: Slave configuration
			1: Master configuration
	 */
	SPI_config->SPIx->CR1 |= (SPI_config->mode << 2);
 800096a:	687b      	ldr	r3, [r7, #4]
 800096c:	681b      	ldr	r3, [r3, #0]
 800096e:	681a      	ldr	r2, [r3, #0]
 8000970:	687b      	ldr	r3, [r7, #4]
 8000972:	791b      	ldrb	r3, [r3, #4]
 8000974:	009b      	lsls	r3, r3, #2
 8000976:	4619      	mov	r1, r3
 8000978:	687b      	ldr	r3, [r7, #4]
 800097a:	681b      	ldr	r3, [r3, #0]
 800097c:	430a      	orrs	r2, r1
 800097e:	601a      	str	r2, [r3, #0]
	/*
	    Bit 15 BIDIMODE: Bidirectional data mode enable
			0: 2-line unidirectional data mode selected
			1: 1-line bidirectional data mode selected
	 */
	SPI_config->SPIx->CR1 |= (SPI_config->bidirectionalMode << 15);
 8000980:	687b      	ldr	r3, [r7, #4]
 8000982:	681b      	ldr	r3, [r3, #0]
 8000984:	681a      	ldr	r2, [r3, #0]
 8000986:	687b      	ldr	r3, [r7, #4]
 8000988:	79db      	ldrb	r3, [r3, #7]
 800098a:	03db      	lsls	r3, r3, #15
 800098c:	4619      	mov	r1, r3
 800098e:	687b      	ldr	r3, [r7, #4]
 8000990:	681b      	ldr	r3, [r3, #0]
 8000992:	430a      	orrs	r2, r1
 8000994:	601a      	str	r2, [r3, #0]
		Bit 14 BIDIOE: Output enable in bidirectional mode
			This bit combined with the BIDImode bit selects the direction of transfer in bidirectional mode
			0: Output disabled (receive-only mode)
			1: Output enabled (transmit-only mode)
	 */
	if(SPI_config->bidirectionalMode == SPI_BDM_1LINE_BIDIR)
 8000996:	687b      	ldr	r3, [r7, #4]
 8000998:	79db      	ldrb	r3, [r3, #7]
 800099a:	2b01      	cmp	r3, #1
 800099c:	d10a      	bne.n	80009b4 <MCAL_SPI_Init+0x80>
		SPI_config->SPIx->CR1 |= (SPI_config->bidiOutputEnable << 14);
 800099e:	687b      	ldr	r3, [r7, #4]
 80009a0:	681b      	ldr	r3, [r3, #0]
 80009a2:	681a      	ldr	r2, [r3, #0]
 80009a4:	687b      	ldr	r3, [r7, #4]
 80009a6:	7a1b      	ldrb	r3, [r3, #8]
 80009a8:	039b      	lsls	r3, r3, #14
 80009aa:	4619      	mov	r1, r3
 80009ac:	687b      	ldr	r3, [r7, #4]
 80009ae:	681b      	ldr	r3, [r3, #0]
 80009b0:	430a      	orrs	r2, r1
 80009b2:	601a      	str	r2, [r3, #0]
	/*
		Bit 13 CRCEN: Hardware CRC calculation enable
			0: CRC calculation disabled
			1: CRC calculation enabled
	 */
	SPI_config->SPIx->CR1 |= (SPI_config->crcEnable << 13);
 80009b4:	687b      	ldr	r3, [r7, #4]
 80009b6:	681b      	ldr	r3, [r3, #0]
 80009b8:	681a      	ldr	r2, [r3, #0]
 80009ba:	687b      	ldr	r3, [r7, #4]
 80009bc:	7b9b      	ldrb	r3, [r3, #14]
 80009be:	035b      	lsls	r3, r3, #13
 80009c0:	4619      	mov	r1, r3
 80009c2:	687b      	ldr	r3, [r7, #4]
 80009c4:	681b      	ldr	r3, [r3, #0]
 80009c6:	430a      	orrs	r2, r1
 80009c8:	601a      	str	r2, [r3, #0]
	/*
		Bit 13 CRCEN: Hardware CRC calculation enable
			0: CRC calculation disabled
			1: CRC calculation enabled
	 */
	SPI_config->SPIx->CR1 |= (SPI_config->crcEnable << 13);
 80009ca:	687b      	ldr	r3, [r7, #4]
 80009cc:	681b      	ldr	r3, [r3, #0]
 80009ce:	681a      	ldr	r2, [r3, #0]
 80009d0:	687b      	ldr	r3, [r7, #4]
 80009d2:	7b9b      	ldrb	r3, [r3, #14]
 80009d4:	035b      	lsls	r3, r3, #13
 80009d6:	4619      	mov	r1, r3
 80009d8:	687b      	ldr	r3, [r7, #4]
 80009da:	681b      	ldr	r3, [r3, #0]
 80009dc:	430a      	orrs	r2, r1
 80009de:	601a      	str	r2, [r3, #0]
	/*
		Bit 11 DFF: Data frame format
			0: 8-bit data frame format is selected for transmission/reception
			1: 16-bit data frame format is selected for transmission/reception
	 */
	SPI_config->SPIx->CR1 |= (SPI_config->dataSize << 11);
 80009e0:	687b      	ldr	r3, [r7, #4]
 80009e2:	681b      	ldr	r3, [r3, #0]
 80009e4:	681a      	ldr	r2, [r3, #0]
 80009e6:	687b      	ldr	r3, [r7, #4]
 80009e8:	795b      	ldrb	r3, [r3, #5]
 80009ea:	02db      	lsls	r3, r3, #11
 80009ec:	4619      	mov	r1, r3
 80009ee:	687b      	ldr	r3, [r7, #4]
 80009f0:	681b      	ldr	r3, [r3, #0]
 80009f2:	430a      	orrs	r2, r1
 80009f4:	601a      	str	r2, [r3, #0]
			unidirectional mode. This bit is also useful in a multislave system in which this particular
			slave is not accessed, the output from the accessed slave is not corrupted.
			0: Full duplex (Transmit and receive)
			1: Output disabled (Receive-only mode)
	 */
	if(SPI_config->bidirectionalMode == SPI_BDM_2LINE_UNIDIR)  // Full duplex (2-line unidirectional)
 80009f6:	687b      	ldr	r3, [r7, #4]
 80009f8:	79db      	ldrb	r3, [r3, #7]
 80009fa:	2b00      	cmp	r3, #0
 80009fc:	d10a      	bne.n	8000a14 <MCAL_SPI_Init+0xe0>
		SPI_config->SPIx->CR1 |= (SPI_config->rxOnlyMode << 11);           // Receive-only mode for unidirectional
 80009fe:	687b      	ldr	r3, [r7, #4]
 8000a00:	681b      	ldr	r3, [r3, #0]
 8000a02:	681a      	ldr	r2, [r3, #0]
 8000a04:	687b      	ldr	r3, [r7, #4]
 8000a06:	7a5b      	ldrb	r3, [r3, #9]
 8000a08:	02db      	lsls	r3, r3, #11
 8000a0a:	4619      	mov	r1, r3
 8000a0c:	687b      	ldr	r3, [r7, #4]
 8000a0e:	681b      	ldr	r3, [r3, #0]
 8000a10:	430a      	orrs	r2, r1
 8000a12:	601a      	str	r2, [r3, #0]
		Bit 9 SSM: Software slave management
			When the SSM bit is set, the NSS pin input is replaced with the value from the SSI bit.
			0: Software slave management disabled
			1: Software slave management enabled
	 */
	SPI_config->SPIx->CR1 |= (SPI_config->ssm << 9);          				// Hardware or software NSS management
 8000a14:	687b      	ldr	r3, [r7, #4]
 8000a16:	681b      	ldr	r3, [r3, #0]
 8000a18:	681a      	ldr	r2, [r3, #0]
 8000a1a:	687b      	ldr	r3, [r7, #4]
 8000a1c:	7a9b      	ldrb	r3, [r3, #10]
 8000a1e:	025b      	lsls	r3, r3, #9
 8000a20:	4619      	mov	r1, r3
 8000a22:	687b      	ldr	r3, [r7, #4]
 8000a24:	681b      	ldr	r3, [r3, #0]
 8000a26:	430a      	orrs	r2, r1
 8000a28:	601a      	str	r2, [r3, #0]
	/*
		Bit 8 SSI: Internal slave select
			This bit has an effect only when the SSM bit is set. The value of this bit is forced onto the
			NSS pin and the IO value of the NSS pin is ignored.
	 */
	if(SPI_config->ssm == SPI_SSM_ENABLED){
 8000a2a:	687b      	ldr	r3, [r7, #4]
 8000a2c:	7a9b      	ldrb	r3, [r3, #10]
 8000a2e:	2b01      	cmp	r3, #1
 8000a30:	d118      	bne.n	8000a64 <MCAL_SPI_Init+0x130>
		// Software NSS management
		if(SPI_config->mode == SPI_MODE_MASTER){
 8000a32:	687b      	ldr	r3, [r7, #4]
 8000a34:	791b      	ldrb	r3, [r3, #4]
 8000a36:	2b01      	cmp	r3, #1
 8000a38:	d108      	bne.n	8000a4c <MCAL_SPI_Init+0x118>
			// Master mode => Set SSI pin HIGH
			SET_BIT(SPI_config->SPIx->CR1, 8);
 8000a3a:	687b      	ldr	r3, [r7, #4]
 8000a3c:	681b      	ldr	r3, [r3, #0]
 8000a3e:	681a      	ldr	r2, [r3, #0]
 8000a40:	687b      	ldr	r3, [r7, #4]
 8000a42:	681b      	ldr	r3, [r3, #0]
 8000a44:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8000a48:	601a      	str	r2, [r3, #0]
 8000a4a:	e00b      	b.n	8000a64 <MCAL_SPI_Init+0x130>
		}
		else if(SPI_config->mode == SPI_MODE_SLAVE){
 8000a4c:	687b      	ldr	r3, [r7, #4]
 8000a4e:	791b      	ldrb	r3, [r3, #4]
 8000a50:	2b00      	cmp	r3, #0
 8000a52:	d107      	bne.n	8000a64 <MCAL_SPI_Init+0x130>
			// Slve mode => Set SSI pin LOW
			CLEAR_BIT(SPI_config->SPIx->CR1, 8);
 8000a54:	687b      	ldr	r3, [r7, #4]
 8000a56:	681b      	ldr	r3, [r3, #0]
 8000a58:	681a      	ldr	r2, [r3, #0]
 8000a5a:	687b      	ldr	r3, [r7, #4]
 8000a5c:	681b      	ldr	r3, [r3, #0]
 8000a5e:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 8000a62:	601a      	str	r2, [r3, #0]
	/*
		Bit 7 LSBFIRST: Frame format
			0: MSB transmitted first
			1: LSB transmitted first
	 */
	SPI_config->SPIx->CR1 |= (SPI_config->frameFormat << 7);
 8000a64:	687b      	ldr	r3, [r7, #4]
 8000a66:	681b      	ldr	r3, [r3, #0]
 8000a68:	681a      	ldr	r2, [r3, #0]
 8000a6a:	687b      	ldr	r3, [r7, #4]
 8000a6c:	799b      	ldrb	r3, [r3, #6]
 8000a6e:	01db      	lsls	r3, r3, #7
 8000a70:	4619      	mov	r1, r3
 8000a72:	687b      	ldr	r3, [r7, #4]
 8000a74:	681b      	ldr	r3, [r3, #0]
 8000a76:	430a      	orrs	r2, r1
 8000a78:	601a      	str	r2, [r3, #0]
			100: fPCLK/32
			101: fPCLK/64
			110: fPCLK/128
			111: fPCLK/256
	 */
	if(SPI_config->mode == SPI_MODE_MASTER){    // Master mode
 8000a7a:	687b      	ldr	r3, [r7, #4]
 8000a7c:	791b      	ldrb	r3, [r3, #4]
 8000a7e:	2b01      	cmp	r3, #1
 8000a80:	d113      	bne.n	8000aaa <MCAL_SPI_Init+0x176>
		SPI_config->SPIx->CR1 &= ~(0b111 << 3);
 8000a82:	687b      	ldr	r3, [r7, #4]
 8000a84:	681b      	ldr	r3, [r3, #0]
 8000a86:	681a      	ldr	r2, [r3, #0]
 8000a88:	687b      	ldr	r3, [r7, #4]
 8000a8a:	681b      	ldr	r3, [r3, #0]
 8000a8c:	f022 0238 	bic.w	r2, r2, #56	; 0x38
 8000a90:	601a      	str	r2, [r3, #0]
		SPI_config->SPIx->CR1 |= ((SPI_config->baudRate & 0x7) << 3);
 8000a92:	687b      	ldr	r3, [r7, #4]
 8000a94:	681b      	ldr	r3, [r3, #0]
 8000a96:	6819      	ldr	r1, [r3, #0]
 8000a98:	687b      	ldr	r3, [r7, #4]
 8000a9a:	7b5b      	ldrb	r3, [r3, #13]
 8000a9c:	00db      	lsls	r3, r3, #3
 8000a9e:	f003 0238 	and.w	r2, r3, #56	; 0x38
 8000aa2:	687b      	ldr	r3, [r7, #4]
 8000aa4:	681b      	ldr	r3, [r3, #0]
 8000aa6:	430a      	orrs	r2, r1
 8000aa8:	601a      	str	r2, [r3, #0]
		Bit 2 SSOE: SS output enable
			0: SS output is disabled in master mode and the cell can work in multimaster configuration
			1: SS output is enabled in master mode and when the cell is enabled. The cell cannot work
			in a multimaster environment.
	 */
	SPI_config->SPIx->CR2 |= (SPI_config->ssoe << 2);
 8000aaa:	687b      	ldr	r3, [r7, #4]
 8000aac:	681b      	ldr	r3, [r3, #0]
 8000aae:	685a      	ldr	r2, [r3, #4]
 8000ab0:	687b      	ldr	r3, [r7, #4]
 8000ab2:	7d1b      	ldrb	r3, [r3, #20]
 8000ab4:	009b      	lsls	r3, r3, #2
 8000ab6:	4619      	mov	r1, r3
 8000ab8:	687b      	ldr	r3, [r7, #4]
 8000aba:	681b      	ldr	r3, [r3, #0]
 8000abc:	430a      	orrs	r2, r1
 8000abe:	605a      	str	r2, [r3, #4]
	/*
		Bit 7 TXEIE: Tx buffer empty interrupt enable
			0: TXE interrupt masked
			1: TXE interrupt not masked. Used to generate an interrupt request when the TXE flag is set.
	 */
	if(SPI_config->txeInterrupt == SPI_TXE_IRQ_ENABLED){
 8000ac0:	687b      	ldr	r3, [r7, #4]
 8000ac2:	7c9b      	ldrb	r3, [r3, #18]
 8000ac4:	2b01      	cmp	r3, #1
 8000ac6:	d10a      	bne.n	8000ade <MCAL_SPI_Init+0x1aa>
		SET_BIT(SPI_config->SPIx->CR2, 7);
 8000ac8:	687b      	ldr	r3, [r7, #4]
 8000aca:	681b      	ldr	r3, [r3, #0]
 8000acc:	685a      	ldr	r2, [r3, #4]
 8000ace:	687b      	ldr	r3, [r7, #4]
 8000ad0:	681b      	ldr	r3, [r3, #0]
 8000ad2:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8000ad6:	605a      	str	r2, [r3, #4]
		// Enable Global Interrupt
		MCAL_SPI_Enable_Global_Interrupt(SPI_config);
 8000ad8:	6878      	ldr	r0, [r7, #4]
 8000ada:	f7ff ff05 	bl	80008e8 <MCAL_SPI_Enable_Global_Interrupt>
	/*
		Bit 6 RXNEIE: RX buffer not empty interrupt enable
			0: RXNE interrupt masked
			1: RXNE interrupt not masked. Used to generate an interrupt request when the RXNE flag is.
	 */
	if(SPI_config->rxneInterrupt == SPI_RXNE_IRQ_ENABLED){
 8000ade:	687b      	ldr	r3, [r7, #4]
 8000ae0:	7cdb      	ldrb	r3, [r3, #19]
 8000ae2:	2b01      	cmp	r3, #1
 8000ae4:	d10a      	bne.n	8000afc <MCAL_SPI_Init+0x1c8>
		SET_BIT(SPI_config->SPIx->CR2, 6);
 8000ae6:	687b      	ldr	r3, [r7, #4]
 8000ae8:	681b      	ldr	r3, [r3, #0]
 8000aea:	685a      	ldr	r2, [r3, #4]
 8000aec:	687b      	ldr	r3, [r7, #4]
 8000aee:	681b      	ldr	r3, [r3, #0]
 8000af0:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8000af4:	605a      	str	r2, [r3, #4]
		// Enable Global Interrupt
		MCAL_SPI_Enable_Global_Interrupt(SPI_config);
 8000af6:	6878      	ldr	r0, [r7, #4]
 8000af8:	f7ff fef6 	bl	80008e8 <MCAL_SPI_Enable_Global_Interrupt>
	}

	// Set the function callback
	MCAL_SPI_SetCallBackFunction(SPI_config);
 8000afc:	6878      	ldr	r0, [r7, #4]
 8000afe:	f7ff fed1 	bl	80008a4 <MCAL_SPI_SetCallBackFunction>

	// Set GPIO pins for SPI
	MCAL_SPI_Set_GPIO_Pins(SPI_config);
 8000b02:	6878      	ldr	r0, [r7, #4]
 8000b04:	f7ff fda0 	bl	8000648 <MCAL_SPI_Set_GPIO_Pins>
	/*
	 	 Bit 6 SPE: SPI enable
			0: Peripheral disabled
			1: Peripheral enabled
	 */
	SET_BIT(SPI_config->SPIx->CR1, 6);
 8000b08:	687b      	ldr	r3, [r7, #4]
 8000b0a:	681b      	ldr	r3, [r3, #0]
 8000b0c:	681a      	ldr	r2, [r3, #0]
 8000b0e:	687b      	ldr	r3, [r7, #4]
 8000b10:	681b      	ldr	r3, [r3, #0]
 8000b12:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8000b16:	601a      	str	r2, [r3, #0]
}
 8000b18:	bf00      	nop
 8000b1a:	3708      	adds	r7, #8
 8000b1c:	46bd      	mov	sp, r7
 8000b1e:	bd80      	pop	{r7, pc}
 8000b20:	40013000 	.word	0x40013000
 8000b24:	40021000 	.word	0x40021000
 8000b28:	40003800 	.word	0x40003800

08000b2c <MCAL_SPI_Transmit>:


void MCAL_SPI_Transmit(SPI_Config_t *SPI_config, uint16 data){
 8000b2c:	b480      	push	{r7}
 8000b2e:	b083      	sub	sp, #12
 8000b30:	af00      	add	r7, sp, #0
 8000b32:	6078      	str	r0, [r7, #4]
 8000b34:	460b      	mov	r3, r1
 8000b36:	807b      	strh	r3, [r7, #2]
	/*
	 	 Bit 1 TXE: Transmit buffer empty
			0: Tx buffer not empty
			1: Tx buffer empty
	 */
	while(!(READ_BIT(SPI_config->SPIx->SR, 1)));
 8000b38:	bf00      	nop
 8000b3a:	687b      	ldr	r3, [r7, #4]
 8000b3c:	681b      	ldr	r3, [r3, #0]
 8000b3e:	689b      	ldr	r3, [r3, #8]
 8000b40:	085b      	lsrs	r3, r3, #1
 8000b42:	f003 0301 	and.w	r3, r3, #1
 8000b46:	2b00      	cmp	r3, #0
 8000b48:	d0f7      	beq.n	8000b3a <MCAL_SPI_Transmit+0xe>
	SPI_config->SPIx->DR = data;
 8000b4a:	687b      	ldr	r3, [r7, #4]
 8000b4c:	681b      	ldr	r3, [r3, #0]
 8000b4e:	887a      	ldrh	r2, [r7, #2]
 8000b50:	60da      	str	r2, [r3, #12]
}
 8000b52:	bf00      	nop
 8000b54:	370c      	adds	r7, #12
 8000b56:	46bd      	mov	sp, r7
 8000b58:	bc80      	pop	{r7}
 8000b5a:	4770      	bx	lr

08000b5c <MCAL_SPI_Recieve>:

uint16 MCAL_SPI_Recieve(SPI_Config_t *SPI_config){
 8000b5c:	b480      	push	{r7}
 8000b5e:	b085      	sub	sp, #20
 8000b60:	af00      	add	r7, sp, #0
 8000b62:	6078      	str	r0, [r7, #4]
	/*
		 Bit 0 RXNE: Receive buffer not empty
			0: Rx buffer empty
			1: Rx buffer not empty
	 */
	while(!(READ_BIT(SPI_config->SPIx->SR, 0)));
 8000b64:	bf00      	nop
 8000b66:	687b      	ldr	r3, [r7, #4]
 8000b68:	681b      	ldr	r3, [r3, #0]
 8000b6a:	689b      	ldr	r3, [r3, #8]
 8000b6c:	f003 0301 	and.w	r3, r3, #1
 8000b70:	2b00      	cmp	r3, #0
 8000b72:	d0f8      	beq.n	8000b66 <MCAL_SPI_Recieve+0xa>
	RecievedData = SPI_config->SPIx->DR;
 8000b74:	687b      	ldr	r3, [r7, #4]
 8000b76:	681b      	ldr	r3, [r3, #0]
 8000b78:	68db      	ldr	r3, [r3, #12]
 8000b7a:	81fb      	strh	r3, [r7, #14]
	return RecievedData;
 8000b7c:	89fb      	ldrh	r3, [r7, #14]
}
 8000b7e:	4618      	mov	r0, r3
 8000b80:	3714      	adds	r7, #20
 8000b82:	46bd      	mov	sp, r7
 8000b84:	bc80      	pop	{r7}
 8000b86:	4770      	bx	lr

08000b88 <MCAL_SPI_Transmit_Recieve>:

uint16 MCAL_SPI_Transmit_Recieve(SPI_Config_t *SPI_config, uint16 data){
 8000b88:	b580      	push	{r7, lr}
 8000b8a:	b084      	sub	sp, #16
 8000b8c:	af00      	add	r7, sp, #0
 8000b8e:	6078      	str	r0, [r7, #4]
 8000b90:	460b      	mov	r3, r1
 8000b92:	807b      	strh	r3, [r7, #2]
	uint16 RecievedData;
	MCAL_SPI_Transmit(SPI_config, data);
 8000b94:	887b      	ldrh	r3, [r7, #2]
 8000b96:	4619      	mov	r1, r3
 8000b98:	6878      	ldr	r0, [r7, #4]
 8000b9a:	f7ff ffc7 	bl	8000b2c <MCAL_SPI_Transmit>
	RecievedData = MCAL_SPI_Recieve(SPI_config);
 8000b9e:	6878      	ldr	r0, [r7, #4]
 8000ba0:	f7ff ffdc 	bl	8000b5c <MCAL_SPI_Recieve>
 8000ba4:	4603      	mov	r3, r0
 8000ba6:	81fb      	strh	r3, [r7, #14]
	return RecievedData;
 8000ba8:	89fb      	ldrh	r3, [r7, #14]
}
 8000baa:	4618      	mov	r0, r3
 8000bac:	3710      	adds	r7, #16
 8000bae:	46bd      	mov	sp, r7
 8000bb0:	bd80      	pop	{r7, pc}
	...

08000bb4 <SPI1_IRQHandler>:

/* ================================================================ */
/* ============================= ISR ============================== */
/* ================================================================ */

void SPI1_IRQHandler(void){
 8000bb4:	b580      	push	{r7, lr}
 8000bb6:	af00      	add	r7, sp, #0
	SPI_CallBackFunction[0]();
 8000bb8:	4b02      	ldr	r3, [pc, #8]	; (8000bc4 <SPI1_IRQHandler+0x10>)
 8000bba:	681b      	ldr	r3, [r3, #0]
 8000bbc:	4798      	blx	r3
}
 8000bbe:	bf00      	nop
 8000bc0:	bd80      	pop	{r7, pc}
 8000bc2:	bf00      	nop
 8000bc4:	20000094 	.word	0x20000094

08000bc8 <SPI2_IRQHandler>:

void SPI2_IRQHandler(void){
 8000bc8:	b580      	push	{r7, lr}
 8000bca:	af00      	add	r7, sp, #0
	SPI_CallBackFunction[1]();
 8000bcc:	4b02      	ldr	r3, [pc, #8]	; (8000bd8 <SPI2_IRQHandler+0x10>)
 8000bce:	685b      	ldr	r3, [r3, #4]
 8000bd0:	4798      	blx	r3
}
 8000bd2:	bf00      	nop
 8000bd4:	bd80      	pop	{r7, pc}
 8000bd6:	bf00      	nop
 8000bd8:	20000094 	.word	0x20000094

08000bdc <MCAL_USART_SetBaudRate>:
 * @Retval      None
 *
 * @Note        This function is static and intended for internal use only.
 *              The calculation for the baud rate register depends on the clock frequency.
 */
static void MCAL_USART_SetBaudRate(USART_Config_t *USART_Config, uint32 F_CLK){
 8000bdc:	b480      	push	{r7}
 8000bde:	b087      	sub	sp, #28
 8000be0:	af00      	add	r7, sp, #0
 8000be2:	6078      	str	r0, [r7, #4]
 8000be4:	6039      	str	r1, [r7, #0]
	/*
	     * USARTDIV = fCK / (16 * baud_rate)
	     * BRR[15:4] = Mantissa
	     * BRR[3:0] = Fraction
	 */
	uint32 USARTDIV = (F_CLK / (16UL * (USART_Config->baud_rate)));
 8000be6:	687b      	ldr	r3, [r7, #4]
 8000be8:	691b      	ldr	r3, [r3, #16]
 8000bea:	011b      	lsls	r3, r3, #4
 8000bec:	683a      	ldr	r2, [r7, #0]
 8000bee:	fbb2 f3f3 	udiv	r3, r2, r3
 8000bf2:	617b      	str	r3, [r7, #20]
	uint32 USARTDIV_MUL100 = ((F_CLK / (16UL * (USART_Config->baud_rate))) * 100);
 8000bf4:	687b      	ldr	r3, [r7, #4]
 8000bf6:	691b      	ldr	r3, [r3, #16]
 8000bf8:	011b      	lsls	r3, r3, #4
 8000bfa:	683a      	ldr	r2, [r7, #0]
 8000bfc:	fbb2 f3f3 	udiv	r3, r2, r3
 8000c00:	2264      	movs	r2, #100	; 0x64
 8000c02:	fb02 f303 	mul.w	r3, r2, r3
 8000c06:	613b      	str	r3, [r7, #16]
	uint16 DIV_Mantissa = USARTDIV;                       // Mantissa part
 8000c08:	697b      	ldr	r3, [r7, #20]
 8000c0a:	81fb      	strh	r3, [r7, #14]
	uint16 DIV_Mantissa_MUL100 = DIV_Mantissa * 100;
 8000c0c:	89fb      	ldrh	r3, [r7, #14]
 8000c0e:	461a      	mov	r2, r3
 8000c10:	0092      	lsls	r2, r2, #2
 8000c12:	4413      	add	r3, r2
 8000c14:	461a      	mov	r2, r3
 8000c16:	0091      	lsls	r1, r2, #2
 8000c18:	461a      	mov	r2, r3
 8000c1a:	460b      	mov	r3, r1
 8000c1c:	4413      	add	r3, r2
 8000c1e:	009b      	lsls	r3, r3, #2
 8000c20:	81bb      	strh	r3, [r7, #12]
	uint8 DIV_Fraction = ((USARTDIV_MUL100 - DIV_Mantissa_MUL100 ) * 16) / 100;       // Function part
 8000c22:	89bb      	ldrh	r3, [r7, #12]
 8000c24:	693a      	ldr	r2, [r7, #16]
 8000c26:	1ad3      	subs	r3, r2, r3
 8000c28:	011b      	lsls	r3, r3, #4
 8000c2a:	4a09      	ldr	r2, [pc, #36]	; (8000c50 <MCAL_USART_SetBaudRate+0x74>)
 8000c2c:	fba2 2303 	umull	r2, r3, r2, r3
 8000c30:	095b      	lsrs	r3, r3, #5
 8000c32:	72fb      	strb	r3, [r7, #11]

	USART_Config->USARTx->BRR = ((DIV_Mantissa << 4) | (DIV_Fraction & 0xF));
 8000c34:	89fb      	ldrh	r3, [r7, #14]
 8000c36:	011a      	lsls	r2, r3, #4
 8000c38:	7afb      	ldrb	r3, [r7, #11]
 8000c3a:	f003 030f 	and.w	r3, r3, #15
 8000c3e:	431a      	orrs	r2, r3
 8000c40:	687b      	ldr	r3, [r7, #4]
 8000c42:	681b      	ldr	r3, [r3, #0]
 8000c44:	609a      	str	r2, [r3, #8]
}
 8000c46:	bf00      	nop
 8000c48:	371c      	adds	r7, #28
 8000c4a:	46bd      	mov	sp, r7
 8000c4c:	bc80      	pop	{r7}
 8000c4e:	4770      	bx	lr
 8000c50:	51eb851f 	.word	0x51eb851f

08000c54 <MCAL_USART_GPIO_Set_Pins>:
 * @Retval      None
 *
 * @Note        This function is static and intended for internal use only.
 *              Ensure that the GPIO peripheral is properly initialized before calling this function.
 */
static void MCAL_USART_GPIO_Set_Pins(USART_Config_t *USART_Config) {
 8000c54:	b580      	push	{r7, lr}
 8000c56:	b084      	sub	sp, #16
 8000c58:	af00      	add	r7, sp, #0
 8000c5a:	6078      	str	r0, [r7, #4]
    GPIO_PinConfig_t pinConfig;

    if (USART_Config->USARTx == USART1) {
 8000c5c:	687b      	ldr	r3, [r7, #4]
 8000c5e:	681b      	ldr	r3, [r3, #0]
 8000c60:	4a5d      	ldr	r2, [pc, #372]	; (8000dd8 <MCAL_USART_GPIO_Set_Pins+0x184>)
 8000c62:	4293      	cmp	r3, r2
 8000c64:	d139      	bne.n	8000cda <MCAL_USART_GPIO_Set_Pins+0x86>
        // Configure Tx (PA9 or PB6)
        pinConfig.PinNum = GPIO_PIN9;  // Default: PA9
 8000c66:	2309      	movs	r3, #9
 8000c68:	733b      	strb	r3, [r7, #12]
        pinConfig.PinMode = GPIO_OUTPUT_10MHZ;
 8000c6a:	2301      	movs	r3, #1
 8000c6c:	737b      	strb	r3, [r7, #13]
        pinConfig.PinCNF = GPIO_CNF_AF_PUSH_PULL_OUTPUT;
 8000c6e:	2302      	movs	r3, #2
 8000c70:	73fb      	strb	r3, [r7, #15]
        MCAL_GPIO_Init(GPIOA, &pinConfig);
 8000c72:	f107 030c 	add.w	r3, r7, #12
 8000c76:	4619      	mov	r1, r3
 8000c78:	4858      	ldr	r0, [pc, #352]	; (8000ddc <MCAL_USART_GPIO_Set_Pins+0x188>)
 8000c7a:	f7ff fbdd 	bl	8000438 <MCAL_GPIO_Init>

        // Configure Rx (PA10 or PB7)
        pinConfig.PinNum = GPIO_PIN10;  // Default: PA10
 8000c7e:	230a      	movs	r3, #10
 8000c80:	733b      	strb	r3, [r7, #12]
        pinConfig.PinMode = GPIO_INPUT;
 8000c82:	2300      	movs	r3, #0
 8000c84:	737b      	strb	r3, [r7, #13]
        pinConfig.PinCNF = GPIO_CNF_FLOATING_INPUT;
 8000c86:	2301      	movs	r3, #1
 8000c88:	73fb      	strb	r3, [r7, #15]
        MCAL_GPIO_Init(GPIOA, &pinConfig);
 8000c8a:	f107 030c 	add.w	r3, r7, #12
 8000c8e:	4619      	mov	r1, r3
 8000c90:	4852      	ldr	r0, [pc, #328]	; (8000ddc <MCAL_USART_GPIO_Set_Pins+0x188>)
 8000c92:	f7ff fbd1 	bl	8000438 <MCAL_GPIO_Init>

        // Configure CTS (PA11) if enabled
        if (USART_Config->CTS_CTRL == USART_CTS_ENABLED) {
 8000c96:	687b      	ldr	r3, [r7, #4]
 8000c98:	7b1b      	ldrb	r3, [r3, #12]
 8000c9a:	2b01      	cmp	r3, #1
 8000c9c:	d10b      	bne.n	8000cb6 <MCAL_USART_GPIO_Set_Pins+0x62>
            pinConfig.PinNum = GPIO_PIN11;  // CTS: PA11
 8000c9e:	230b      	movs	r3, #11
 8000ca0:	733b      	strb	r3, [r7, #12]
            pinConfig.PinMode = GPIO_INPUT;
 8000ca2:	2300      	movs	r3, #0
 8000ca4:	737b      	strb	r3, [r7, #13]
            pinConfig.PinCNF = GPIO_CNF_FLOATING_INPUT;
 8000ca6:	2301      	movs	r3, #1
 8000ca8:	73fb      	strb	r3, [r7, #15]
            MCAL_GPIO_Init(GPIOA, &pinConfig);
 8000caa:	f107 030c 	add.w	r3, r7, #12
 8000cae:	4619      	mov	r1, r3
 8000cb0:	484a      	ldr	r0, [pc, #296]	; (8000ddc <MCAL_USART_GPIO_Set_Pins+0x188>)
 8000cb2:	f7ff fbc1 	bl	8000438 <MCAL_GPIO_Init>
        }

        // Configure RTS (PA12) if enabled
        if (USART_Config->RTS_CTRL == USART_RTS_ENABLED) {
 8000cb6:	687b      	ldr	r3, [r7, #4]
 8000cb8:	7b5b      	ldrb	r3, [r3, #13]
 8000cba:	2b01      	cmp	r3, #1
 8000cbc:	f040 8088 	bne.w	8000dd0 <MCAL_USART_GPIO_Set_Pins+0x17c>
            pinConfig.PinNum = GPIO_PIN12;  // RTS: PA12
 8000cc0:	230c      	movs	r3, #12
 8000cc2:	733b      	strb	r3, [r7, #12]
            pinConfig.PinMode = GPIO_OUTPUT_10MHZ;
 8000cc4:	2301      	movs	r3, #1
 8000cc6:	737b      	strb	r3, [r7, #13]
            pinConfig.PinCNF = GPIO_CNF_AF_PUSH_PULL_OUTPUT;
 8000cc8:	2302      	movs	r3, #2
 8000cca:	73fb      	strb	r3, [r7, #15]
            MCAL_GPIO_Init(GPIOA, &pinConfig);
 8000ccc:	f107 030c 	add.w	r3, r7, #12
 8000cd0:	4619      	mov	r1, r3
 8000cd2:	4842      	ldr	r0, [pc, #264]	; (8000ddc <MCAL_USART_GPIO_Set_Pins+0x188>)
 8000cd4:	f7ff fbb0 	bl	8000438 <MCAL_GPIO_Init>
            pinConfig.PinMode = GPIO_OUTPUT_10MHZ;
            pinConfig.PinCNF = GPIO_CNF_AF_PUSH_PULL_OUTPUT;
            MCAL_GPIO_Init(GPIOB, &pinConfig);
        }
    }
}
 8000cd8:	e07a      	b.n	8000dd0 <MCAL_USART_GPIO_Set_Pins+0x17c>
    else if (USART_Config->USARTx == USART2) {
 8000cda:	687b      	ldr	r3, [r7, #4]
 8000cdc:	681b      	ldr	r3, [r3, #0]
 8000cde:	4a40      	ldr	r2, [pc, #256]	; (8000de0 <MCAL_USART_GPIO_Set_Pins+0x18c>)
 8000ce0:	4293      	cmp	r3, r2
 8000ce2:	d138      	bne.n	8000d56 <MCAL_USART_GPIO_Set_Pins+0x102>
        pinConfig.PinNum = GPIO_PIN2;  // Tx: PA2
 8000ce4:	2302      	movs	r3, #2
 8000ce6:	733b      	strb	r3, [r7, #12]
        pinConfig.PinMode = GPIO_OUTPUT_10MHZ;
 8000ce8:	2301      	movs	r3, #1
 8000cea:	737b      	strb	r3, [r7, #13]
        pinConfig.PinCNF = GPIO_CNF_AF_PUSH_PULL_OUTPUT;
 8000cec:	2302      	movs	r3, #2
 8000cee:	73fb      	strb	r3, [r7, #15]
        MCAL_GPIO_Init(GPIOA, &pinConfig);
 8000cf0:	f107 030c 	add.w	r3, r7, #12
 8000cf4:	4619      	mov	r1, r3
 8000cf6:	4839      	ldr	r0, [pc, #228]	; (8000ddc <MCAL_USART_GPIO_Set_Pins+0x188>)
 8000cf8:	f7ff fb9e 	bl	8000438 <MCAL_GPIO_Init>
        pinConfig.PinNum = GPIO_PIN3;  // Rx: PA3
 8000cfc:	2303      	movs	r3, #3
 8000cfe:	733b      	strb	r3, [r7, #12]
        pinConfig.PinMode = GPIO_INPUT;
 8000d00:	2300      	movs	r3, #0
 8000d02:	737b      	strb	r3, [r7, #13]
        pinConfig.PinCNF = GPIO_CNF_FLOATING_INPUT;
 8000d04:	2301      	movs	r3, #1
 8000d06:	73fb      	strb	r3, [r7, #15]
        MCAL_GPIO_Init(GPIOA, &pinConfig);
 8000d08:	f107 030c 	add.w	r3, r7, #12
 8000d0c:	4619      	mov	r1, r3
 8000d0e:	4833      	ldr	r0, [pc, #204]	; (8000ddc <MCAL_USART_GPIO_Set_Pins+0x188>)
 8000d10:	f7ff fb92 	bl	8000438 <MCAL_GPIO_Init>
        if (USART_Config->CTS_CTRL == USART_CTS_ENABLED) {
 8000d14:	687b      	ldr	r3, [r7, #4]
 8000d16:	7b1b      	ldrb	r3, [r3, #12]
 8000d18:	2b01      	cmp	r3, #1
 8000d1a:	d10b      	bne.n	8000d34 <MCAL_USART_GPIO_Set_Pins+0xe0>
            pinConfig.PinNum = GPIO_PIN0;  // CTS: PA0
 8000d1c:	2300      	movs	r3, #0
 8000d1e:	733b      	strb	r3, [r7, #12]
            pinConfig.PinMode = GPIO_INPUT;
 8000d20:	2300      	movs	r3, #0
 8000d22:	737b      	strb	r3, [r7, #13]
            pinConfig.PinCNF = GPIO_CNF_FLOATING_INPUT;
 8000d24:	2301      	movs	r3, #1
 8000d26:	73fb      	strb	r3, [r7, #15]
            MCAL_GPIO_Init(GPIOA, &pinConfig);
 8000d28:	f107 030c 	add.w	r3, r7, #12
 8000d2c:	4619      	mov	r1, r3
 8000d2e:	482b      	ldr	r0, [pc, #172]	; (8000ddc <MCAL_USART_GPIO_Set_Pins+0x188>)
 8000d30:	f7ff fb82 	bl	8000438 <MCAL_GPIO_Init>
        if (USART_Config->RTS_CTRL == USART_RTS_ENABLED) {
 8000d34:	687b      	ldr	r3, [r7, #4]
 8000d36:	7b5b      	ldrb	r3, [r3, #13]
 8000d38:	2b01      	cmp	r3, #1
 8000d3a:	d149      	bne.n	8000dd0 <MCAL_USART_GPIO_Set_Pins+0x17c>
            pinConfig.PinNum = GPIO_PIN1;  // RTS: PA1
 8000d3c:	2301      	movs	r3, #1
 8000d3e:	733b      	strb	r3, [r7, #12]
            pinConfig.PinMode = GPIO_OUTPUT_10MHZ;
 8000d40:	2301      	movs	r3, #1
 8000d42:	737b      	strb	r3, [r7, #13]
            pinConfig.PinCNF = GPIO_CNF_AF_PUSH_PULL_OUTPUT;
 8000d44:	2302      	movs	r3, #2
 8000d46:	73fb      	strb	r3, [r7, #15]
            MCAL_GPIO_Init(GPIOA, &pinConfig);
 8000d48:	f107 030c 	add.w	r3, r7, #12
 8000d4c:	4619      	mov	r1, r3
 8000d4e:	4823      	ldr	r0, [pc, #140]	; (8000ddc <MCAL_USART_GPIO_Set_Pins+0x188>)
 8000d50:	f7ff fb72 	bl	8000438 <MCAL_GPIO_Init>
}
 8000d54:	e03c      	b.n	8000dd0 <MCAL_USART_GPIO_Set_Pins+0x17c>
    else if (USART_Config->USARTx == USART3) {
 8000d56:	687b      	ldr	r3, [r7, #4]
 8000d58:	681b      	ldr	r3, [r3, #0]
 8000d5a:	4a22      	ldr	r2, [pc, #136]	; (8000de4 <MCAL_USART_GPIO_Set_Pins+0x190>)
 8000d5c:	4293      	cmp	r3, r2
 8000d5e:	d137      	bne.n	8000dd0 <MCAL_USART_GPIO_Set_Pins+0x17c>
        pinConfig.PinNum = GPIO_PIN10;  // Tx: PB10
 8000d60:	230a      	movs	r3, #10
 8000d62:	733b      	strb	r3, [r7, #12]
        pinConfig.PinMode = GPIO_OUTPUT_10MHZ;
 8000d64:	2301      	movs	r3, #1
 8000d66:	737b      	strb	r3, [r7, #13]
        pinConfig.PinCNF = GPIO_CNF_AF_PUSH_PULL_OUTPUT;
 8000d68:	2302      	movs	r3, #2
 8000d6a:	73fb      	strb	r3, [r7, #15]
        MCAL_GPIO_Init(GPIOB, &pinConfig);
 8000d6c:	f107 030c 	add.w	r3, r7, #12
 8000d70:	4619      	mov	r1, r3
 8000d72:	481d      	ldr	r0, [pc, #116]	; (8000de8 <MCAL_USART_GPIO_Set_Pins+0x194>)
 8000d74:	f7ff fb60 	bl	8000438 <MCAL_GPIO_Init>
        pinConfig.PinNum = GPIO_PIN11;  // Rx: PB11
 8000d78:	230b      	movs	r3, #11
 8000d7a:	733b      	strb	r3, [r7, #12]
        pinConfig.PinMode = GPIO_INPUT;
 8000d7c:	2300      	movs	r3, #0
 8000d7e:	737b      	strb	r3, [r7, #13]
        pinConfig.PinCNF = GPIO_CNF_FLOATING_INPUT;
 8000d80:	2301      	movs	r3, #1
 8000d82:	73fb      	strb	r3, [r7, #15]
        MCAL_GPIO_Init(GPIOB, &pinConfig);
 8000d84:	f107 030c 	add.w	r3, r7, #12
 8000d88:	4619      	mov	r1, r3
 8000d8a:	4817      	ldr	r0, [pc, #92]	; (8000de8 <MCAL_USART_GPIO_Set_Pins+0x194>)
 8000d8c:	f7ff fb54 	bl	8000438 <MCAL_GPIO_Init>
        if (USART_Config->CTS_CTRL == USART_CTS_ENABLED) {
 8000d90:	687b      	ldr	r3, [r7, #4]
 8000d92:	7b1b      	ldrb	r3, [r3, #12]
 8000d94:	2b01      	cmp	r3, #1
 8000d96:	d10b      	bne.n	8000db0 <MCAL_USART_GPIO_Set_Pins+0x15c>
            pinConfig.PinNum = GPIO_PIN13;  // CTS: PB13
 8000d98:	230d      	movs	r3, #13
 8000d9a:	733b      	strb	r3, [r7, #12]
            pinConfig.PinMode = GPIO_INPUT;
 8000d9c:	2300      	movs	r3, #0
 8000d9e:	737b      	strb	r3, [r7, #13]
            pinConfig.PinCNF = GPIO_CNF_FLOATING_INPUT;
 8000da0:	2301      	movs	r3, #1
 8000da2:	73fb      	strb	r3, [r7, #15]
            MCAL_GPIO_Init(GPIOB, &pinConfig);
 8000da4:	f107 030c 	add.w	r3, r7, #12
 8000da8:	4619      	mov	r1, r3
 8000daa:	480f      	ldr	r0, [pc, #60]	; (8000de8 <MCAL_USART_GPIO_Set_Pins+0x194>)
 8000dac:	f7ff fb44 	bl	8000438 <MCAL_GPIO_Init>
        if (USART_Config->RTS_CTRL == USART_RTS_ENABLED) {
 8000db0:	687b      	ldr	r3, [r7, #4]
 8000db2:	7b5b      	ldrb	r3, [r3, #13]
 8000db4:	2b01      	cmp	r3, #1
 8000db6:	d10b      	bne.n	8000dd0 <MCAL_USART_GPIO_Set_Pins+0x17c>
            pinConfig.PinNum = GPIO_PIN14;  // RTS: PB14
 8000db8:	230e      	movs	r3, #14
 8000dba:	733b      	strb	r3, [r7, #12]
            pinConfig.PinMode = GPIO_OUTPUT_10MHZ;
 8000dbc:	2301      	movs	r3, #1
 8000dbe:	737b      	strb	r3, [r7, #13]
            pinConfig.PinCNF = GPIO_CNF_AF_PUSH_PULL_OUTPUT;
 8000dc0:	2302      	movs	r3, #2
 8000dc2:	73fb      	strb	r3, [r7, #15]
            MCAL_GPIO_Init(GPIOB, &pinConfig);
 8000dc4:	f107 030c 	add.w	r3, r7, #12
 8000dc8:	4619      	mov	r1, r3
 8000dca:	4807      	ldr	r0, [pc, #28]	; (8000de8 <MCAL_USART_GPIO_Set_Pins+0x194>)
 8000dcc:	f7ff fb34 	bl	8000438 <MCAL_GPIO_Init>
}
 8000dd0:	bf00      	nop
 8000dd2:	3710      	adds	r7, #16
 8000dd4:	46bd      	mov	sp, r7
 8000dd6:	bd80      	pop	{r7, pc}
 8000dd8:	40013800 	.word	0x40013800
 8000ddc:	40010800 	.word	0x40010800
 8000de0:	40004400 	.word	0x40004400
 8000de4:	40004800 	.word	0x40004800
 8000de8:	40010c00 	.word	0x40010c00

08000dec <MCAL_USART_Init>:
 *
 * @Retval      None
 *
 * @Note        This function must be called before using any USART transmit or receive APIs.
 */
void MCAL_USART_Init(USART_Config_t *USART_Config){
 8000dec:	b580      	push	{r7, lr}
 8000dee:	b084      	sub	sp, #16
 8000df0:	af00      	add	r7, sp, #0
 8000df2:	6078      	str	r0, [r7, #4]
	uint32 F_CLK;

	// Enable the clock for configured USART (1, 2, 3)
	if(USART_Config->USARTx == USART1){
 8000df4:	687b      	ldr	r3, [r7, #4]
 8000df6:	681b      	ldr	r3, [r3, #0]
 8000df8:	4a76      	ldr	r2, [pc, #472]	; (8000fd4 <MCAL_USART_Init+0x1e8>)
 8000dfa:	4293      	cmp	r3, r2
 8000dfc:	d10c      	bne.n	8000e18 <MCAL_USART_Init+0x2c>
		USART1_CLK_EN();
 8000dfe:	4b76      	ldr	r3, [pc, #472]	; (8000fd8 <MCAL_USART_Init+0x1ec>)
 8000e00:	699b      	ldr	r3, [r3, #24]
 8000e02:	4a75      	ldr	r2, [pc, #468]	; (8000fd8 <MCAL_USART_Init+0x1ec>)
 8000e04:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8000e08:	6193      	str	r3, [r2, #24]
		// PCLK2 for USART1
		Global_USART_Config[0] = USART_Config;
 8000e0a:	4a74      	ldr	r2, [pc, #464]	; (8000fdc <MCAL_USART_Init+0x1f0>)
 8000e0c:	687b      	ldr	r3, [r7, #4]
 8000e0e:	6013      	str	r3, [r2, #0]
		F_CLK = MCAL_RCC_GetPCLK2_Freq();
 8000e10:	f7ff fbfc 	bl	800060c <MCAL_RCC_GetPCLK2_Freq>
 8000e14:	60f8      	str	r0, [r7, #12]
 8000e16:	e022      	b.n	8000e5e <MCAL_USART_Init+0x72>
	}
	else if(USART_Config->USARTx == USART2){
 8000e18:	687b      	ldr	r3, [r7, #4]
 8000e1a:	681b      	ldr	r3, [r3, #0]
 8000e1c:	4a70      	ldr	r2, [pc, #448]	; (8000fe0 <MCAL_USART_Init+0x1f4>)
 8000e1e:	4293      	cmp	r3, r2
 8000e20:	d10c      	bne.n	8000e3c <MCAL_USART_Init+0x50>
		USART2_CLK_EN();
 8000e22:	4b6d      	ldr	r3, [pc, #436]	; (8000fd8 <MCAL_USART_Init+0x1ec>)
 8000e24:	699b      	ldr	r3, [r3, #24]
 8000e26:	4a6c      	ldr	r2, [pc, #432]	; (8000fd8 <MCAL_USART_Init+0x1ec>)
 8000e28:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8000e2c:	6193      	str	r3, [r2, #24]
		// PCLK1 for USART2
		F_CLK = MCAL_RCC_GetPCLK1_Freq();
 8000e2e:	f7ff fbcf 	bl	80005d0 <MCAL_RCC_GetPCLK1_Freq>
 8000e32:	60f8      	str	r0, [r7, #12]
		Global_USART_Config[1] = USART_Config;
 8000e34:	4a69      	ldr	r2, [pc, #420]	; (8000fdc <MCAL_USART_Init+0x1f0>)
 8000e36:	687b      	ldr	r3, [r7, #4]
 8000e38:	6053      	str	r3, [r2, #4]
 8000e3a:	e010      	b.n	8000e5e <MCAL_USART_Init+0x72>
	}
	else if(USART_Config->USARTx == USART3){
 8000e3c:	687b      	ldr	r3, [r7, #4]
 8000e3e:	681b      	ldr	r3, [r3, #0]
 8000e40:	4a68      	ldr	r2, [pc, #416]	; (8000fe4 <MCAL_USART_Init+0x1f8>)
 8000e42:	4293      	cmp	r3, r2
 8000e44:	d10b      	bne.n	8000e5e <MCAL_USART_Init+0x72>
		USART3_CLK_EN();
 8000e46:	4b64      	ldr	r3, [pc, #400]	; (8000fd8 <MCAL_USART_Init+0x1ec>)
 8000e48:	699b      	ldr	r3, [r3, #24]
 8000e4a:	4a63      	ldr	r2, [pc, #396]	; (8000fd8 <MCAL_USART_Init+0x1ec>)
 8000e4c:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 8000e50:	6193      	str	r3, [r2, #24]
		// PCLK1 for USART3
		F_CLK = MCAL_RCC_GetPCLK1_Freq();
 8000e52:	f7ff fbbd 	bl	80005d0 <MCAL_RCC_GetPCLK1_Freq>
 8000e56:	60f8      	str	r0, [r7, #12]
		Global_USART_Config[2] = USART_Config;
 8000e58:	4a60      	ldr	r2, [pc, #384]	; (8000fdc <MCAL_USART_Init+0x1f0>)
 8000e5a:	687b      	ldr	r3, [r7, #4]
 8000e5c:	6093      	str	r3, [r2, #8]
	}

	// Configure the GPIO pins for Tx, Rx, CTS, RTS
	MCAL_USART_GPIO_Set_Pins(USART_Config);
 8000e5e:	6878      	ldr	r0, [r7, #4]
 8000e60:	f7ff fef8 	bl	8000c54 <MCAL_USART_GPIO_Set_Pins>

	// Enable the USART by writing the UE bit in USART_CR1 register to 1
	SET_BIT(USART_Config->USARTx->CR1, 13);
 8000e64:	687b      	ldr	r3, [r7, #4]
 8000e66:	681b      	ldr	r3, [r3, #0]
 8000e68:	68da      	ldr	r2, [r3, #12]
 8000e6a:	687b      	ldr	r3, [r7, #4]
 8000e6c:	681b      	ldr	r3, [r3, #0]
 8000e6e:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 8000e72:	60da      	str	r2, [r3, #12]

	// Disable/Enable TX/RX
	if(USART_Config->TxMode == USART_TX_ENABLED)
 8000e74:	687b      	ldr	r3, [r7, #4]
 8000e76:	7a1b      	ldrb	r3, [r3, #8]
 8000e78:	2b01      	cmp	r3, #1
 8000e7a:	d107      	bne.n	8000e8c <MCAL_USART_Init+0xa0>
		SET_BIT(USART_Config->USARTx->CR1, 3);
 8000e7c:	687b      	ldr	r3, [r7, #4]
 8000e7e:	681b      	ldr	r3, [r3, #0]
 8000e80:	68da      	ldr	r2, [r3, #12]
 8000e82:	687b      	ldr	r3, [r7, #4]
 8000e84:	681b      	ldr	r3, [r3, #0]
 8000e86:	f042 0208 	orr.w	r2, r2, #8
 8000e8a:	60da      	str	r2, [r3, #12]
	if(USART_Config->TxMode == USART_RX_ENABLED)
 8000e8c:	687b      	ldr	r3, [r7, #4]
 8000e8e:	7a1b      	ldrb	r3, [r3, #8]
 8000e90:	2b01      	cmp	r3, #1
 8000e92:	d107      	bne.n	8000ea4 <MCAL_USART_Init+0xb8>
		SET_BIT(USART_Config->USARTx->CR1, 2);
 8000e94:	687b      	ldr	r3, [r7, #4]
 8000e96:	681b      	ldr	r3, [r3, #0]
 8000e98:	68da      	ldr	r2, [r3, #12]
 8000e9a:	687b      	ldr	r3, [r7, #4]
 8000e9c:	681b      	ldr	r3, [r3, #0]
 8000e9e:	f042 0204 	orr.w	r2, r2, #4
 8000ea2:	60da      	str	r2, [r3, #12]

	// Set the Word Length
	if(USART_Config->wordLength == USART_9_BIT_WORD_LENGTH)
 8000ea4:	687b      	ldr	r3, [r7, #4]
 8000ea6:	791b      	ldrb	r3, [r3, #4]
 8000ea8:	2b01      	cmp	r3, #1
 8000eaa:	d108      	bne.n	8000ebe <MCAL_USART_Init+0xd2>
		SET_BIT(USART_Config->USARTx->CR1, 12);   // 9 bit data
 8000eac:	687b      	ldr	r3, [r7, #4]
 8000eae:	681b      	ldr	r3, [r3, #0]
 8000eb0:	68da      	ldr	r2, [r3, #12]
 8000eb2:	687b      	ldr	r3, [r7, #4]
 8000eb4:	681b      	ldr	r3, [r3, #0]
 8000eb6:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8000eba:	60da      	str	r2, [r3, #12]
 8000ebc:	e007      	b.n	8000ece <MCAL_USART_Init+0xe2>
	else
		CLEAR_BIT(USART_Config->USARTx->CR1, 12); // 8 bit data
 8000ebe:	687b      	ldr	r3, [r7, #4]
 8000ec0:	681b      	ldr	r3, [r3, #0]
 8000ec2:	68da      	ldr	r2, [r3, #12]
 8000ec4:	687b      	ldr	r3, [r7, #4]
 8000ec6:	681b      	ldr	r3, [r3, #0]
 8000ec8:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 8000ecc:	60da      	str	r2, [r3, #12]

	// Enable/Disable Parity bit
	if(USART_Config->parityMode == USART_ENABLED_PARITY)
 8000ece:	687b      	ldr	r3, [r7, #4]
 8000ed0:	795b      	ldrb	r3, [r3, #5]
 8000ed2:	2b01      	cmp	r3, #1
 8000ed4:	d108      	bne.n	8000ee8 <MCAL_USART_Init+0xfc>
		SET_BIT(USART_Config->USARTx->CR1, 10);    // Enable Parity
 8000ed6:	687b      	ldr	r3, [r7, #4]
 8000ed8:	681b      	ldr	r3, [r3, #0]
 8000eda:	68da      	ldr	r2, [r3, #12]
 8000edc:	687b      	ldr	r3, [r7, #4]
 8000ede:	681b      	ldr	r3, [r3, #0]
 8000ee0:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8000ee4:	60da      	str	r2, [r3, #12]
 8000ee6:	e007      	b.n	8000ef8 <MCAL_USART_Init+0x10c>
	else
		CLEAR_BIT(USART_Config->USARTx->CR1, 10);  // Disable Parity
 8000ee8:	687b      	ldr	r3, [r7, #4]
 8000eea:	681b      	ldr	r3, [r3, #0]
 8000eec:	68da      	ldr	r2, [r3, #12]
 8000eee:	687b      	ldr	r3, [r7, #4]
 8000ef0:	681b      	ldr	r3, [r3, #0]
 8000ef2:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8000ef6:	60da      	str	r2, [r3, #12]

	// Enable/Disable Hardware Flow Control (CTS, RTS)
	if(USART_Config->CTS_CTRL == USART_CTS_ENABLED)
 8000ef8:	687b      	ldr	r3, [r7, #4]
 8000efa:	7b1b      	ldrb	r3, [r3, #12]
 8000efc:	2b01      	cmp	r3, #1
 8000efe:	d107      	bne.n	8000f10 <MCAL_USART_Init+0x124>
		SET_BIT(USART_Config->USARTx->CR3, 9);    // Enable CTS Pin
 8000f00:	687b      	ldr	r3, [r7, #4]
 8000f02:	681b      	ldr	r3, [r3, #0]
 8000f04:	695a      	ldr	r2, [r3, #20]
 8000f06:	687b      	ldr	r3, [r7, #4]
 8000f08:	681b      	ldr	r3, [r3, #0]
 8000f0a:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8000f0e:	615a      	str	r2, [r3, #20]
	if(USART_Config->RTS_CTRL == USART_RTS_ENABLED)
 8000f10:	687b      	ldr	r3, [r7, #4]
 8000f12:	7b5b      	ldrb	r3, [r3, #13]
 8000f14:	2b01      	cmp	r3, #1
 8000f16:	d107      	bne.n	8000f28 <MCAL_USART_Init+0x13c>
		SET_BIT(USART_Config->USARTx->CR3, 8);  // Enable RTS Pin
 8000f18:	687b      	ldr	r3, [r7, #4]
 8000f1a:	681b      	ldr	r3, [r3, #0]
 8000f1c:	695a      	ldr	r2, [r3, #20]
 8000f1e:	687b      	ldr	r3, [r7, #4]
 8000f20:	681b      	ldr	r3, [r3, #0]
 8000f22:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8000f26:	615a      	str	r2, [r3, #20]

	// Configure the number of stop bits
	USART_Config->USARTx->CR2 |= (USART_Config->stopBits << 12);
 8000f28:	687b      	ldr	r3, [r7, #4]
 8000f2a:	681b      	ldr	r3, [r3, #0]
 8000f2c:	691a      	ldr	r2, [r3, #16]
 8000f2e:	687b      	ldr	r3, [r7, #4]
 8000f30:	79db      	ldrb	r3, [r3, #7]
 8000f32:	031b      	lsls	r3, r3, #12
 8000f34:	4619      	mov	r1, r3
 8000f36:	687b      	ldr	r3, [r7, #4]
 8000f38:	681b      	ldr	r3, [r3, #0]
 8000f3a:	430a      	orrs	r2, r1
 8000f3c:	611a      	str	r2, [r3, #16]

	// Configure the BaudRate
	MCAL_USART_SetBaudRate(USART_Config, F_CLK);
 8000f3e:	68f9      	ldr	r1, [r7, #12]
 8000f40:	6878      	ldr	r0, [r7, #4]
 8000f42:	f7ff fe4b 	bl	8000bdc <MCAL_USART_SetBaudRate>

	// Enable/Disable Interrupt
	if((USART_Config->Tx_Interrupt_Enable == USART_TX_INTERRUPT_ENABLED) || (USART_Config->Rx_Interrupt_Enable == USART_RX_INTERRUPT_ENABLED)){
 8000f46:	687b      	ldr	r3, [r7, #4]
 8000f48:	7a9b      	ldrb	r3, [r3, #10]
 8000f4a:	2b01      	cmp	r3, #1
 8000f4c:	d003      	beq.n	8000f56 <MCAL_USART_Init+0x16a>
 8000f4e:	687b      	ldr	r3, [r7, #4]
 8000f50:	7adb      	ldrb	r3, [r3, #11]
 8000f52:	2b01      	cmp	r3, #1
 8000f54:	d13a      	bne.n	8000fcc <MCAL_USART_Init+0x1e0>
		// Enable NVIC for USARTx IRQ
		if(USART_Config->USARTx == USART1){
 8000f56:	687b      	ldr	r3, [r7, #4]
 8000f58:	681b      	ldr	r3, [r3, #0]
 8000f5a:	4a1e      	ldr	r2, [pc, #120]	; (8000fd4 <MCAL_USART_Init+0x1e8>)
 8000f5c:	4293      	cmp	r3, r2
 8000f5e:	d106      	bne.n	8000f6e <MCAL_USART_Init+0x182>
			NVIC_IRQ_ENABLE(USART1_IRQ);
 8000f60:	4b21      	ldr	r3, [pc, #132]	; (8000fe8 <MCAL_USART_Init+0x1fc>)
 8000f62:	681b      	ldr	r3, [r3, #0]
 8000f64:	4a20      	ldr	r2, [pc, #128]	; (8000fe8 <MCAL_USART_Init+0x1fc>)
 8000f66:	f043 0320 	orr.w	r3, r3, #32
 8000f6a:	6013      	str	r3, [r2, #0]
 8000f6c:	e016      	b.n	8000f9c <MCAL_USART_Init+0x1b0>
		}
		else if(USART_Config->USARTx == USART2){
 8000f6e:	687b      	ldr	r3, [r7, #4]
 8000f70:	681b      	ldr	r3, [r3, #0]
 8000f72:	4a1b      	ldr	r2, [pc, #108]	; (8000fe0 <MCAL_USART_Init+0x1f4>)
 8000f74:	4293      	cmp	r3, r2
 8000f76:	d106      	bne.n	8000f86 <MCAL_USART_Init+0x19a>
			NVIC_IRQ_ENABLE(USART2_IRQ);
 8000f78:	4b1b      	ldr	r3, [pc, #108]	; (8000fe8 <MCAL_USART_Init+0x1fc>)
 8000f7a:	681b      	ldr	r3, [r3, #0]
 8000f7c:	4a1a      	ldr	r2, [pc, #104]	; (8000fe8 <MCAL_USART_Init+0x1fc>)
 8000f7e:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8000f82:	6013      	str	r3, [r2, #0]
 8000f84:	e00a      	b.n	8000f9c <MCAL_USART_Init+0x1b0>
		}
		else if(USART_Config->USARTx == USART3){
 8000f86:	687b      	ldr	r3, [r7, #4]
 8000f88:	681b      	ldr	r3, [r3, #0]
 8000f8a:	4a16      	ldr	r2, [pc, #88]	; (8000fe4 <MCAL_USART_Init+0x1f8>)
 8000f8c:	4293      	cmp	r3, r2
 8000f8e:	d105      	bne.n	8000f9c <MCAL_USART_Init+0x1b0>
			NVIC_IRQ_ENABLE(USART3_IRQ);
 8000f90:	4b15      	ldr	r3, [pc, #84]	; (8000fe8 <MCAL_USART_Init+0x1fc>)
 8000f92:	681b      	ldr	r3, [r3, #0]
 8000f94:	4a14      	ldr	r2, [pc, #80]	; (8000fe8 <MCAL_USART_Init+0x1fc>)
 8000f96:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8000f9a:	6013      	str	r3, [r2, #0]
		}

		// Enable Tx/Rx Interrupt Based on configuration
		if(USART_Config->Tx_Interrupt_Enable == USART_TX_INTERRUPT_ENABLED)
 8000f9c:	687b      	ldr	r3, [r7, #4]
 8000f9e:	7a9b      	ldrb	r3, [r3, #10]
 8000fa0:	2b01      	cmp	r3, #1
 8000fa2:	d107      	bne.n	8000fb4 <MCAL_USART_Init+0x1c8>
			SET_BIT(USART_Config->USARTx->CR1, 6);    // TCIE: Transmission complete interrupt enable
 8000fa4:	687b      	ldr	r3, [r7, #4]
 8000fa6:	681b      	ldr	r3, [r3, #0]
 8000fa8:	68da      	ldr	r2, [r3, #12]
 8000faa:	687b      	ldr	r3, [r7, #4]
 8000fac:	681b      	ldr	r3, [r3, #0]
 8000fae:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8000fb2:	60da      	str	r2, [r3, #12]
		if(USART_Config->Rx_Interrupt_Enable == USART_RX_INTERRUPT_ENABLED)
 8000fb4:	687b      	ldr	r3, [r7, #4]
 8000fb6:	7adb      	ldrb	r3, [r3, #11]
 8000fb8:	2b01      	cmp	r3, #1
 8000fba:	d107      	bne.n	8000fcc <MCAL_USART_Init+0x1e0>
			SET_BIT(USART_Config->USARTx->CR1, 5);    // Bit 5 RXNEIE: RXNE interrupt enable
 8000fbc:	687b      	ldr	r3, [r7, #4]
 8000fbe:	681b      	ldr	r3, [r3, #0]
 8000fc0:	68da      	ldr	r2, [r3, #12]
 8000fc2:	687b      	ldr	r3, [r7, #4]
 8000fc4:	681b      	ldr	r3, [r3, #0]
 8000fc6:	f042 0220 	orr.w	r2, r2, #32
 8000fca:	60da      	str	r2, [r3, #12]
	}
}
 8000fcc:	bf00      	nop
 8000fce:	3710      	adds	r7, #16
 8000fd0:	46bd      	mov	sp, r7
 8000fd2:	bd80      	pop	{r7, pc}
 8000fd4:	40013800 	.word	0x40013800
 8000fd8:	40021000 	.word	0x40021000
 8000fdc:	2000009c 	.word	0x2000009c
 8000fe0:	40004400 	.word	0x40004400
 8000fe4:	40004800 	.word	0x40004800
 8000fe8:	e000e104 	.word	0xe000e104

08000fec <USART1_IRQHandler>:

/* ================================================================ */
/* ============================= ISR ============================== */
/* ================================================================ */

void USART1_IRQHandler(void){
 8000fec:	b580      	push	{r7, lr}
 8000fee:	af00      	add	r7, sp, #0
	Global_USART_Config[0]->USARTx_CallBackFunction();
 8000ff0:	4b02      	ldr	r3, [pc, #8]	; (8000ffc <USART1_IRQHandler+0x10>)
 8000ff2:	681b      	ldr	r3, [r3, #0]
 8000ff4:	695b      	ldr	r3, [r3, #20]
 8000ff6:	4798      	blx	r3
}
 8000ff8:	bf00      	nop
 8000ffa:	bd80      	pop	{r7, pc}
 8000ffc:	2000009c 	.word	0x2000009c

08001000 <USART2_IRQHandler>:

void USART2_IRQHandler(void){
 8001000:	b580      	push	{r7, lr}
 8001002:	af00      	add	r7, sp, #0
	Global_USART_Config[1]->USARTx_CallBackFunction();
 8001004:	4b02      	ldr	r3, [pc, #8]	; (8001010 <USART2_IRQHandler+0x10>)
 8001006:	685b      	ldr	r3, [r3, #4]
 8001008:	695b      	ldr	r3, [r3, #20]
 800100a:	4798      	blx	r3
}
 800100c:	bf00      	nop
 800100e:	bd80      	pop	{r7, pc}
 8001010:	2000009c 	.word	0x2000009c

08001014 <USART3_IRQHandler>:

void USART3_IRQHandler(void){
 8001014:	b580      	push	{r7, lr}
 8001016:	af00      	add	r7, sp, #0
	Global_USART_Config[2]->USARTx_CallBackFunction();
 8001018:	4b02      	ldr	r3, [pc, #8]	; (8001024 <USART3_IRQHandler+0x10>)
 800101a:	689b      	ldr	r3, [r3, #8]
 800101c:	695b      	ldr	r3, [r3, #20]
 800101e:	4798      	blx	r3
}
 8001020:	bf00      	nop
 8001022:	bd80      	pop	{r7, pc}
 8001024:	2000009c 	.word	0x2000009c

08001028 <main>:

};
#endif

int main(void)
{
 8001028:	b580      	push	{r7, lr}
 800102a:	af00      	add	r7, sp, #0


	// Initializing the clock
	clock_Init();
 800102c:	f000 f818 	bl	8001060 <clock_Init>
	// Initialize PA4
	#ifdef MCU_SPI_MASTER
	MCAL_GPIO_Init(GPIOA, &PA4_Pin);
 8001030:	4907      	ldr	r1, [pc, #28]	; (8001050 <main+0x28>)
 8001032:	4808      	ldr	r0, [pc, #32]	; (8001054 <main+0x2c>)
 8001034:	f7ff fa00 	bl	8000438 <MCAL_GPIO_Init>
	// Set the logic of PA4 to HIGH
	MCAL_GPIO_WritePin(GPIOA, GPIO_PIN4, GPIO_HIGH);
 8001038:	2201      	movs	r2, #1
 800103a:	2104      	movs	r1, #4
 800103c:	4805      	ldr	r0, [pc, #20]	; (8001054 <main+0x2c>)
 800103e:	f7ff fa65 	bl	800050c <MCAL_GPIO_WritePin>
	#endif
	// Initializing USART1
	MCAL_USART_Init(&UART1_Config);
 8001042:	4805      	ldr	r0, [pc, #20]	; (8001058 <main+0x30>)
 8001044:	f7ff fed2 	bl	8000dec <MCAL_USART_Init>
	// Initializing SPI1
	MCAL_SPI_Init(&SPI1_Config);
 8001048:	4804      	ldr	r0, [pc, #16]	; (800105c <main+0x34>)
 800104a:	f7ff fc73 	bl	8000934 <MCAL_SPI_Init>


	while(1)
 800104e:	e7fe      	b.n	800104e <main+0x26>
 8001050:	20000018 	.word	0x20000018
 8001054:	40010800 	.word	0x40010800
 8001058:	20000000 	.word	0x20000000
 800105c:	2000001c 	.word	0x2000001c

08001060 <clock_Init>:
	{

	}
}

void clock_Init(){
 8001060:	b480      	push	{r7}
 8001062:	af00      	add	r7, sp, #0
	GPIOA_CLK_EN(); // IO port A clock enabled
 8001064:	4b0a      	ldr	r3, [pc, #40]	; (8001090 <clock_Init+0x30>)
 8001066:	699b      	ldr	r3, [r3, #24]
 8001068:	4a09      	ldr	r2, [pc, #36]	; (8001090 <clock_Init+0x30>)
 800106a:	f043 0304 	orr.w	r3, r3, #4
 800106e:	6193      	str	r3, [r2, #24]
	GPIOB_CLK_EN(); // IO port B clock enabled
 8001070:	4b07      	ldr	r3, [pc, #28]	; (8001090 <clock_Init+0x30>)
 8001072:	699b      	ldr	r3, [r3, #24]
 8001074:	4a06      	ldr	r2, [pc, #24]	; (8001090 <clock_Init+0x30>)
 8001076:	f043 0308 	orr.w	r3, r3, #8
 800107a:	6193      	str	r3, [r2, #24]
	AFIO_CLK_EN();  // AFIO cock enabled
 800107c:	4b04      	ldr	r3, [pc, #16]	; (8001090 <clock_Init+0x30>)
 800107e:	699b      	ldr	r3, [r3, #24]
 8001080:	4a03      	ldr	r2, [pc, #12]	; (8001090 <clock_Init+0x30>)
 8001082:	f043 0301 	orr.w	r3, r3, #1
 8001086:	6193      	str	r3, [r2, #24]
}
 8001088:	bf00      	nop
 800108a:	46bd      	mov	sp, r7
 800108c:	bc80      	pop	{r7}
 800108e:	4770      	bx	lr
 8001090:	40021000 	.word	0x40021000

08001094 <MyUSART1_IRQHandler>:

void MyUSART1_IRQHandler(void)
{
 8001094:	b580      	push	{r7, lr}
 8001096:	b082      	sub	sp, #8
 8001098:	af00      	add	r7, sp, #0
	#ifdef MCU_SPI_MASTER
	uint16 received_byte = USART1->DR;
 800109a:	4b0d      	ldr	r3, [pc, #52]	; (80010d0 <MyUSART1_IRQHandler+0x3c>)
 800109c:	685b      	ldr	r3, [r3, #4]
 800109e:	80fb      	strh	r3, [r7, #6]
	USART1->DR = received_byte;
 80010a0:	4a0b      	ldr	r2, [pc, #44]	; (80010d0 <MyUSART1_IRQHandler+0x3c>)
 80010a2:	88fb      	ldrh	r3, [r7, #6]
 80010a4:	6053      	str	r3, [r2, #4]
	// Transmit Data on SPI
	// Set the logic of PA4 to LOW
	MCAL_GPIO_WritePin(GPIOA, GPIO_PIN4,  GPIO_LOW);  // Chip select
 80010a6:	2200      	movs	r2, #0
 80010a8:	2104      	movs	r1, #4
 80010aa:	480a      	ldr	r0, [pc, #40]	; (80010d4 <MyUSART1_IRQHandler+0x40>)
 80010ac:	f7ff fa2e 	bl	800050c <MCAL_GPIO_WritePin>
	uint16 RecievedDataFromSPI = MCAL_SPI_Transmit_Recieve(&SPI1_Config, received_byte);
 80010b0:	88fb      	ldrh	r3, [r7, #6]
 80010b2:	4619      	mov	r1, r3
 80010b4:	4808      	ldr	r0, [pc, #32]	; (80010d8 <MyUSART1_IRQHandler+0x44>)
 80010b6:	f7ff fd67 	bl	8000b88 <MCAL_SPI_Transmit_Recieve>
 80010ba:	4603      	mov	r3, r0
 80010bc:	80bb      	strh	r3, [r7, #4]
	// Set the logic of PA4 to LOW
	MCAL_GPIO_WritePin(GPIOA, GPIO_PIN4,  GPIO_HIGH);  // Chip select
 80010be:	2201      	movs	r2, #1
 80010c0:	2104      	movs	r1, #4
 80010c2:	4804      	ldr	r0, [pc, #16]	; (80010d4 <MyUSART1_IRQHandler+0x40>)
 80010c4:	f7ff fa22 	bl	800050c <MCAL_GPIO_WritePin>
	#endif
}
 80010c8:	bf00      	nop
 80010ca:	3708      	adds	r7, #8
 80010cc:	46bd      	mov	sp, r7
 80010ce:	bd80      	pop	{r7, pc}
 80010d0:	40013800 	.word	0x40013800
 80010d4:	40010800 	.word	0x40010800
 80010d8:	2000001c 	.word	0x2000001c

080010dc <Reset_Handler>:

  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_estack
 80010dc:	480d      	ldr	r0, [pc, #52]	; (8001114 <LoopForever+0x2>)
  mov   sp, r0          /* set stack pointer */
 80010de:	4685      	mov	sp, r0
/* Call the clock system intitialization function.*/
  bl  SystemInit
 80010e0:	f3af 8000 	nop.w

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
 80010e4:	480c      	ldr	r0, [pc, #48]	; (8001118 <LoopForever+0x6>)
  ldr r1, =_edata
 80010e6:	490d      	ldr	r1, [pc, #52]	; (800111c <LoopForever+0xa>)
  ldr r2, =_sidata
 80010e8:	4a0d      	ldr	r2, [pc, #52]	; (8001120 <LoopForever+0xe>)
  movs r3, #0
 80010ea:	2300      	movs	r3, #0
  b LoopCopyDataInit
 80010ec:	e002      	b.n	80010f4 <LoopCopyDataInit>

080010ee <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 80010ee:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 80010f0:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 80010f2:	3304      	adds	r3, #4

080010f4 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 80010f4:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 80010f6:	428c      	cmp	r4, r1
  bcc CopyDataInit
 80010f8:	d3f9      	bcc.n	80010ee <CopyDataInit>

/* Zero fill the bss segment. */
  ldr r2, =_sbss
 80010fa:	4a0a      	ldr	r2, [pc, #40]	; (8001124 <LoopForever+0x12>)
  ldr r4, =_ebss
 80010fc:	4c0a      	ldr	r4, [pc, #40]	; (8001128 <LoopForever+0x16>)
  movs r3, #0
 80010fe:	2300      	movs	r3, #0
  b LoopFillZerobss
 8001100:	e001      	b.n	8001106 <LoopFillZerobss>

08001102 <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 8001102:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 8001104:	3204      	adds	r2, #4

08001106 <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 8001106:	42a2      	cmp	r2, r4
  bcc FillZerobss
 8001108:	d3fb      	bcc.n	8001102 <FillZerobss>

/* Call static constructors */
  bl __libc_init_array
 800110a:	f000 f811 	bl	8001130 <__libc_init_array>
/* Call the application's entry point.*/
  bl main
 800110e:	f7ff ff8b 	bl	8001028 <main>

08001112 <LoopForever>:

LoopForever:
    b LoopForever
 8001112:	e7fe      	b.n	8001112 <LoopForever>
  ldr   r0, =_estack
 8001114:	20002800 	.word	0x20002800
  ldr r0, =_sdata
 8001118:	20000000 	.word	0x20000000
  ldr r1, =_edata
 800111c:	20000038 	.word	0x20000038
  ldr r2, =_sidata
 8001120:	080011f8 	.word	0x080011f8
  ldr r2, =_sbss
 8001124:	20000038 	.word	0x20000038
  ldr r4, =_ebss
 8001128:	200000a8 	.word	0x200000a8

0800112c <ADC1_2_IRQHandler>:
 * @retval : None
*/
  .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
 800112c:	e7fe      	b.n	800112c <ADC1_2_IRQHandler>
	...

08001130 <__libc_init_array>:
 8001130:	b570      	push	{r4, r5, r6, lr}
 8001132:	2500      	movs	r5, #0
 8001134:	4e0c      	ldr	r6, [pc, #48]	; (8001168 <__libc_init_array+0x38>)
 8001136:	4c0d      	ldr	r4, [pc, #52]	; (800116c <__libc_init_array+0x3c>)
 8001138:	1ba4      	subs	r4, r4, r6
 800113a:	10a4      	asrs	r4, r4, #2
 800113c:	42a5      	cmp	r5, r4
 800113e:	d109      	bne.n	8001154 <__libc_init_array+0x24>
 8001140:	f000 f81a 	bl	8001178 <_init>
 8001144:	2500      	movs	r5, #0
 8001146:	4e0a      	ldr	r6, [pc, #40]	; (8001170 <__libc_init_array+0x40>)
 8001148:	4c0a      	ldr	r4, [pc, #40]	; (8001174 <__libc_init_array+0x44>)
 800114a:	1ba4      	subs	r4, r4, r6
 800114c:	10a4      	asrs	r4, r4, #2
 800114e:	42a5      	cmp	r5, r4
 8001150:	d105      	bne.n	800115e <__libc_init_array+0x2e>
 8001152:	bd70      	pop	{r4, r5, r6, pc}
 8001154:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 8001158:	4798      	blx	r3
 800115a:	3501      	adds	r5, #1
 800115c:	e7ee      	b.n	800113c <__libc_init_array+0xc>
 800115e:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 8001162:	4798      	blx	r3
 8001164:	3501      	adds	r5, #1
 8001166:	e7f2      	b.n	800114e <__libc_init_array+0x1e>
 8001168:	080011f0 	.word	0x080011f0
 800116c:	080011f0 	.word	0x080011f0
 8001170:	080011f0 	.word	0x080011f0
 8001174:	080011f4 	.word	0x080011f4

08001178 <_init>:
 8001178:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800117a:	bf00      	nop
 800117c:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800117e:	bc08      	pop	{r3}
 8001180:	469e      	mov	lr, r3
 8001182:	4770      	bx	lr

08001184 <_fini>:
 8001184:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001186:	bf00      	nop
 8001188:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800118a:	bc08      	pop	{r3}
 800118c:	469e      	mov	lr, r3
 800118e:	4770      	bx	lr
