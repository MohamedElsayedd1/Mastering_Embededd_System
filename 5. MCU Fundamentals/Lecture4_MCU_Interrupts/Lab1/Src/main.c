/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

#include <stdint.h>

#define EXTI0_IRQN			6

#define RCC_BASE_ADDRESS 	0x40021000
#define PORTA_BASE_ADDRESS 	0x40010800
#define EXTI_BASE_ADDRESS   0x40010400
#define AFIO_BASE_ADDRESS   0x40010000

#define RCC_APB2ENR_OFFSET  0x18
#define GPIOA_CRH_OFFSET	0x04
#define GPIOA_ODR_OFFSET	0x0C
#define GPIOA_CRL_OFFSET    0x00
#define AFIO_EXTICR1_OFFSET 0x08
#define EXTI_IMR_OFFSET		0x00
#define EXTI_EMR_OFFSET		0x04
#define EXTI_RTSR_OFFSET	0x08
#define EXTI_FTSR_OFFSET	0x0C
#define EXTI_SWIER_OFFSET	0x10
#define EXTI_PR_OFFSET		0x14

#define RCC_APB2ENR 		*((volatile uint32_t *)(RCC_BASE_ADDRESS + RCC_APB2ENR_OFFSET))
#define GPIOA_CRH 			*((volatile uint32_t *)(PORTA_BASE_ADDRESS + GPIOA_CRH_OFFSET))
#define GPIOA_ODR			*((volatile uint32_t *)(PORTA_BASE_ADDRESS + GPIOA_ODR_OFFSET))
#define GPIOA_CRL		    *((volatile uint32_t *)(PORTA_BASE_ADDRESS + GPIOA_CRL_OFFSET))
#define AFIO_EXTICR1		*((volatile uint32_t *)(AFIO_BASE_ADDRESS + AFIO_EXTICR1_OFFSET))
#define EXTI_IMR			*((volatile uint32_t *)(EXTI_BASE_ADDRESS + EXTI_IMR_OFFSET))
#define EXTI_EMR			*((volatile uint32_t *)(EXTI_BASE_ADDRESS + EXTI_EMR_OFFSET))
#define EXTI_RTSR			*((volatile uint32_t *)(EXTI_BASE_ADDRESS + EXTI_RTSR_OFFSET))
#define EXTI_FTSR			*((volatile uint32_t *)(EXTI_BASE_ADDRESS + EXTI_FTSR_OFFSET))
#define EXTI_SWIER			*((volatile uint32_t *)(EXTI_BASE_ADDRESS + EXTI_SWIER_OFFSET))
#define EXTI_PR				*((volatile uint32_t *)(EXTI_BASE_ADDRESS + EXTI_PR_OFFSET))
#define NVIC_INTERRUPT_EN 	*((volatile uint32_t *)(0xE000E100))

typedef union{
	volatile uint32_t All_Ports;
	struct{
		volatile uint32_t RESERVED : 12;
		volatile uint32_t PIN13 : 1;
	}Bit_field;
}ODR_REG_t;

volatile ODR_REG_t *ODR = ((volatile ODR_REG_t *)(PORTA_BASE_ADDRESS + GPIOA_ODR_OFFSET));

void clock_init(void){
	// Enable GPIO clock
	RCC_APB2ENR |= (1 << 2);
	// Enable AFIO clock
	// 1: Alternate Function IO clock enabled
	RCC_APB2ENR |= (1 << 0);
}

void GPIO_Init(void){
	// Configure PA13 as output push-pull
	// 10: Alternate function output Push-pull
	// PA13 used to toggle the led if interrupt is triggered on PA0
	GPIOA_CRH &= ~(0xF << 20);
	GPIOA_CRH |= (0x2 << 20);
	// Configue PA0 as input
	GPIOA_CRL &= ~(0b11 << 0);
	// Configue PA0 as Floating input (reset state)
	// 01: Floating input (reset state)
	GPIOA_CRL &= ~(0b11 << 2);
	GPIOA_CRL |= (0b01 << 2);
}

void delay(volatile int count) {
    while(count--);
}

void NVIC_EnableIRQ(uint32_t IRQn){
	NVIC_INTERRUPT_EN |= (1 << IRQn);
}

void EXTI0_init(void){
	// Select PA0 for external interrupt 0 (EXTI0 -> PA0)
	// 0000: PA[x] pin
	AFIO_EXTICR1 &= ~(0b1111 << 0);
	// Enable external interrupt 0 mask (EXTI0) in EXTI_IMR register
	EXTI_IMR |= (1 << 0);
	// Enable rising edge detection for input line
	EXTI_RTSR |= (1 << 0);
	// Enable EXTI0 interrupt in NVIC
	NVIC_EnableIRQ(EXTI0_IRQN);
}


int main(void)
{
	clock_init();
	GPIO_Init();
	/*
		To configure the 20 lines as interrupt sources, use the following procedure:
		• Configure the mask bits of the 20 Interrupt lines (EXTI_IMR)
		• Configure the Trigger Selection bits of the Interrupt lines (EXTI_RTSR and
		EXTI_FTSR)
		• Configure the enable and mask bits that control the NVIC IRQ channel mapped to the
		External Interrupt Controller (EXTI) so that an interrupt coming from one of the 20 lines
		can be correctly acknowledged
	 */
	EXTI0_init();

    /* Loop forever */
	while(1){
		// Do nothing
	}

	return 0;
}

void EXTI0_IRQHandler(void){
	// EXTI0 is triggered on PORTA0, rising edge
	// Clear interrupt status flag
	// This bit is set when the selected edge event arrives on the external interrupt line. This bit is cleared by writing a ‘1’ into the bit.
	EXTI_PR |= (1 << 0);
	// Toggle bit 13 in PORTA -> PA0
	GPIOA_ODR ^= (1 << 13);
}
