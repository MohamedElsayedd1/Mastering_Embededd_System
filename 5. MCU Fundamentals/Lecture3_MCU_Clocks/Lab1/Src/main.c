/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

//Learn-in-depth
//Mohamed Elsayed
//Mastering Embedded System online diploma

#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>

typedef volatile unsigned int vuint32_t;

// Register base addresses
#define GPIOA_BASE      0x40010800
#define RCC_BASE        0x40021000

// Register offsets
#define GPIOA_CRH       *(vuint32_t *)(GPIOA_BASE + 0x04)   // GPIOA configuration register high
#define GPIOA_ODR       *(vuint32_t *)(GPIOA_BASE + 0x0C)   // GPIOA output data register
#define RCC_APB2ENR     *(vuint32_t *)(RCC_BASE + 0x18)     // RCC APB2 peripheral clock enable register
#define RCC_CFGR 		*(vuint32_t *)(RCC_BASE + 0x04)
int main(void)
{
	// HSE selected as system clock, HSI clock = 00: HSI selected as system clock
	RCC_CFGR &= 0xFFFFFFFC;

	// HPRE: AHB prescaler, 0xxx: SYSCLK not divided
	RCC_CFGR &= ~(1 << 7);

	//  PPRE1: APB low-speed prescaler (APB1),  100: HCLK divided by 2
	// Clear bit 8 to bit 10
	RCC_CFGR &= ~(0b111 << 8);
	// Set value 100 from bit 8 to bit 10
	RCC_CFGR |= (0b100 << 8);

	// PPRE2: APB high-speed prescaler (APB2), 101: HCLK divided by 4
	RCC_CFGR &= ~(0x07 << 11);
	RCC_CFGR |= (0x05 << 11);

	// MCO: Microcontroller clock output, 101: HSI clock selected
	RCC_CFGR &= ~(0b111 << 24);
	RCC_CFGR |= (0b101 << 24);

    // Enable clock for GPIOA by setting bit 2 in RCC_APB2ENR
    RCC_APB2ENR |= (1 << 2);

    // Configure PA13 as general-purpose output push-pull, max speed 2 MHz
    // First clear the relevant bits (bits 23-20) and then set the configuration for PA13
    GPIOA_CRH &= 0xFF0FFFFF;  // Clear bits 20-23
    GPIOA_CRH |= 0x00200000;  // Set bits 21 for output mode (2 MHz) and clear bits 22-23 for general purpose output push-pull

    // Infinite loop to toggle the LED on PA13
    while (1)
    {
        // Set PA13 high (turn LED on)
        GPIOA_ODR |= (1 << 13);

        // Delay loop (arbitrary delay)
        for (int i = 0; i < 5000; i++);

        // Set PA13 low (turn LED off)
        GPIOA_ODR &= ~(1 << 13);

        // Delay loop (arbitrary delay)
        for (int i = 0; i < 5000; i++);
    }
}
