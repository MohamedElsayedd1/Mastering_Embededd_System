/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

//Learn-in-depth
//Mohamed Elsayed
//Mastering Embedded System online diploma

#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>

typedef volatile unsigned int vuint32_t;

// Register base addresses
#define GPIOA_BASE      0x40010800
#define RCC_BASE        0x40021000

// Register offsets
#define GPIOA_CRH       *(vuint32_t *)(GPIOA_BASE + 0x04)   // GPIOA configuration register high
#define GPIOA_ODR       *(vuint32_t *)(GPIOA_BASE + 0x0C)   // GPIOA output data register
#define RCC_APB2ENR     *(vuint32_t *)(RCC_BASE + 0x18)     // RCC APB2 peripheral clock enable register
#define RCC_CFGR 		*(vuint32_t *)(RCC_BASE + 0x04)
#define RCC_CR 			*(vuint32_t *)(RCC_BASE + 0x00)

int main(void)
{
	/*
	 * The PLL configuration, including setting the multiplication factor (PLLMUL),
	 *  can only be modified when the PLL is disabled. If the PLL is already enabled,
	 *   any attempt to change the configuration will not take effect.
	 */
	RCC_CFGR &= ~(0b1111 << 18);      // Clear PLLMUL bits
	RCC_CFGR |= (0b0110 << 18);       // Set PLLMUL to 8x
	RCC_CFGR |= (1 << 1);             // Select PLL as system clock

	// Reset PPRE1 (APB1) bits (bits 10:8)
	RCC_CFGR &= ~(0b111 << 8);

	// Set APB1 prescaler to divide by 2 (HCLK / 2)
	RCC_CFGR |= (0b100 << 8);  // APB1 = HCLK / 2

	// Reset PPRE2 (APB2) bits (bits 13:11)
	RCC_CFGR &= ~(0b111 << 11);

	// Set APB2 prescaler to divide by 4 (HCLK / 4)
	RCC_CFGR |= (0b101 << 11);  // APB2 = HCLK / 4

	RCC_CR |= (1 << 24);              // Enable PLL

    // Enable clock for GPIOA by setting bit 2 in RCC_APB2ENR
    RCC_APB2ENR |= (1 << 2);

    // Configure PA13 as general-purpose output push-pull, max speed 2 MHz
    // First clear the relevant bits (bits 23-20) and then set the configuration for PA13
    GPIOA_CRH &= 0xFF0FFFFF;  // Clear bits 20-23
    GPIOA_CRH |= 0x00200000;  // Set bits 21 for output mode (2 MHz) and clear bits 22-23 for general purpose output push-pull

    // Infinite loop to toggle the LED on PA13
    while (1)
    {
        // Set PA13 high (turn LED on)
        GPIOA_ODR |= (1 << 13);

        // Delay loop (arbitrary delay)
        for (int i = 0; i < 5000; i++);

        // Set PA13 low (turn LED off)
        GPIOA_ODR &= ~(1 << 13);

        // Delay loop (arbitrary delay)
        for (int i = 0; i < 5000; i++);
    }
}
