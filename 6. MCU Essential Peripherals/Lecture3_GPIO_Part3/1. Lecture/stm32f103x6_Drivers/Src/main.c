/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

#include "stm32f103x6_GPIO_driver.h"
#include "stm32f103x6.h"

void clock_Init(){
	GPIOA_CLK_EN(); // IO port A clock enabled
	GPIOB_CLK_EN(); // IO port B clock enabled
}

void GPIO_Init(){
	GPIO_PinConfig_t PA1, PA13, PB1, PB13;

	PA1.PinMode = GPIO_INPUT;
	PA1.PinCNF = GPIO_CNF_FLOATING_INPUT;
	PA1.PinNum = 1;

	PA13.PinMode = GPIO_INPUT;
	PA13.PinCNF = GPIO_CNF_FLOATING_INPUT;
	PA13.PinNum = 13;

	PB1.PinMode = GPIO_OUTPUT_2MHZ;
	PB1.PinCNF = GPIO_CNF_PUSH_PULL_OUTPUT;
	PB1.PinNum = 1;

	PB13.PinMode = GPIO_OUTPUT_2MHZ;
	PB13.PinCNF = GPIO_CNF_PUSH_PULL_OUTPUT;
	PB13.PinNum = 13;

	// Configure PA1 and PA13 as Floating Input
	MCAL_GPIO_Init(GPIOA, &PA1);
	MCAL_GPIO_Init(GPIOA, &PA13);

	// Configure PB1 and PB13 as Push-Pull Output
	MCAL_GPIO_Init(GPIOB, &PB1);
	MCAL_GPIO_Init(GPIOB, &PB13);
}

GPIO_PinState_t ReadPushButton1(void){
	// Read the logic of PA1 pin -> Push-Up Resistor (High)
	GPIO_PinState_t btn1_state = MCAL_GPIO_ReadPin(GPIOA, 1);
	return btn1_state;
}

GPIO_PinState_t ReadPushButton2(void){
	// Read the logic of PA13 pin -> Push-Down Resistor (Low)
	GPIO_PinState_t btn2_state = MCAL_GPIO_ReadPin(GPIOA, 13);
	return btn2_state;
}

void delay(volatile int count) {
    while(count--);
}

GPIO_PinState_t btn1_prev = GPIO_HIGH;
GPIO_PinState_t btn2_prev = GPIO_LOW;

int main(void)
{
    clock_Init();
    GPIO_Init();
    while(1){
        GPIO_PinState_t btn1_current = ReadPushButton1();
        if(btn1_current == GPIO_LOW && btn1_prev == GPIO_HIGH){
            MCAL_GPIO_TogglePin(GPIOB, 1);
        }
        btn1_prev = btn1_current;

        GPIO_PinState_t btn2_current = ReadPushButton2();
        if(btn2_current == GPIO_HIGH){
            MCAL_GPIO_TogglePin(GPIOB, 13);
        }
        delay(100000);
    }

}
